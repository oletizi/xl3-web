<!-- Generated by SpecStory -->

# Google OAuth Simplification: Faster, Cleaner Authentication (2025-10-08 14:58:40Z)

<!-- Claude Code Session 0eb82cb5-f8e9-48b6-ad68-dff0fd18baa0 (2025-10-08_14-58-40Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/docs/1.0/authentication/implementation/workplan.md b/docs/1.0/authentication/implementation/workplan.md
new file mode 100644
index 0000000..e0446a2
--- /dev/null
+++ b/docs/1.0/authentication/implementation/workplan.md
@@ -0,0 +1,2121 @@
+# Authentication Module Implementation Workplan
+
+**Version:** 1.2
+**Date:** 2025-10-08
+**Status:** Planning
+**Target:** Google OAuth-only authentication with Supabase
+
+## Table of Contents
+
+1. [Architecture Overview](#1-architecture-overview)
+2. [Technical Design](#2-technical-design)
+3. [Implementation Steps](#3-implementation-steps)
+4. [File Structure](#4-file-structure)
+5. [Code Specifications](#5-code-specifications)
+6. [Testing Strategy](#6-testing-strategy)
+7. [Security Checklist](#7-security-checklist)
+8. [Integration Points](#8-integration-points)
+9. [Development Timeline](#9-development-timeline)
+10. [Acceptance Criteria](#10-acceptance-criteria)
+11. [Security Architecture](#11-security-architecture)
+12. [Appendices](#appendices)
+
+---
+
+## 1. Architecture Overview
+
+### 1.1 Authentication Flow Diagrams
+
+#### OAuth Flow (Google)
+
+```
+┌─────────┐                   ┌──────────┐                   ┌─────────────┐
+│ Browser │                   │   App    │                   │  Supabase   │
+└────┬────┘                   └────┬─────┘                   └──────┬──────┘
+     │                             │                                 │
+     │  1. Click "Sign in with    │                                 │
+     │     Google"                 │                                 │
+     │────────────────────────────>│                                 │
+     │                             │                                 │
+     │                             │  2. Initiate OAuth              │
+     │                             │────────────────────────────────>│
+     │                             │                                 │
+     │                             │  3. Redirect to Provider        │
+     │<────────────────────────────┼─────────────────────────────────│
+     │                             │                                 │
+     │  4. Authenticate with       │                                 │
+     │     Provider (external)     │                                 │
+     │                             │                                 │
+     │  5. Redirect back with code │                                 │
+     │────────────────────────────>│                                 │
+     │                             │                                 │
+     │                             │  6. Exchange code for tokens    │
+     │                             │────────────────────────────────>│
+     │                             │                                 │
+     │                             │  7. Return JWT + refresh token  │
+     │                             │<────────────────────────────────│
+     │                             │                                 │
+     │                             │  8. Store session               │
+     │                             │    (managed by Supabase)        │
+     │                             │                                 │
+     │  9. Render authenticated UI │                                 │
+     │<────────────────────────────│                                 │
+```
+
+#### Session Refresh Flow
+
+```
+┌─────────┐                   ┌──────────┐                   ┌─────────────┐
+│ Browser │                   │   App    │                   │  Supabase   │
+└────┬────┘                   └────┬─────┘                   └──────┬──────┘
+     │                             │                                 │
+     │                             │  1. JWT expires                 │
+     │                             │    (detected via API error 401) │
+     │                             │                                 │
+     │                             │  2. refreshSession()            │
+     │                             │────────────────────────────────>│
+     │                             │                                 │
+     │                             │  3. Validate refresh token      │
+     │                             │                                 │
+     │                             │  4. Return new JWT              │
+     │                             │<────────────────────────────────│
+     │                             │                                 │
+     │                             │  5. Retry original request      │
+     │                             │────────────────────────────────>│
+     │                             │                                 │
+     │  6. Continue without        │                                 │
+     │     interruption            │                                 │
+     │<────────────────────────────│                                 │
+```
+
+### 1.2 Session Management Strategy
+
+**Token Storage:**
+- JWT access token and refresh token managed by Supabase client
+- Session persists across browser tabs and page refreshes
+- Automatic session restoration on app load
+
+**Token Lifecycle:**
+- Access token expires after 1 hour (Supabase default)
+- Refresh token valid for 30 days (configurable)
+- Automatic token refresh via Supabase client
+- Manual refresh triggers on 401 responses
+
+**Session Invalidation:**
+- Explicit sign-out removes all tokens
+- Token expiry triggers automatic refresh
+- Network errors gracefully handled with retry logic
+
+### 1.3 Security Considerations
+
+**Token Security:**
+- JWT tokens contain minimal user data (id, email, metadata)
+- Supabase manages token storage securely
+- Token exposure mitigated by short expiry times
+- HTTPS required in production
+
+**CSRF Protection:**
+- State parameter in OAuth flow prevents CSRF
+- PKCE flow for enhanced OAuth security
+- Origin validation for callback URLs
+
+**XSS Prevention:**
+- React automatically escapes rendered content
+- No innerHTML or dangerouslySetInnerHTML with user data
+- Content Security Policy headers in production
+
+**Redirect Safety:**
+- Whitelist allowed redirect URLs in Supabase dashboard
+- Validate redirect parameters client-side
+- Never redirect to user-provided URLs without validation
+
+---
+
+## 2. Technical Design
+
+### 2.1 Supabase Configuration
+
+#### Project Setup
+
+```typescript
+// src/lib/supabase.ts
+
+import { createClient } from '@supabase/supabase-js';
+import type { Database } from '@/types/supabase';
+
+const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
+const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
+
+if (!supabaseUrl || !supabaseAnonKey) {
+  throw new Error('Missing Supabase environment variables. Check .env file.');
+}
+
+export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
+  auth: {
+    autoRefreshToken: true,
+    persistSession: true,
+    detectSessionInUrl: true,
+    flowType: 'pkce', // Proof Key for Code Exchange for enhanced security
+  },
+});
+```
+
+#### Environment Variables
+
+```bash
+# .env.example
+
+# Supabase Configuration
+VITE_SUPABASE_URL=https://your-project.supabase.co
+VITE_SUPABASE_ANON_KEY=your-anon-key-here
+
+# Optional: Custom redirect URLs
+VITE_AUTH_REDIRECT_URL=http://localhost:8080/auth/callback
+VITE_APP_URL=http://localhost:8080
+```
+
+### 2.2 React Context Architecture
+
+#### AuthContext Structure
+
+```typescript
+// src/contexts/AuthContext.tsx
+
+import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
+import { User, Session } from '@supabase/supabase-js';
+import { supabase } from '@/lib/supabase';
+
+interface AuthState {
+  // User & session data
+  user: User | null;
+  session: Session | null;
+
+  // Loading states
+  loading: boolean;
+
+  // Auth methods
+  signInWithGoogle: () => Promise<void>;
+  signOut: () => Promise<void>;
+
+  // Utility methods
+  refreshSession: () => Promise<void>;
+  isAuthenticated: boolean;
+}
+
+const AuthContext = createContext<AuthState | undefined>(undefined);
+
+export function AuthProvider({ children }: { children: ReactNode }) {
+  const [user, setUser] = useState<User | null>(null);
+  const [session, setSession] = useState<Session | null>(null);
+  const [loading, setLoading] = useState(true);
+
+  useEffect(() => {
+    // Get initial session
+    supabase.auth.getSession().then(({ data: { session } }) => {
+      setSession(session);
+      setUser(session?.user ?? null);
+      setLoading(false);
+    });
+
+    // Listen for auth changes
+    const {
+      data: { subscription },
+    } = supabase.auth.onAuthStateChange((_event, session) => {
+      setSession(session);
+      setUser(session?.user ?? null);
+      setLoading(false);
+    });
+
+    return () => subscription.unsubscribe();
+  }, []);
+
+  const value: AuthState = {
+    user,
+    session,
+    loading,
+    signInWithGoogle: async () => {
+      const { error } = await supabase.auth.signInWithOAuth({
+        provider: 'google',
+        options: {
+          redirectTo: `${window.location.origin}/auth/callback`,
+        },
+      });
+      if (error) throw error;
+    },
+    signOut: async () => {
+      const { error } = await supabase.auth.signOut();
+      if (error) throw error;
+    },
+    refreshSession: async () => {
+      const { error } = await supabase.auth.refreshSession();
+      if (error) throw error;
+    },
+    isAuthenticated: !!user,
+  };
+
+  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
+}
+
+export function useAuth() {
+  const context = useContext(AuthContext);
+  if (context === undefined) {
+    throw new Error('useAuth must be used within an AuthProvider');
+  }
+  return context;
+}
+```
+
+### 2.3 Protected Routes Implementation
+
+```typescript
+// src/components/auth/ProtectedRoute.tsx
+
+import { ReactNode } from 'react';
+import { Navigate, useLocation } from 'react-router-dom';
+import { useAuth } from '@/contexts/AuthContext';
+import { Skeleton } from '@/components/ui/skeleton';
+
+interface ProtectedRouteProps {
+  children: ReactNode;
+  redirectTo?: string;
+}
+
+export function ProtectedRoute({
+  children,
+  redirectTo = '/login'
+}: ProtectedRouteProps) {
+  const { user, loading } = useAuth();
+  const location = useLocation();
+
+  if (loading) {
+    return (
+      <div className="flex items-center justify-center min-h-screen">
+        <div className="space-y-4 w-full max-w-md">
+          <Skeleton className="h-12 w-full" />
+          <Skeleton className="h-12 w-full" />
+          <Skeleton className="h-12 w-full" />
+        </div>
+      </div>
+    );
+  }
+
+  if (!user) {
+    return <Navigate to={redirectTo} state={{ from: location }} replace />;
+  }
+
+  return <>{children}</>;
+}
+```
+
+### 2.4 Session Refresh Logic
+
+```typescript
+// src/lib/api-client.ts
+
+import { supabase } from '@/lib/supabase';
+
+export interface ApiClientConfig {
+  baseUrl: string;
+  timeout?: number;
+}
+
+export class ApiClient {
+  private baseUrl: string;
+  private timeout: number;
+
+  constructor(config: ApiClientConfig) {
+    this.baseUrl = config.baseUrl;
+    this.timeout = config.timeout ?? 30000;
+  }
+
+  private async getAuthToken(): Promise<string | null> {
+    const { data: { session }, error } = await supabase.auth.getSession();
+
+    if (error) {
+      throw new Error(`Failed to get auth session: ${error.message}`);
+    }
+
+    return session?.access_token ?? null;
+  }
+
+  private async refreshSessionIfNeeded(error: Response): Promise<boolean> {
+    if (error.status === 401) {
+      try {
+        const { error: refreshError } = await supabase.auth.refreshSession();
+        if (refreshError) {
+          throw refreshError;
+        }
+        return true;
+      } catch (err) {
+        console.error('Session refresh failed:', err);
+        await supabase.auth.signOut();
+        return false;
+      }
+    }
+    return false;
+  }
+
+  async request<T>(
+    endpoint: string,
+    options: RequestInit = {}
+  ): Promise<T> {
+    const token = await this.getAuthToken();
+
+    const headers: HeadersInit = {
+      'Content-Type': 'application/json',
+      ...options.headers,
+    };
+
+    if (token) {
+      headers['Authorization'] = `Bearer ${token}`;
+    }
+
+    const controller = new AbortController();
+    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
+
+    try {
+      const response = await fetch(`${this.baseUrl}${endpoint}`, {
+        ...options,
+        headers,
+        signal: controller.signal,
+      });
+
+      clearTimeout(timeoutId);
+
+      if (response.status === 401) {
+        const refreshed = await this.refreshSessionIfNeeded(response);
+        if (refreshed) {
+          return this.request<T>(endpoint, options);
+        }
+      }
+
+      if (!response.ok) {
+        const error = await response.json().catch(() => ({
+          message: 'Request failed'
+        }));
+        throw new Error(error.message || `HTTP ${response.status}`);
+      }
+
+      return response.json();
+    } catch (error: any) {
+      clearTimeout(timeoutId);
+      if (error.name === 'AbortError') {
+        throw new Error('Request timeout');
+      }
+      throw error;
+    }
+  }
+
+  get<T>(endpoint: string): Promise<T> {
+    return this.request<T>(endpoint, { method: 'GET' });
+  }
+
+  post<T>(endpoint: string, data: any): Promise<T> {
+    return this.request<T>(endpoint, {
+      method: 'POST',
+      body: JSON.stringify(data),
+    });
+  }
+
+  put<T>(endpoint: string, data: any): Promise<T> {
+    return this.request<T>(endpoint, {
+      method: 'PUT',
+      body: JSON.stringify(data),
+    });
+  }
+
+  delete<T>(endpoint: string): Promise<T> {
+    return this.request<T>(endpoint, { method: 'DELETE' });
+  }
+}
+
+export const apiClient = new ApiClient({
+  baseUrl: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api/v1',
+});
+```
+
+---
+
+## 3. Implementation Steps
+
+### Phase 1: Environment Setup (2-3 hours)
+
+#### 3.1 Install Dependencies
+
+```bash
+pnpm add @supabase/supabase-js
+```
+
+#### 3.2 Create Supabase Project
+
+1. Go to https://supabase.com
+2. Create new project: "xl3-web-auth"
+3. Note project URL and anon key
+4. Configure authentication providers:
+   - Enable Google OAuth only
+   - **Disable** Email/Password authentication
+   - **Disable** GitHub OAuth (keeping it simple)
+
+#### 3.3 Configure OAuth Providers
+
+**Google OAuth:**
+1. Go to [Google Cloud Console](https://console.cloud.google.com/)
+2. Navigate to APIs & Services → Credentials
+3. Create OAuth 2.0 Client ID (Application type: Web application)
+4. Add authorized redirect URI: `https://your-project.supabase.co/auth/v1/callback`
+5. Copy Client ID and Client Secret
+6. In Supabase: Authentication → Providers → Google → Enable and paste credentials
+7. Test the OAuth flow to ensure it works
+
+#### 3.4 Environment Variables
+
+Create `.env` file:
+
+```bash
+VITE_SUPABASE_URL=https://your-project.supabase.co
+VITE_SUPABASE_ANON_KEY=your-anon-key
+VITE_API_BASE_URL=https://your-project.supabase.co
+```
+
+### Phase 2: Core Authentication (4-6 hours)
+
+#### 3.5 Create Supabase Client
+
+- **File:** `src/lib/supabase.ts`
+- Initialize Supabase client with PKCE flow
+- Export singleton instance
+
+#### 3.6 Create Type Definitions
+
+- **File:** `src/types/auth.ts`
+- Define User, Session, AuthError interfaces
+
+#### 3.7 Create AuthContext
+
+- **File:** `src/contexts/AuthContext.tsx`
+- Implement AuthProvider component
+- Create useAuth hook
+- Handle session initialization
+- Listen for auth state changes
+
+#### 3.8 Integrate AuthProvider
+
+- **File:** `src/main.tsx`
+- Wrap app with AuthProvider
+
+### Phase 3: UI Components (3-4 hours)
+
+#### 3.9 Create Login Page
+
+- **File:** `src/pages/Login.tsx`
+- Single "Sign in with Google" button
+- Error handling for OAuth failures
+- Redirect after successful login
+- Minimal, clean UI
+- Show loading state during OAuth redirect
+
+#### 3.10 Create Auth Callback
+
+- **File:** `src/pages/AuthCallback.tsx`
+- Handle OAuth redirect
+- Show loading state
+- Handle errors
+
+#### 3.11 Create User Profile Component
+
+- **File:** `src/components/auth/UserProfile.tsx`
+- Avatar dropdown
+- User menu with sign out
+- Display user email and name from OAuth provider
+
+### Phase 4: Protected Routes (2-3 hours)
+
+#### 3.13 Create ProtectedRoute Component
+
+- **File:** `src/components/auth/ProtectedRoute.tsx`
+- Check authentication
+- Show loading state
+- Redirect if unauthenticated
+
+#### 3.14 Update Router
+
+- **File:** `src/App.tsx`
+- Wrap protected routes
+- Configure public routes
+
+### Phase 5: Session Management (3-4 hours)
+
+#### 3.15 Create API Client
+
+- **File:** `src/lib/api-client.ts`
+- Auto-inject auth token
+- Handle 401 with refresh
+- Implement timeout
+
+#### 3.16 Update CloudStorageService
+
+- **File:** `src/lib/services/cloud-storage.ts`
+- Use ApiClient for requests
+
+### Phase 6: Testing (4-6 hours)
+
+See Section 6 for detailed testing strategy.
+
+---
+
+## 4. File Structure
+
+### New Files to Create
+
+```
+src/
+├── lib/
+│   ├── supabase.ts                    # Supabase client
+│   ├── api-client.ts                  # HTTP client with auth
+│   └── errors.ts                      # Auth error classes
+│
+├── contexts/
+│   └── AuthContext.tsx                # Auth state and methods
+│
+├── hooks/
+│   ├── useAuth.ts                     # Re-export from AuthContext
+│   └── useRequireAuth.ts              # Hook to enforce auth
+│
+├── components/
+│   └── auth/
+│       ├── ProtectedRoute.tsx         # Route wrapper
+│       ├── UserProfile.tsx            # User dropdown
+│       └── AuthStatus.tsx             # Auth state indicator
+│
+├── pages/
+│   ├── Login.tsx                      # Login page (OAuth only)
+│   ├── AuthCallback.tsx               # OAuth callback
+│   ├── Profile.tsx                    # User profile page
+│   └── Settings.tsx                   # User settings page
+│
+└── types/
+    ├── auth.ts                        # Auth types
+    └── supabase.ts                    # Generated Supabase types
+```
+
+### Files to Modify
+
+```
+src/
+├── main.tsx                           # Add AuthProvider
+├── App.tsx                            # Update routing
+├── components/
+│   └── Layout.tsx                     # Add UserProfile
+└── lib/services/
+    └── cloud-storage.ts               # Use apiClient
+```
+
+---
+
+## 5. Code Specifications
+
+### 5.1 Interface Definitions
+
+```typescript
+// User (from @supabase/supabase-js)
+export interface User {
+  id: string;
+  email?: string;
+  user_metadata: {
+    avatar_url?: string;
+    full_name?: string;
+    [key: string]: any;
+  };
+  created_at: string;
+}
+
+// Session (from @supabase/supabase-js)
+export interface Session {
+  access_token: string;
+  refresh_token: string;
+  expires_in: number;
+  expires_at?: number;
+  user: User;
+}
+
+// AuthState
+export interface AuthState {
+  user: User | null;
+  session: Session | null;
+  loading: boolean;
+  isAuthenticated: boolean;
+  signInWithGoogle: () => Promise<void>;
+  signOut: () => Promise<void>;
+  refreshSession: () => Promise<void>;
+}
+```
+
+### 5.2 Hook APIs
+
+```typescript
+// useAuth
+const {
+  user,
+  session,
+  loading,
+  isAuthenticated,
+  signInWithGoogle,
+  signOut
+} = useAuth();
+
+// useRequireAuth
+export function useRequireAuth(redirectTo: string = '/login') {
+  const { isAuthenticated, loading } = useAuth();
+  const navigate = useNavigate();
+
+  useEffect(() => {
+    if (!loading && !isAuthenticated) {
+      navigate(redirectTo);
+    }
+  }, [isAuthenticated, loading, navigate, redirectTo]);
+
+  return { isAuthenticated, loading };
+}
+```
+
+### 5.3 Component APIs
+
+```typescript
+// ProtectedRoute
+interface ProtectedRouteProps {
+  children: ReactNode;
+  redirectTo?: string;
+}
+
+// UserProfile
+interface UserProfileProps {
+  className?: string;
+  showEmail?: boolean;
+  menuPosition?: 'left' | 'right';
+}
+```
+
+### 5.4 Error Types
+
+```typescript
+export enum AuthErrorCode {
+  OAUTH_ERROR = 'oauth_error',
+  OAUTH_CANCELLED = 'oauth_cancelled',
+  SESSION_EXPIRED = 'session_expired',
+  NETWORK_ERROR = 'network_error',
+  UNKNOWN = 'unknown',
+}
+
+export interface AuthError {
+  code: AuthErrorCode;
+  message: string;
+  details?: any;
+}
+```
+
+---
+
+## 6. Testing Strategy
+
+### 6.1 Unit Tests
+
+```typescript
+// src/contexts/__tests__/AuthContext.test.tsx
+
+import { describe, it, expect, vi } from 'vitest';
+import { render, screen, waitFor } from '@testing-library/react';
+import { AuthProvider, useAuth } from '@/contexts/AuthContext';
+
+describe('AuthContext', () => {
+  it('should provide initial loading state', () => {
+    // Test implementation
+  });
+
+  it('should show authenticated user', async () => {
+    // Test implementation
+  });
+
+  it('should handle sign in', async () => {
+    // Test implementation
+  });
+});
+```
+
+### 6.2 Integration Tests
+
+```typescript
+// tests/e2e/auth.spec.ts
+
+import { test, expect } from '@playwright/test';
+
+test('should redirect to OAuth provider on sign in', async ({ page, context }) => {
+  await page.goto('/login');
+
+  // Click Google sign in
+  const [popup] = await Promise.all([
+    context.waitForEvent('page'),
+    page.click('button:has-text("Continue with Google")'),
+  ]);
+
+  // Should redirect to Google OAuth page
+  await expect(popup).toHaveURL(/accounts\.google\.com/);
+});
+```
+
+### 6.3 Coverage Requirements
+
+- AuthContext: 90%+
+- API Client: 85%+
+- Auth components: 80%+
+- Auth pages: 75%+
+
+---
+
+## 7. Security Checklist
+
+### 7.1 Token Storage
+
+- [x] Tokens managed by Supabase (secure)
+- [x] No tokens in URL parameters
+- [x] Session cleared on sign out
+- [x] Tokens not exposed in logs (production)
+
+### 7.2 CSRF Protection
+
+- [x] OAuth state parameter validated
+- [x] PKCE flow enabled
+- [x] Origin validation
+
+### 7.3 XSS Prevention
+
+- [x] React auto-escaping
+- [x] No dangerouslySetInnerHTML with user data
+- [x] CSP headers configured
+
+### 7.4 Redirect Safety
+
+- [x] Whitelist redirect URLs
+- [x] Validate redirect parameters
+- [x] Never use untrusted URLs
+
+### 7.5 Rate Limiting
+
+- [x] Supabase rate limiting
+- [x] Client-side debouncing
+- [x] Exponential backoff
+
+---
+
+## 8. Integration Points
+
+### 8.1 CloudStorageService Integration
+
+```typescript
+// Update CloudStorageService to use authenticated requests
+import { apiClient } from '@/lib/api-client';
+
+export class CloudStorageService {
+  async getUserModes(): Promise<CloudMode[]> {
+    return apiClient.get('/users/me/modes');
+  }
+}
+```
+
+### 8.2 React Query Integration
+
+```typescript
+export function useUserModes() {
+  const { user, isAuthenticated } = useAuth();
+
+  return useQuery({
+    queryKey: ['user-modes', user?.id],
+    queryFn: () => cloudStorage.getUserModes(),
+    enabled: isAuthenticated,
+  });
+}
+```
+
+---
+
+## 9. Development Timeline
+
+### Total: 10-15 hours (Google OAuth-only)
+
+**Week 1: Core Implementation (8-10 hours)**
+- Day 1: Setup (2h) - Supabase project, Google OAuth config
+- Day 2: Auth Context (2-3h) - AuthContext with signInWithGoogle only
+- Day 3: UI Components (2-3h) - Login page (1 button!), AuthCallback, UserProfile
+- Day 4: Integration (2h) - Protected routes, update App routing
+
+**Week 2: Polish & Testing (2-5 hours)**
+- Day 5: API Client (1-2h) - Auth token injection and refresh
+- Day 6: Testing (1-2h) - E2E OAuth flow test
+- Day 7: Final review (30min-1h) - Security review, docs
+
+---
+
+## 10. Acceptance Criteria
+
+### Feature Completion
+
+- [ ] Google OAuth sign in
+- [ ] Session persistence across page reloads
+- [ ] Protected routes with redirect to login
+- [ ] Auto token refresh on expiry
+- [ ] User profile UI with Google avatar/email
+- [ ] Sign out functionality
+- [ ] OAuth callback handling with loading state
+- [ ] Error handling for OAuth failures
+
+### Testing
+
+- [ ] 85%+ test coverage
+- [ ] All E2E tests pass
+- [ ] Manual testing checklist complete
+
+### Security
+
+- [ ] PKCE flow enabled
+- [ ] Rate limiting active
+- [ ] CSP headers configured
+- [ ] No security vulnerabilities
+
+---
+
+## 11. Security Architecture
+
+### 11.1 Threat Model
+
+#### OWASP Top 10 Mapping
+
+**A01:2021 – Broken Access Control**
+- **Risk:** Users accessing other users' modes, admin functions
+- **Mitigation:** Row-Level Security (RLS) policies, server-side authorization checks
+- **Implementation:** Supabase RLS enforces `auth.uid() = author_id` for all user data access
+
+**A02:2021 – Cryptographic Failures**
+- **Risk:** OAuth tokens exposed, session tokens stolen
+- **Mitigation:** HTTPS for all traffic, secure token storage by Supabase
+- **Implementation:** Never log tokens in production, enforce HTTPS redirects, PKCE flow
+
+**A03:2021 – Injection**
+- **Risk:** SQL injection through user input
+- **Mitigation:** Supabase uses parameterized queries, Zod validation on all inputs
+- **Implementation:** Never concatenate user input into queries
+
+**A04:2021 – Insecure Design**
+- **Risk:** Missing security controls in architecture
+- **Mitigation:** Security-first design with PKCE, rate limiting, email verification
+- **Implementation:** This workplan addresses security from day 1
+
+**A05:2021 – Security Misconfiguration**
+- **Risk:** Default credentials, exposed error messages, missing security headers
+- **Mitigation:** CSP headers, secure Supabase config, generic error messages
+- **Implementation:** See section 11.5 for secure coding guidelines
+
+**A06:2021 – Vulnerable and Outdated Components**
+- **Risk:** Old dependencies with known vulnerabilities
+- **Mitigation:** Regular `pnpm audit`, Snyk monitoring, dependency updates
+- **Implementation:** CI/CD pipeline includes security scanning
+
+**A07:2021 – Identification and Authentication Failures**
+- **Risk:** Session fixation, OAuth flow manipulation, weak session management
+- **Mitigation:** PKCE flow, session rotation, secure OAuth implementation
+- **Implementation:** See section 11.3 for OAuth security controls
+
+**A08:2021 – Software and Data Integrity Failures**
+- **Risk:** Unsigned JWTs, tampered session data
+- **Mitigation:** Supabase signs all JWTs, verify signature on every request
+- **Implementation:** ApiClient validates tokens before use
+
+**A09:2021 – Security Logging and Monitoring Failures**
+- **Risk:** No audit trail, undetected breaches
+- **Mitigation:** Log all auth events, monitor failed login attempts
+- **Implementation:** Supabase provides auth event logs, integrate with Sentry
+
+**A10:2021 – Server-Side Request Forgery (SSRF)**
+- **Risk:** Attacker-controlled URLs in OAuth redirects
+- **Mitigation:** Whitelist allowed redirect URLs, validate all redirects
+- **Implementation:** See section 7.4 for redirect safety
+
+#### React SPA-Specific Vulnerabilities
+
+**Token Exposure in Client-Side Storage**
+- **Risk:** XSS attacks stealing tokens from localStorage
+- **Mitigation:** Supabase handles token storage securely, httpOnly cookies where possible
+- **Impact:** High - tokens grant full user access
+
+**DOM-Based XSS**
+- **Risk:** Malicious scripts in user-generated content (mode names, descriptions)
+- **Mitigation:** React auto-escapes by default, DOMPurify for rich content
+- **Impact:** High - can steal tokens, perform actions as user
+
+**Open Redirects**
+- **Risk:** OAuth redirect to attacker-controlled site
+- **Mitigation:** Whitelist redirects, validate origin
+- **Impact:** Medium - phishing attacks
+
+**Client-Side Authorization Bypass**
+- **Risk:** Users modifying client code to bypass UI restrictions
+- **Mitigation:** Always enforce authorization server-side with RLS
+- **Impact:** Critical - unauthorized data access
+
+### 11.2 Security Requirements
+
+#### Token Storage
+
+**DO:**
+- Use Supabase's built-in session management
+- Let Supabase handle token storage (uses localStorage securely)
+- Clear all session data on sign out
+
+**DON'T:**
+- Store tokens in plain text anywhere
+- Store tokens in URL parameters or cookies manually
+- Log tokens in production
+
+**Implementation:**
+```typescript
+// Supabase handles this automatically
+const { data: { session } } = await supabase.auth.getSession();
+// Session includes access_token, refresh_token (stored securely by Supabase)
+```
+
+#### HTTPS Enforcement
+
+**Requirements:**
+- All production traffic over HTTPS
+- HTTP Strict Transport Security (HSTS) headers
+- Redirect HTTP to HTTPS
+
+**Implementation:**
+```typescript
+// vite.config.ts (production)
+export default defineConfig({
+  server: {
+    https: process.env.NODE_ENV === 'production',
+    headers: {
+      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
+    },
+  },
+});
+```
+
+#### CORS Configuration
+
+**Whitelist only trusted origins:**
+```typescript
+// Supabase dashboard: Authentication > URL Configuration
+// Allowed origins:
+// - http://localhost:8080 (dev)
+// - https://your-production-domain.com (prod)
+```
+
+#### Content Security Policy (CSP)
+
+**Strict CSP headers:**
+```typescript
+// vite.config.ts
+export default defineConfig({
+  server: {
+    headers: {
+      'Content-Security-Policy': [
+        "default-src 'self'",
+        "script-src 'self' 'unsafe-inline'", // React requires inline scripts
+        "style-src 'self' 'unsafe-inline'",
+        "img-src 'self' data: https:",
+        "connect-src 'self' https://*.supabase.co",
+        "font-src 'self'",
+        "object-src 'none'",
+        "base-uri 'self'",
+        "form-action 'self'",
+      ].join('; '),
+    },
+  },
+});
+```
+
+#### Cookie Security Flags
+
+**If using custom cookies (Supabase manages its own):**
+- `Secure` - only sent over HTTPS
+- `HttpOnly` - not accessible via JavaScript (prevents XSS)
+- `SameSite=Strict` - prevents CSRF
+
+### 11.3 Authentication Security Controls
+
+#### Google OAuth-Only Benefits
+
+**No Password Management:**
+- No password storage or hashing required
+- No password reset flows to secure
+- No brute force attacks on passwords
+- Users rely on Google's enterprise-grade security
+
+**Reduced Attack Surface:**
+- No account enumeration via email lookup
+- No timing attacks on password verification
+- No credential stuffing attacks
+- Delegates authentication to trusted provider (Google)
+
+**Single Provider Simplicity:**
+- One OAuth integration to maintain
+- Consistent user experience
+- Most users already have Google accounts
+- Faster implementation and testing
+
+#### OAuth Security
+
+**PKCE Flow (Proof Key for Code Exchange):**
+- Prevents authorization code interception
+- Required for all OAuth flows
+- Already enabled in Supabase config
+
+**State Parameter Validation:**
+- Prevents CSRF attacks on OAuth callback
+- Supabase handles this automatically
+
+**Redirect URI Validation:**
+- Whitelist exact redirect URLs (no wildcards)
+- Validate redirect_uri parameter matches whitelist
+- Configure in Supabase dashboard
+
+**Implementation:**
+```typescript
+// Supabase config already includes PKCE
+export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
+  auth: {
+    flowType: 'pkce', // ✅ Critical for security
+  },
+});
+```
+
+#### Session Fixation Prevention
+
+**Session Rotation:**
+- Generate new session ID on OAuth login
+- Invalidate old session ID
+- Supabase handles this automatically
+
+**Implementation:**
+```typescript
+// On OAuth login success, Supabase issues new tokens
+const { data, error } = await supabase.auth.signInWithOAuth({
+  provider: 'google',
+  options: { redirectTo: `${window.location.origin}/auth/callback` },
+});
+// Old session is invalidated, new session created after OAuth callback
+```
+
+### 11.4 Authorization Security
+
+#### Row-Level Security (RLS) Policy Audit
+
+**From research document, these RLS policies must be implemented:**
+
+```sql
+-- ✅ VERIFIED: Public modes viewable by everyone
+CREATE POLICY "Public modes are viewable by everyone"
+  ON modes FOR SELECT
+  USING (is_public = true);
+
+-- ✅ VERIFIED: Users can view own modes
+CREATE POLICY "Users can view own modes"
+  ON modes FOR SELECT
+  USING (auth.uid() = author_id);
+
+-- ✅ VERIFIED: Users can create modes
+CREATE POLICY "Users can create modes"
+  ON modes FOR INSERT
+  WITH CHECK (auth.uid() = author_id);
+
+-- ✅ VERIFIED: Users can update own modes
+CREATE POLICY "Users can update own modes"
+  ON modes FOR UPDATE
+  USING (auth.uid() = author_id);
+
+-- ✅ VERIFIED: Users can delete own modes
+CREATE POLICY "Users can delete own modes"
+  ON modes FOR DELETE
+  USING (auth.uid() = author_id);
+
+-- ⚠️ REVIEW REQUIRED: Admin policy needs custom claim
+CREATE POLICY "Admins have full access"
+  ON modes
+  USING (
+    (auth.jwt() ->> 'role')::text = 'admin'
+  );
+```
+
+**Security Concerns:**
+1. **Public modes leak check:** Ensure `is_public = true` modes don't contain PII
+2. **Admin role validation:** Custom JWT claim `role: admin` must be set server-side only
+3. **Like/rating policies:** Need policies for `mode_likes` and `mode_ratings` tables
+
+#### Principle of Least Privilege
+
+**Users can only:**
+- View public modes (read-only)
+- View/edit/delete their own modes
+- Like/rate modes they didn't create
+
+**Users cannot:**
+- Access other users' private modes
+- Edit modes they didn't create
+- Delete other users' data
+- Grant themselves admin privileges
+
+#### Token Validation on Every Request
+
+**Server-side (Supabase handles this):**
+- Verify JWT signature
+- Check expiration time
+- Validate issuer and audience
+- Enforce RLS based on `auth.uid()`
+
+**Client-side (our responsibility):**
+```typescript
+// ApiClient automatically includes token
+async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
+  const token = await this.getAuthToken(); // Validates session exists
+
+  if (!token) {
+    throw new AuthenticationError('No valid session');
+  }
+
+  headers['Authorization'] = `Bearer ${token}`;
+  // ...
+}
+```
+
+### 11.5 Secure Coding Guidelines
+
+#### Input Validation
+
+**Validate all user inputs with Zod:**
+```typescript
+// src/lib/validation/mode.ts
+
+import { z } from 'zod';
+
+const ControlMappingSchema = z.object({
+  id: z.string().uuid(),
+  type: z.enum(['knob', 'fader', 'button']),
+  ccNumber: z.number().int().min(0).max(127),
+  midiChannel: z.number().int().min(1).max(16),
+  minValue: z.number().int().min(0).max(127),
+  maxValue: z.number().int().min(0).max(127),
+  label: z.string().max(50).optional(),
+});
+
+const ModeSchema = z.object({
+  name: z.string()
+    .min(1, 'Name is required')
+    .max(100, 'Name too long')
+    .regex(/^[a-zA-Z0-9\s\-_]+$/, 'Name contains invalid characters'),
+  description: z.string()
+    .max(500, 'Description too long'),
+  version: z.string()
+    .regex(/^\d+\.\d+\.\d+$/, 'Invalid version format (use semver)'),
+  controls: z.record(ControlMappingSchema),
+  tags: z.array(z.string().max(30)).max(10),
+  category: z.string().max(50),
+});
+
+// Usage
+export function validateMode(mode: unknown) {
+  return ModeSchema.parse(mode); // Throws if invalid
+}
+```
+
+**Sanitize before storage:**
+```typescript
+// Remove potentially dangerous characters
+function sanitizeInput(input: string): string {
+  return input
+    .replace(/<script/gi, '')  // Remove script tags
+    .replace(/javascript:/gi, '')  // Remove javascript: URLs
+    .replace(/on\w+=/gi, '')  // Remove event handlers
+    .trim();
+}
+```
+
+#### XSS Prevention
+
+**React's built-in escaping:**
+```typescript
+// ✅ SAFE - React auto-escapes
+function ModeCard({ mode }: { mode: CloudMode }) {
+  return (
+    <div>
+      <h3>{mode.name}</h3> {/* React escapes this */}
+      <p>{mode.description}</p> {/* React escapes this */}
+    </div>
+  );
+}
+```
+
+**DOMPurify for rich content:**
+```typescript
+import DOMPurify from 'dompurify';
+
+// Only if you need to render HTML (avoid if possible)
+function RichDescription({ html }: { html: string }) {
+  const clean = DOMPurify.sanitize(html, {
+    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
+    ALLOWED_ATTR: ['href'],
+  });
+
+  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
+}
+```
+
+**NEVER use user input in these contexts:**
+```typescript
+// ❌ DANGEROUS - XSS vulnerability
+<div dangerouslySetInnerHTML={{ __html: userInput }} />
+<a href={userProvidedURL}>Click</a>
+<img src={userProvidedURL} />
+eval(userInput);
+new Function(userInput);
+```
+
+#### CSRF Protection
+
+**Supabase handles CSRF via:**
+- JWT tokens in Authorization header (not cookies)
+- SameSite cookie policies
+- Origin validation
+
+**Our responsibility:**
+- Never use cookies for auth manually
+- Always use POST for state-changing operations
+- Validate origin on OAuth callbacks
+
+#### Secure Redirect Validation
+
+```typescript
+// src/lib/validation/redirect.ts
+
+function getSafeRedirectUrl(url: string | null): string {
+  const allowedPaths = [
+    '/',
+    '/editor',
+    '/library',
+    '/catalog',
+    '/profile',
+    '/settings',
+  ];
+
+  if (!url) return '/';
+
+  try {
+    const parsed = new URL(url, window.location.origin);
+
+    // Only allow same-origin redirects
+    if (parsed.origin !== window.location.origin) {
+      console.warn('Blocked cross-origin redirect:', url);
+      return '/';
+    }
+
+    // Check against whitelist
+    if (allowedPaths.includes(parsed.pathname)) {
+      return parsed.pathname;
+    }
+
+    // Allow dynamic routes (e.g., /modes/:id)
+    if (parsed.pathname.startsWith('/modes/')) {
+      return parsed.pathname;
+    }
+
+    console.warn('Blocked non-whitelisted redirect:', url);
+    return '/';
+  } catch {
+    console.warn('Invalid redirect URL:', url);
+    return '/';
+  }
+}
+
+// Usage in Login component
+const from = getSafeRedirectUrl(location.state?.from?.pathname);
+navigate(from, { replace: true });
+```
+
+#### Error Message Sanitization
+
+**Don't leak sensitive information:**
+```typescript
+// ❌ BAD - reveals database structure
+throw new Error(`User not found in users table for OAuth ID: ${oauthId}`);
+
+// ❌ BAD - reveals OAuth provider details
+throw new Error('Google OAuth token is invalid or expired');
+
+// ✅ GOOD - generic, safe
+throw new Error('Authentication failed. Please try again.');
+
+// ✅ GOOD - helpful without leaking info
+throw new Error('Unable to sign in. Please check your browser allows popups and try again.');
+```
+
+**Log detailed errors server-side only:**
+```typescript
+try {
+  await supabase.auth.signInWithOAuth({ provider: 'google' });
+} catch (error: any) {
+  // Log full error for debugging (dev only)
+  if (import.meta.env.DEV) {
+    console.error('OAuth error:', error);
+  }
+
+  // Show generic error to user
+  throw new Error('Unable to sign in with Google. Please try again.');
+}
+```
+
+### 11.6 Security Testing Requirements
+
+#### Penetration Testing Checklist
+
+**Authentication Testing:**
+- [ ] XSS payloads in all input fields (name, description, tags)
+- [ ] CSRF token bypass attempts
+- [ ] Session fixation attacks
+- [ ] JWT tampering (modify claims, signature)
+- [ ] JWT replay attacks (reuse old tokens)
+- [ ] OAuth state parameter manipulation
+- [ ] OAuth redirect URI manipulation
+- [ ] OAuth code interception (PKCE should prevent)
+- [ ] Cross-site request forgery on OAuth callback
+- [ ] Open redirect vulnerabilities in OAuth flow
+
+**Authorization Testing:**
+- [ ] Access other users' private modes
+- [ ] Modify modes without authentication
+- [ ] Delete modes as wrong user
+- [ ] Bypass RLS policies
+- [ ] Elevate privileges to admin
+- [ ] Access admin-only endpoints
+
+**Session Management Testing:**
+- [ ] Session hijacking via XSS
+- [ ] Session fixation
+- [ ] Token theft from localStorage
+- [ ] Concurrent session handling
+- [ ] Session timeout enforcement
+- [ ] Logout effectiveness (token revocation)
+
+#### Security Unit Tests
+
+```typescript
+// tests/security/rls-policies.test.ts
+
+describe('Row-Level Security Policies', () => {
+  it('should prevent users from viewing other users private modes', async () => {
+    const user1 = await createTestUser();
+    const user2 = await createTestUser();
+
+    const privateMode = await createMode(user1, { isPublic: false });
+
+    // Try to access as user2
+    const result = await supabase
+      .from('modes')
+      .select('*')
+      .eq('id', privateMode.id)
+      .single();
+
+    expect(result.data).toBeNull(); // Should not see user1's private mode
+  });
+
+  it('should allow users to view public modes', async () => {
+    const user1 = await createTestUser();
+    const user2 = await createTestUser();
+
+    const publicMode = await createMode(user1, { isPublic: true });
+
+    // Try to access as user2
+    const result = await supabase
+      .from('modes')
+      .select('*')
+      .eq('id', publicMode.id)
+      .single();
+
+    expect(result.data).toBeDefined(); // Should see public mode
+  });
+
+  it('should prevent users from deleting other users modes', async () => {
+    const user1 = await createTestUser();
+    const user2 = await createTestUser();
+
+    const mode = await createMode(user1, { isPublic: true });
+
+    // Try to delete as user2
+    const result = await supabase
+      .from('modes')
+      .delete()
+      .eq('id', mode.id);
+
+    expect(result.error).toBeDefined(); // Should fail
+  });
+});
+```
+
+```typescript
+// tests/security/input-validation.test.ts
+
+describe('Input Validation', () => {
+  it('should reject XSS payloads in mode name', () => {
+    const maliciousMode = {
+      name: '<script>alert("XSS")</script>',
+      description: 'Test',
+      version: '1.0.0',
+      controls: {},
+    };
+
+    expect(() => validateMode(maliciousMode)).toThrow();
+  });
+
+  it('should reject SQL injection in mode description', () => {
+    const maliciousMode = {
+      name: 'Test',
+      description: "'; DROP TABLE modes; --",
+      version: '1.0.0',
+      controls: {},
+    };
+
+    // Should not throw (sanitization handles this)
+    const validated = validateMode(maliciousMode);
+    expect(validated.description).not.toContain('DROP TABLE');
+  });
+
+  it('should enforce tag limits', () => {
+    const modeWithManyTags = {
+      name: 'Test',
+      description: 'Test mode',
+      version: '1.0.0',
+      controls: {},
+      tags: Array(20).fill('tag'), // Too many tags
+    };
+
+    expect(() => validateMode(modeWithManyTags)).toThrow('maximum');
+  });
+});
+```
+
+```typescript
+// tests/security/oauth-security.test.ts
+
+describe('OAuth Security', () => {
+  it('should use PKCE flow', () => {
+    const config = supabase.auth.getOptions();
+    expect(config.flowType).toBe('pkce');
+  });
+
+  it('should validate redirect URIs', async () => {
+    const maliciousRedirect = 'https://evil.com';
+
+    const result = await supabase.auth.signInWithOAuth({
+      provider: 'google',
+      options: { redirectTo: maliciousRedirect },
+    });
+
+    // Supabase should reject this
+    expect(result.error).toBeDefined();
+  });
+});
+```
+
+#### Automated Security Scans
+
+**OWASP ZAP Integration:**
+```bash
+# Run ZAP automated scan
+docker run -v $(pwd):/zap/wrk/:rw -t owasp/zap2docker-stable zap-baseline.py \
+  -t http://localhost:8080 \
+  -r zap-report.html
+```
+
+**npm audit:**
+```bash
+# Check for known vulnerabilities
+pnpm audit
+
+# Fix vulnerabilities automatically
+pnpm audit --fix
+```
+
+**Snyk Integration:**
+```bash
+# Install Snyk
+pnpm add -D snyk
+
+# Run security scan
+pnpm snyk test
+
+# Monitor continuously
+pnpm snyk monitor
+```
+
+**CI/CD Security Checks:**
+```yaml
+# .github/workflows/security.yml
+
+name: Security Scan
+on: [push, pull_request]
+
+jobs:
+  security:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+
+      - name: Run npm audit
+        run: pnpm audit
+
+      - name: Run Snyk security scan
+        uses: snyk/actions/node@master
+        env:
+          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
+
+      - name: Run OWASP ZAP
+        uses: zaproxy/action-baseline@v0.7.0
+        with:
+          target: 'http://localhost:8080'
+```
+
+### 11.7 Incident Response
+
+#### Token Revocation Procedures
+
+**Immediate Actions (< 5 minutes):**
+1. Identify compromised tokens/sessions
+2. Revoke tokens via Supabase API
+3. Force re-authentication for affected users
+4. Notify security team
+
+**Implementation:**
+```typescript
+// src/lib/security/incident-response.ts
+
+export async function revokeAllUserSessions(userId: string) {
+  // Supabase admin API (server-side only)
+  const { error } = await supabase.auth.admin.signOut(userId);
+
+  if (error) {
+    throw new Error(`Failed to revoke sessions: ${error.message}`);
+  }
+
+  // Log incident
+  await logSecurityIncident({
+    type: 'session_revocation',
+    userId,
+    timestamp: new Date().toISOString(),
+    reason: 'Security incident',
+  });
+}
+
+export async function revokeAllSessions() {
+  // Global session revocation (emergency use only)
+  // This would require custom implementation or Supabase support
+  await supabase.auth.admin.listUsers().then(({ data: { users } }) => {
+    return Promise.all(
+      users.map(user => supabase.auth.admin.signOut(user.id))
+    );
+  });
+}
+```
+
+#### Breach Notification Plan
+
+**GDPR Compliance - 72 Hour Rule:**
+
+**Hour 0-24: Detection & Containment**
+- Detect breach (automated alerts, user reports)
+- Contain breach (revoke tokens, patch vulnerability)
+- Assess scope (number of users, data exposed)
+- Document timeline
+
+**Hour 24-48: Investigation**
+- Root cause analysis
+- Determine data exposed (emails, names, modes, etc.)
+- Identify affected users
+- Prepare notification templates
+
+**Hour 48-72: Notification**
+- Notify data protection authority (DPA)
+- Notify affected users via email
+- Public disclosure (if required)
+- Provide remediation steps
+
+**Email Template:**
+```
+Subject: Important Security Notice - XL3 Web
+
+Dear [User],
+
+We are writing to inform you of a security incident that may have affected your account.
+
+What Happened:
+On [DATE], we discovered [BRIEF DESCRIPTION]. We immediately took steps to secure our systems and investigate the incident.
+
+What Information Was Involved:
+[List specific data types: email addresses, usernames, mode data, etc.]
+
+What We're Doing:
+- We have revoked all active sessions and reset passwords
+- We have patched the vulnerability
+- We are conducting a full security audit
+- We have reported this to the appropriate authorities
+
+What You Should Do:
+1. Sign in with your email at [LINK] and set a new password
+2. If you use the same password elsewhere, change it immediately
+3. Monitor your account for suspicious activity
+4. Enable two-factor authentication when available
+
+Questions:
+If you have questions, please contact security@xl3-web.com
+
+We sincerely apologize for this incident and any inconvenience it may cause.
+
+Sincerely,
+XL3 Web Security Team
+```
+
+#### Audit Logging Requirements
+
+**Log all authentication events:**
+```typescript
+// src/lib/logging/auth-logger.ts
+
+export interface AuthEvent {
+  type: 'login' | 'logout' | 'signup' | 'password_change' | 'password_reset' | 'failed_login';
+  userId?: string;
+  email?: string;
+  ipAddress: string;
+  userAgent: string;
+  timestamp: string;
+  success: boolean;
+  errorMessage?: string;
+}
+
+export async function logAuthEvent(event: AuthEvent) {
+  // Log to Supabase table
+  await supabase.from('auth_events').insert(event);
+
+  // Also send to external logging service (Sentry, LogRocket, etc.)
+  if (import.meta.env.PROD) {
+    await fetch('/api/logs', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(event),
+    });
+  }
+}
+
+// Usage in AuthContext
+export function AuthProvider({ children }: { children: ReactNode }) {
+  // ...
+
+  const signInWithEmail = async (email: string, password: string) => {
+    try {
+      const { error } = await supabase.auth.signInWithPassword({ email, password });
+
+      if (error) throw error;
+
+      await logAuthEvent({
+        type: 'login',
+        email,
+        ipAddress: await getClientIP(),
+        userAgent: navigator.userAgent,
+        timestamp: new Date().toISOString(),
+        success: true,
+      });
+    } catch (error: any) {
+      await logAuthEvent({
+        type: 'failed_login',
+        email,
+        ipAddress: await getClientIP(),
+        userAgent: navigator.userAgent,
+        timestamp: new Date().toISOString(),
+        success: false,
+        errorMessage: error.message,
+      });
+
+      throw error;
+    }
+  };
+
+  // ...
+}
+```
+
+**Database schema for audit logs:**
+```sql
+CREATE TABLE auth_events (
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  type VARCHAR(50) NOT NULL,
+  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
+  email VARCHAR(255),
+  ip_address INET,
+  user_agent TEXT,
+  timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
+  success BOOLEAN NOT NULL,
+  error_message TEXT,
+
+  -- Indexes for querying
+  INDEX idx_auth_events_user (user_id, timestamp DESC),
+  INDEX idx_auth_events_email (email, timestamp DESC),
+  INDEX idx_auth_events_ip (ip_address, timestamp DESC),
+  INDEX idx_auth_events_type (type, timestamp DESC)
+);
+
+-- Enable RLS
+ALTER TABLE auth_events ENABLE ROW LEVEL SECURITY;
+
+-- Only admins can view logs
+CREATE POLICY "Only admins can view auth events"
+  ON auth_events FOR SELECT
+  USING ((auth.jwt() ->> 'role')::text = 'admin');
+```
+
+#### Forensics and Log Retention
+
+**Log Retention Policy:**
+- Auth events: 90 days
+- Security incidents: 7 years (legal requirement)
+- User activity logs: 30 days
+- Error logs: 30 days
+
+**Forensic Readiness:**
+```typescript
+// Ensure logs are immutable and verifiable
+CREATE TABLE security_incidents (
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  type VARCHAR(100) NOT NULL,
+  severity VARCHAR(20) NOT NULL, -- low, medium, high, critical
+  description TEXT NOT NULL,
+  affected_users UUID[] DEFAULT '{}',
+  detected_at TIMESTAMP NOT NULL DEFAULT NOW(),
+  resolved_at TIMESTAMP,
+  root_cause TEXT,
+  remediation TEXT,
+  created_by UUID REFERENCES users(id),
+
+  -- Prevent modification
+  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
+  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
+);
+
+-- Trigger to prevent deletion (append-only)
+CREATE RULE security_incidents_no_delete AS
+  ON DELETE TO security_incidents
+  DO INSTEAD NOTHING;
+```
+
+### 11.8 Compliance Considerations
+
+#### GDPR Requirements
+
+**Right to Access (Article 15):**
+```typescript
+// src/lib/gdpr/data-export.ts
+
+export async function exportUserData(userId: string) {
+  // Export all user data
+  const userData = await supabase.from('users').select('*').eq('id', userId).single();
+  const userModes = await supabase.from('modes').select('*').eq('author_id', userId);
+  const likes = await supabase.from('mode_likes').select('*').eq('user_id', userId);
+  const ratings = await supabase.from('mode_ratings').select('*').eq('user_id', userId);
+
+  return {
+    user: userData.data,
+    modes: userModes.data,
+    likes: likes.data,
+    ratings: ratings.data,
+    exportedAt: new Date().toISOString(),
+  };
+}
+```
+
+**Right to Deletion (Article 17):**
+```typescript
+// src/lib/gdpr/data-deletion.ts
+
+export async function deleteUserData(userId: string) {
+  // Cascade delete all user data
+  // Order matters - delete children before parent
+
+  await supabase.from('mode_likes').delete().eq('user_id', userId);
+  await supabase.from('mode_ratings').delete().eq('user_id', userId);
+  await supabase.from('modes').delete().eq('author_id', userId);
+  await supabase.from('auth_events').delete().eq('user_id', userId);
+
+  // Finally delete user
+  await supabase.auth.admin.deleteUser(userId);
+
+  // Log deletion
+  await logSecurityIncident({
+    type: 'user_deletion',
+    userId,
+    timestamp: new Date().toISOString(),
+    reason: 'User requested data deletion (GDPR Article 17)',
+  });
+}
+```
+
+**Data Portability (Article 20):**
+```typescript
+// Export in machine-readable format (JSON)
+export async function exportUserDataPortable(userId: string) {
+  const data = await exportUserData(userId);
+
+  return {
+    format: 'JSON',
+    version: '1.0',
+    exported: new Date().toISOString(),
+    data: data,
+  };
+}
+```
+
+#### Data Retention Policies
+
+**Retention Schedule:**
+- Active users: Data retained indefinitely
+- Inactive users (no login for 2 years): Notify user, delete after 30 days if no response
+- Deleted accounts: Soft delete for 30 days, then hard delete
+- Audit logs: 90 days (auth events), 7 years (security incidents)
+
+**Implementation:**
+```sql
+-- Soft delete users
+ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP;
+ALTER TABLE users ADD COLUMN deletion_scheduled_at TIMESTAMP;
+
+-- Scheduled deletion job (run daily)
+CREATE FUNCTION schedule_inactive_user_deletions() RETURNS void AS $$
+BEGIN
+  UPDATE users
+  SET deletion_scheduled_at = NOW() + INTERVAL '30 days'
+  WHERE last_sign_in_at < NOW() - INTERVAL '2 years'
+    AND deletion_scheduled_at IS NULL
+    AND deleted_at IS NULL;
+END;
+$$ LANGUAGE plpgsql;
+
+-- Hard delete job (run daily)
+CREATE FUNCTION hard_delete_scheduled_users() RETURNS void AS $$
+BEGIN
+  DELETE FROM users
+  WHERE deletion_scheduled_at IS NOT NULL
+    AND deletion_scheduled_at < NOW();
+END;
+$$ LANGUAGE plpgsql;
+```
+
+#### Right to Deletion Implementation
+
+**UI for user-initiated deletion:**
+```typescript
+// src/pages/Settings.tsx
+
+export function Settings() {
+  const { user } = useAuth();
+  const [confirmDelete, setConfirmDelete] = useState(false);
+
+  const handleDeleteAccount = async () => {
+    if (!confirmDelete) {
+      setConfirmDelete(true);
+      return;
+    }
+
+    try {
+      // Request deletion
+      await fetch('/api/users/me/delete', {
+        method: 'POST',
+        headers: {
+          'Authorization': `Bearer ${await supabase.auth.getSession().then(s => s.data.session?.access_token)}`,
+        },
+      });
+
+      // Sign out
+      await supabase.auth.signOut();
+
+      // Show confirmation
+      toast.success('Your account has been scheduled for deletion. You have 30 days to change your mind.');
+
+      navigate('/');
+    } catch (error) {
+      toast.error('Failed to delete account. Please contact support.');
+    }
+  };
+
+  return (
+    <div>
+      {/* Settings UI */}
+
+      <div className="border-t border-destructive mt-8 pt-8">
+        <h2 className="text-lg font-semibold text-destructive">Danger Zone</h2>
+        <p className="text-sm text-muted-foreground mt-2">
+          Once you delete your account, there is no going back. Please be certain.
+        </p>
+
+        <Button
+          variant="destructive"
+          onClick={handleDeleteAccount}
+          className="mt-4"
+        >
+          {confirmDelete ? 'Click again to confirm deletion' : 'Delete Account'}
+        </Button>
+
+        {confirmDelete && (
+          <p className="text-sm text-muted-foreground mt-2">
+            This will permanently delete all your modes, likes, and ratings after 30 days.
+          </p>
+        )}
+      </div>
+    </div>
+  );
+}
+```
+
+#### Cookie Consent Management
+
+**GDPR requires consent for non-essential cookies:**
+
+```typescript
+// src/components/CookieConsent.tsx
+
+import { useState, useEffect } from 'react';
+import { Button } from '@/components/ui/button';
+import { Card } from '@/components/ui/card';
+
+export function CookieConsent() {
+  const [showBanner, setShowBanner] = useState(false);
+
+  useEffect(() => {
+    const consent = localStorage.getItem('cookie-consent');
+    if (!consent) {
+      setShowBanner(true);
+    }
+  }, []);
+
+  const acceptCookies = () => {
+    localStorage.setItem('cookie-consent', 'accepted');
+    setShowBanner(false);
+
+    // Enable analytics (only after consent)
+    if (typeof window.gtag !== 'undefined') {
+      window.gtag('consent', 'update', {
+        analytics_storage: 'granted'
+      });
+    }
+  };
+
+  const rejectCookies = () => {
+    localStorage.setItem('cookie-consent', 'rejected');
+    setShowBanner(false);
+
+    // Disable analytics
+    if (typeof window.gtag !== 'undefined') {
+      window.gtag('consent', 'update', {
+        analytics_storage: 'denied'
+      });
+    }
+  };
+
+  if (!showBanner) return null;
+
+  return (
+    <Card className="fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:max-w-md p-4 shadow-lg z-50">
+      <p className="text-sm mb-4">
+        We use cookies to improve your experience. Essential cookies are required for authentication.
+        Analytics cookies are optional.
+      </p>
+      <div className="flex space-x-2">
+        <Button onClick={acceptCookies} size="sm">
+          Accept All
+        </Button>
+        <Button onClick={rejectCookies} variant="outline" size="sm">
+          Essential Only
+        </Button>
+      </div>
+    </Card>
+  );
+}
+```
+
+---
+
+## Appendices
+
+### Appendix A: Supabase Dashboard Configuration
+
+#### Authentication Settings
+
+1. **URL Configuration:**
+   - Site URL: `http://localhost:8080` (dev), `https://your-domain.com` (prod)
+   - Redirect URLs: `http://localhost:8080/auth/callback`, `https://your-domain.com/auth/callback`
+
+2. **Disable Unused Auth Methods:**
+   - Authentication → Providers → Email → **Disable**
+   - Authentication → Providers → GitHub → **Disable**
+   - Authentication → Providers → All others → **Disable**
+
+3. **Enable Google OAuth:**
+   - Authentication → Providers → Google → **Enable**
+   - Add Client ID and Secret from Google Cloud Console
+   - Save configuration
+
+4. **Security:**
+   - Set session timeout: 7 days (default)
+   - Enable automatic token refresh: ✅
+   - PKCE flow is enabled by default in client config
+
+### Appendix B: Environment Variables Reference
+
+```bash
+# Supabase
+VITE_SUPABASE_URL=https://your-project.supabase.co
+VITE_SUPABASE_ANON_KEY=your-anon-key-here
+
+# Optional
+VITE_API_BASE_URL=https://your-project.supabase.co
+VITE_APP_URL=http://localhost:8080
+VITE_AUTH_REDIRECT_URL=http://localhost:8080/auth/callback
+```
+
+### Appendix C: Common Issues & Solutions
+
+#### Issue: OAuth redirect not working
+
+**Solution:**
+- Verify redirect URL is whitelisted in Supabase dashboard
+- Check OAuth provider callback URL matches
+- Ensure HTTPS in production
+
+#### Issue: Token refresh fails
+
+**Solution:**
+- Check refresh token not expired (default: 30 days)
+- Verify `autoRefreshToken: true` in config
+- Check network connectivity
+
+#### Issue: Session not persisting
+
+**Solution:**
+- Verify `persistSession: true` in config
+- Check localStorage not blocked by browser
+- Verify cookies/storage not cleared
+
+#### Issue: 401 errors after token expiry
+
+**Solution:**
+- Ensure ApiClient has refresh logic
+- Check `refreshSession` implementation
+- Verify retry logic in place
+
+---
+
+**End of Workplan**
diff --git a/docs/1.0/cloud-storage/planning/research.md b/docs/1.0/cloud-storage/planning/research.md
index 613d406..55eb4cf 100644
--- a/docs/1.0/cloud-storage/planning/research.md
+++ b/docs/1.0/cloud-storage/planning/research.md
@@ -6,13 +6,16 @@
 
 ## Executive Summary
 
-This document outlines the architecture for implementing cloud-based mode storage and a global catalog for sharing custom MIDI controller modes. The system will enable users to store their custom modes in the cloud, discover community-created modes, and collaborate through forking and remixing.
+This document outlines the architecture for implementing cloud-based mode storage and a global catalog for sharing
+custom MIDI controller modes. The system will enable users to store their custom modes in the cloud, discover
+community-created modes, and collaborate through forking and remixing.
 
 ## Current System Analysis
 
 ### Existing Architecture
 
 **Frontend Stack:**
+
 - React 18.3 + TypeScript 5.8
 - Vite 5.4 build system
 - TanStack Query 5.83 (already available!)
@@ -20,23 +23,26 @@ This document outlines the architecture for implementing cloud-based mode storag
 - React Router 6.30
 
 **Current Storage:**
+
 - Local storage for active mode (`LocalStorageManager`)
 - File-based export/import (`fileStorage.ts`)
 - State persistence (`statePersistence.ts`)
 
 **Data Model:**
+
 ```typescript
 interface CustomMode {
-  name: string;
-  description: string;
-  version: string;
-  controls: Record<string, ControlMapping>;
-  createdAt: string;
-  modifiedAt: string;
+    name: string;
+    description: string;
+    version: string;
+    controls: Record<string, ControlMapping>;
+    createdAt: string;
+    modifiedAt: string;
 }
 ```
 
 **UI Components:**
+
 - `/pages/Catalog.tsx` - Mock UI for browsing community modes
 - `/pages/Library.tsx` - Mock UI for user's personal library
 - `/pages/Editor.tsx` - Mode editing interface
@@ -44,6 +50,7 @@ interface CustomMode {
 ### Gap Analysis
 
 **Missing Components:**
+
 1. Cloud storage backend
 2. Authentication system
 3. API service layer
@@ -62,57 +69,57 @@ interface CustomMode {
 
 ```typescript
 interface CloudMode extends CustomMode {
-  // Unique identification
-  id: string;                    // UUID v4
-
-  // Ownership & attribution
-  authorId: string;              // Auth provider user ID
-  authorName: string;            // Display name
-  authorAvatar?: string;         // Profile image URL
-
-  // Visibility & access
-  isPublic: boolean;             // Public catalog visibility
-  isOfficial: boolean;           // Curated by platform
-  isFeatured: boolean;           // Featured on homepage
-
-  // Engagement metrics
-  downloads: number;             // Total download count
-  likes: number;                 // Like count
-  likesUserIds: string[];        // For checking if user liked
-  rating: number;                // Average rating (1-5)
-  ratingCount: number;           // Number of ratings
-  views: number;                 // View count
-
-  // Discovery & organization
-  tags: string[];                // Searchable tags
-  category: string;              // Primary category
-  categories: string[];          // Multiple categories
-  thumbnail?: string;            // Preview image (base64 or URL)
-
-  // Version management
-  versionHistory: ModeVersion[]; // Historical versions
-  parentModeId?: string;         // Original mode (for forks)
-  forkCount: number;             // Number of forks
-
-  // Metadata
-  publishedAt?: string;          // ISO 8601 timestamp
-  updatedAt: string;             // ISO 8601 timestamp
-  lastSyncedAt?: string;         // Last cloud sync
+    // Unique identification
+    id: string;                    // UUID v4
+
+    // Ownership & attribution
+    authorId: string;              // Auth provider user ID
+    authorName: string;            // Display name
+    authorAvatar?: string;         // Profile image URL
+
+    // Visibility & access
+    isPublic: boolean;             // Public catalog visibility
+    isOfficial: boolean;           // Curated by platform
+    isFeatured: boolean;           // Featured on homepage
+
+    // Engagement metrics
+    downloads: number;             // Total download count
+    likes: number;                 // Like count
+    likesUserIds: string[];        // For checking if user liked
+    rating: number;                // Average rating (1-5)
+    ratingCount: number;           // Number of ratings
+    views: number;                 // View count
+
+    // Discovery & organization
+    tags: string[];                // Searchable tags
+    category: string;              // Primary category
+    categories: string[];          // Multiple categories
+    thumbnail?: string;            // Preview image (base64 or URL)
+
+    // Version management
+    versionHistory: ModeVersion[]; // Historical versions
+    parentModeId?: string;         // Original mode (for forks)
+    forkCount: number;             // Number of forks
+
+    // Metadata
+    publishedAt?: string;          // ISO 8601 timestamp
+    updatedAt: string;             // ISO 8601 timestamp
+    lastSyncedAt?: string;         // Last cloud sync
 }
 
 interface ModeVersion {
-  version: string;               // Semver (1.0.0)
-  changes: string;               // Changelog
-  publishedAt: string;           // ISO 8601 timestamp
-  downloadUrl?: string;          // Version-specific download
+    version: string;               // Semver (1.0.0)
+    changes: string;               // Changelog
+    publishedAt: string;           // ISO 8601 timestamp
+    downloadUrl?: string;          // Version-specific download
 }
 
 interface ModeMetadata {
-  description: string;
-  tags: string[];
-  category: string;
-  isPublic: boolean;
-  thumbnail?: string;
+    description: string;
+    tags: string[];
+    category: string;
+    isPublic: boolean;
+    thumbnail?: string;
 }
 ```
 
@@ -120,118 +127,124 @@ interface ModeMetadata {
 
 ```sql
 -- Users table (managed by auth provider)
-CREATE TABLE users (
-  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
-  auth_provider_id VARCHAR(255) UNIQUE NOT NULL,
-  username VARCHAR(50) UNIQUE NOT NULL,
-  display_name VARCHAR(100),
-  avatar_url TEXT,
-  created_at TIMESTAMP DEFAULT NOW(),
-  updated_at TIMESTAMP DEFAULT NOW()
+CREATE TABLE users
+(
+    id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+    auth_provider_id VARCHAR(255) UNIQUE NOT NULL,
+    username         VARCHAR(50) UNIQUE  NOT NULL,
+    display_name     VARCHAR(100),
+    avatar_url       TEXT,
+    created_at       TIMESTAMP        DEFAULT NOW(),
+    updated_at       TIMESTAMP        DEFAULT NOW()
 );
 
 -- Modes table
-CREATE TABLE modes (
-  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
-  author_id UUID REFERENCES users(id) ON DELETE CASCADE,
-  name VARCHAR(255) NOT NULL,
-  description TEXT,
-  version VARCHAR(20) NOT NULL,
-
-  -- Mode data (JSONB for flexibility)
-  controls JSONB NOT NULL,
-
-  -- Visibility
-  is_public BOOLEAN DEFAULT false,
-  is_official BOOLEAN DEFAULT false,
-  is_featured BOOLEAN DEFAULT false,
-
-  -- Engagement
-  downloads INTEGER DEFAULT 0,
-  likes INTEGER DEFAULT 0,
-  rating DECIMAL(3,2) DEFAULT 0,
-  rating_count INTEGER DEFAULT 0,
-  views INTEGER DEFAULT 0,
-  fork_count INTEGER DEFAULT 0,
-
-  -- Discovery
-  tags TEXT[] DEFAULT '{}',
-  category VARCHAR(100),
-  thumbnail TEXT,
-
-  -- Relationships
-  parent_mode_id UUID REFERENCES modes(id) ON DELETE SET NULL,
-
-  -- Timestamps
-  created_at TIMESTAMP DEFAULT NOW(),
-  modified_at TIMESTAMP DEFAULT NOW(),
-  published_at TIMESTAMP,
-
-  -- Indexes
-  CONSTRAINT valid_rating CHECK (rating >= 0 AND rating <= 5)
+CREATE TABLE modes
+(
+    id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+    author_id      UUID REFERENCES users (id) ON DELETE CASCADE,
+    name           VARCHAR(255) NOT NULL,
+    description    TEXT,
+    version        VARCHAR(20)  NOT NULL,
+
+    -- Mode data (JSONB for flexibility)
+    controls       JSONB        NOT NULL,
+
+    -- Visibility
+    is_public      BOOLEAN          DEFAULT false,
+    is_official    BOOLEAN          DEFAULT false,
+    is_featured    BOOLEAN          DEFAULT false,
+
+    -- Engagement
+    downloads      INTEGER          DEFAULT 0,
+    likes          INTEGER          DEFAULT 0,
+    rating         DECIMAL(3, 2)    DEFAULT 0,
+    rating_count   INTEGER          DEFAULT 0,
+    views          INTEGER          DEFAULT 0,
+    fork_count     INTEGER          DEFAULT 0,
+
+    -- Discovery
+    tags           TEXT[] DEFAULT '{}',
+    category       VARCHAR(100),
+    thumbnail      TEXT,
+
+    -- Relationships
+    parent_mode_id UUID         REFERENCES modes (id) ON DELETE SET NULL,
+
+    -- Timestamps
+    created_at     TIMESTAMP        DEFAULT NOW(),
+    modified_at    TIMESTAMP        DEFAULT NOW(),
+    published_at   TIMESTAMP,
+
+    -- Indexes
+    CONSTRAINT valid_rating CHECK (rating >= 0 AND rating <= 5)
 );
 
-CREATE INDEX idx_modes_author ON modes(author_id);
-CREATE INDEX idx_modes_public ON modes(is_public) WHERE is_public = true;
-CREATE INDEX idx_modes_featured ON modes(is_featured) WHERE is_featured = true;
-CREATE INDEX idx_modes_category ON modes(category);
+CREATE INDEX idx_modes_author ON modes (author_id);
+CREATE INDEX idx_modes_public ON modes (is_public) WHERE is_public = true;
+CREATE INDEX idx_modes_featured ON modes (is_featured) WHERE is_featured = true;
+CREATE INDEX idx_modes_category ON modes (category);
 CREATE INDEX idx_modes_tags ON modes USING GIN(tags);
-CREATE INDEX idx_modes_created ON modes(created_at DESC);
+CREATE INDEX idx_modes_created ON modes (created_at DESC);
 
 -- Full-text search
 CREATE INDEX idx_modes_search ON modes USING GIN(
-  to_tsvector('english', name || ' ' || COALESCE(description, ''))
-);
+    to_tsvector('english', name || ' ' || COALESCE (description, ''))
+    );
 
 -- Mode likes (many-to-many)
-CREATE TABLE mode_likes (
-  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
-  mode_id UUID REFERENCES modes(id) ON DELETE CASCADE,
-  created_at TIMESTAMP DEFAULT NOW(),
-  PRIMARY KEY (user_id, mode_id)
+CREATE TABLE mode_likes
+(
+    user_id    UUID REFERENCES users (id) ON DELETE CASCADE,
+    mode_id    UUID REFERENCES modes (id) ON DELETE CASCADE,
+    created_at TIMESTAMP DEFAULT NOW(),
+    PRIMARY KEY (user_id, mode_id)
 );
 
-CREATE INDEX idx_mode_likes_mode ON mode_likes(mode_id);
+CREATE INDEX idx_mode_likes_mode ON mode_likes (mode_id);
 
 -- Mode ratings
-CREATE TABLE mode_ratings (
-  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
-  mode_id UUID REFERENCES modes(id) ON DELETE CASCADE,
-  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
-  created_at TIMESTAMP DEFAULT NOW(),
-  updated_at TIMESTAMP DEFAULT NOW(),
-  PRIMARY KEY (user_id, mode_id)
+CREATE TABLE mode_ratings
+(
+    user_id    UUID REFERENCES users (id) ON DELETE CASCADE,
+    mode_id    UUID REFERENCES modes (id) ON DELETE CASCADE,
+    rating     INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
+    created_at TIMESTAMP DEFAULT NOW(),
+    updated_at TIMESTAMP DEFAULT NOW(),
+    PRIMARY KEY (user_id, mode_id)
 );
 
 -- Version history
-CREATE TABLE mode_versions (
-  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
-  mode_id UUID REFERENCES modes(id) ON DELETE CASCADE,
-  version VARCHAR(20) NOT NULL,
-  changes TEXT,
-  controls JSONB NOT NULL,
-  published_at TIMESTAMP DEFAULT NOW()
+CREATE TABLE mode_versions
+(
+    id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+    mode_id      UUID REFERENCES modes (id) ON DELETE CASCADE,
+    version      VARCHAR(20) NOT NULL,
+    changes      TEXT,
+    controls     JSONB       NOT NULL,
+    published_at TIMESTAMP        DEFAULT NOW()
 );
 
-CREATE INDEX idx_mode_versions_mode ON mode_versions(mode_id, published_at DESC);
+CREATE INDEX idx_mode_versions_mode ON mode_versions (mode_id, published_at DESC);
 
 -- Categories (predefined)
-CREATE TABLE categories (
-  id VARCHAR(100) PRIMARY KEY,
-  name VARCHAR(100) NOT NULL,
-  description TEXT,
-  icon VARCHAR(50),
-  display_order INTEGER DEFAULT 0
+CREATE TABLE categories
+(
+    id            VARCHAR(100) PRIMARY KEY,
+    name          VARCHAR(100) NOT NULL,
+    description   TEXT,
+    icon          VARCHAR(50),
+    display_order INTEGER DEFAULT 0
 );
 
 -- Insert default categories
-INSERT INTO categories (id, name, description) VALUES
-  ('daw-control', 'DAW Control', 'Digital Audio Workstation control surfaces'),
-  ('live-performance', 'Live Performance', 'Setups for live shows and DJing'),
-  ('mixing-mastering', 'Mixing & Mastering', 'Studio mixing and mastering workflows'),
-  ('instrument-control', 'Instrument Control', 'Hardware synth and instrument mappings'),
-  ('genre-specific', 'Genre-Specific', 'Genre-optimized configurations'),
-  ('educational', 'Educational', 'Learning and tutorial modes');
+INSERT INTO categories (id, name, description)
+VALUES ('daw-control', 'DAW Control', 'Digital Audio Workstation control surfaces'),
+       ('live-performance', 'Live Performance', 'Setups for live shows and DJing'),
+       ('mixing-mastering', 'Mixing & Mastering', 'Studio mixing and mastering workflows'),
+       ('instrument-control', 'Instrument Control', 'Hardware synth and instrument mappings'),
+       ('genre-specific', 'Genre-Specific', 'Genre-optimized configurations'),
+       ('educational', 'Educational', 'Learning and tutorial modes');
 ```
 
 ---
@@ -241,6 +254,7 @@ INSERT INTO categories (id, name, description) VALUES
 #### Recommended: Supabase (Serverless)
 
 **Rationale:**
+
 - Built on PostgreSQL (robust, relational)
 - Real-time subscriptions out of the box
 - Integrated authentication (OAuth + email)
@@ -250,6 +264,7 @@ INSERT INTO categories (id, name, description) VALUES
 - Generous free tier: 500MB database, 1GB storage, 2GB bandwidth/month
 
 **Stack:**
+
 - **Database:** PostgreSQL 15+
 - **Auth:** Supabase Auth (Google, GitHub, Email)
 - **Storage:** Supabase Storage (for thumbnails, large mode files)
@@ -258,6 +273,7 @@ INSERT INTO categories (id, name, description) VALUES
 - **Edge Functions:** Deno runtime for custom logic
 
 **Alternative: Custom Backend**
+
 - **Runtime:** Bun + Hono/Fastify
 - **Database:** PostgreSQL + Drizzle ORM
 - **Cache:** Redis for session/query caching
@@ -279,78 +295,108 @@ INSERT INTO categories (id, name, description) VALUES
  */
 
 // Browse modes with filtering
-GET /modes?
-  category=daw-control&
-  tags=ableton,live&
-  sort=downloads|likes|rating|recent&
-  page=1&
-  limit=20
+GET / modes ?
+    category = daw - control &
+    tags = ableton, live &
+sort = downloads | likes | rating | recent &
+page = 1 &
+limit = 20
 
 Response: {
-  data: CloudMode[];
-  pagination: {
-    page: number;
-    limit: number;
-    total: number;
-    hasNext: boolean;
-  };
+    data: CloudMode[];
+    pagination: {
+        page: number;
+        limit: number;
+        total: number;
+        hasNext: boolean;
+    }
+    ;
 }
 
 // Get specific mode
-GET /modes/:id
+GET / modes /
+:
+id
 Response: CloudMode
 
 // Search modes
-GET /modes/search?q=ableton+live&filters={...}
-Response: { data: CloudMode[]; meta: SearchMeta }
+GET / modes / search ? q = ableton + live & filters = {...}
+    Response
+:
+{
+    data: CloudMode[];
+    meta: SearchMeta
+}
 
 // Get mode versions
-GET /modes/:id/versions
+GET / modes /
+:
+id / versions
 Response: ModeVersion[]
 
 // Download mode (increments counter)
-GET /modes/:id/download
-Response: CustomMode (with analytics tracking)
+GET / modes /
+:
+id / download
+Response: CustomMode(
+with analytics tracking
+)
 
 // Get categories
-GET /categories
+GET / categories
 Response: Category[]
 
 // Get popular tags
-GET /tags?limit=50
-Response: { tag: string; count: number }[]
+GET / tags ? limit = 50
+    Response
+:
+{
+    tag: string;
+    count: number
+}
+[]
 
 /**
  * User Library (Auth Required)
  */
 
 // Get user's modes
-GET /users/me/modes
+GET / users / me / modes
 Response: CloudMode[]
 
 // Create/upload new mode
-POST /modes
+POST / modes
 Body: {
-  mode: CustomMode;
-  metadata: ModeMetadata;
+    mode: CustomMode;
+    metadata: ModeMetadata;
 }
 Response: CloudMode
 
 // Update mode
-PUT /modes/:id
+PUT / modes /
+:
+id
 Body: Partial<CloudMode>
 Response: CloudMode
 
 // Delete mode
-DELETE /modes/:id
-Response: { success: boolean }
+DELETE / modes /
+:
+id
+Response: {
+    success: boolean
+}
 
 // Publish mode (make public)
-POST /modes/:id/publish
+POST / modes /
+:
+id / publish
 Response: CloudMode
 
 // Unpublish mode (make private)
-POST /modes/:id/unpublish
+POST / modes /
+:
+id / unpublish
 Response: CloudMode
 
 /**
@@ -358,33 +404,56 @@ Response: CloudMode
  */
 
 // Like/unlike mode
-POST /modes/:id/like
-Response: { liked: boolean; likesCount: number }
+POST / modes /
+:
+id / like
+Response: {
+    liked: boolean;
+    likesCount: number
+}
 
 // Rate mode
-POST /modes/:id/rate
-Body: { rating: number } // 1-5
-Response: { averageRating: number; ratingCount: number }
+POST / modes /
+:
+id / rate
+Body: {
+    rating: number
+} // 1-5
+Response: {
+    averageRating: number;
+    ratingCount: number
+}
 
 // Fork mode
-POST /modes/:id/fork
-Body: { name?: string; description?: string }
-Response: CloudMode (new forked mode)
+POST / modes /
+:
+id / fork
+Body: {
+    name ? : string;
+    description ? : string
+}
+Response: CloudMode(new forked
+mode
+)
 
 /**
  * User Profile
  */
 
 // Get user profile
-GET /users/:userId
+GET / users /
+:
+userId
 Response: UserProfile
 
 // Get user's public modes
-GET /users/:userId/modes
+GET / users /
+:
+userId / modes
 Response: CloudMode[]
 
 // Update own profile
-PATCH /users/me
+PATCH / users / me
 Body: Partial<UserProfile>
 Response: UserProfile
 ```
@@ -425,141 +494,142 @@ type Subscription {
 ```typescript
 // src/lib/services/cloud-storage.ts
 
-import { QueryClient } from '@tanstack/react-query';
+import {QueryClient} from '@tanstack/react-query';
 
 interface ModeFilters {
-  category?: string;
-  tags?: string[];
-  sort?: 'downloads' | 'likes' | 'rating' | 'recent';
-  page?: number;
-  limit?: number;
+    category?: string;
+    tags?: string[];
+    sort?: 'downloads' | 'likes' | 'rating' | 'recent';
+    page?: number;
+    limit?: number;
 }
 
 export class CloudStorageService {
-  constructor(
-    private baseUrl: string,
-    private authToken?: string
-  ) {}
-
-  // Catalog operations
-  async browseModes(filters: ModeFilters = {}): Promise<PaginatedResponse<CloudMode>> {
-    const query = new URLSearchParams(filters as any).toString();
-    const response = await fetch(`${this.baseUrl}/modes?${query}`);
-    if (!response.ok) throw new Error('Failed to fetch modes');
-    return response.json();
-  }
+    constructor(
+        private baseUrl: string,
+        private authToken?: string
+    ) {
+    }
 
-  async getModeById(id: string): Promise<CloudMode> {
-    const response = await fetch(`${this.baseUrl}/modes/${id}`);
-    if (!response.ok) throw new Error('Mode not found');
-    return response.json();
-  }
+    // Catalog operations
+    async browseModes(filters: ModeFilters = {}): Promise<PaginatedResponse<CloudMode>> {
+        const query = new URLSearchParams(filters as any).toString();
+        const response = await fetch(`${this.baseUrl}/modes?${query}`);
+        if (!response.ok) throw new Error('Failed to fetch modes');
+        return response.json();
+    }
 
-  async searchModes(query: string, filters?: ModeFilters): Promise<CloudMode[]> {
-    const params = new URLSearchParams({ q: query, ...filters as any });
-    const response = await fetch(`${this.baseUrl}/modes/search?${params}`);
-    if (!response.ok) throw new Error('Search failed');
-    const result = await response.json();
-    return result.data;
-  }
+    async getModeById(id: string): Promise<CloudMode> {
+        const response = await fetch(`${this.baseUrl}/modes/${id}`);
+        if (!response.ok) throw new Error('Mode not found');
+        return response.json();
+    }
 
-  // Library operations (authenticated)
-  async getUserModes(): Promise<CloudMode[]> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/users/me/modes`, {
-      headers: { Authorization: `Bearer ${this.authToken}` },
-    });
-    if (!response.ok) throw new Error('Failed to fetch user modes');
-    return response.json();
-  }
+    async searchModes(query: string, filters?: ModeFilters): Promise<CloudMode[]> {
+        const params = new URLSearchParams({q: query, ...filters as any});
+        const response = await fetch(`${this.baseUrl}/modes/search?${params}`);
+        if (!response.ok) throw new Error('Search failed');
+        const result = await response.json();
+        return result.data;
+    }
 
-  async uploadMode(mode: CustomMode, metadata: ModeMetadata): Promise<CloudMode> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/modes`, {
-      method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-        Authorization: `Bearer ${this.authToken}`,
-      },
-      body: JSON.stringify({ mode, metadata }),
-    });
-    if (!response.ok) throw new Error('Failed to upload mode');
-    return response.json();
-  }
+    // Library operations (authenticated)
+    async getUserModes(): Promise<CloudMode[]> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/users/me/modes`, {
+            headers: {Authorization: `Bearer ${this.authToken}`},
+        });
+        if (!response.ok) throw new Error('Failed to fetch user modes');
+        return response.json();
+    }
 
-  async updateMode(id: string, updates: Partial<CloudMode>): Promise<CloudMode> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/modes/${id}`, {
-      method: 'PUT',
-      headers: {
-        'Content-Type': 'application/json',
-        Authorization: `Bearer ${this.authToken}`,
-      },
-      body: JSON.stringify(updates),
-    });
-    if (!response.ok) throw new Error('Failed to update mode');
-    return response.json();
-  }
+    async uploadMode(mode: CustomMode, metadata: ModeMetadata): Promise<CloudMode> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/modes`, {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+                Authorization: `Bearer ${this.authToken}`,
+            },
+            body: JSON.stringify({mode, metadata}),
+        });
+        if (!response.ok) throw new Error('Failed to upload mode');
+        return response.json();
+    }
 
-  async deleteMode(id: string): Promise<void> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/modes/${id}`, {
-      method: 'DELETE',
-      headers: { Authorization: `Bearer ${this.authToken}` },
-    });
-    if (!response.ok) throw new Error('Failed to delete mode');
-  }
+    async updateMode(id: string, updates: Partial<CloudMode>): Promise<CloudMode> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/modes/${id}`, {
+            method: 'PUT',
+            headers: {
+                'Content-Type': 'application/json',
+                Authorization: `Bearer ${this.authToken}`,
+            },
+            body: JSON.stringify(updates),
+        });
+        if (!response.ok) throw new Error('Failed to update mode');
+        return response.json();
+    }
 
-  // Engagement
-  async likeMode(id: string): Promise<{ liked: boolean; likesCount: number }> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/modes/${id}/like`, {
-      method: 'POST',
-      headers: { Authorization: `Bearer ${this.authToken}` },
-    });
-    if (!response.ok) throw new Error('Failed to like mode');
-    return response.json();
-  }
+    async deleteMode(id: string): Promise<void> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/modes/${id}`, {
+            method: 'DELETE',
+            headers: {Authorization: `Bearer ${this.authToken}`},
+        });
+        if (!response.ok) throw new Error('Failed to delete mode');
+    }
 
-  async rateMode(id: string, rating: number): Promise<{ averageRating: number }> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/modes/${id}/rate`, {
-      method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-        Authorization: `Bearer ${this.authToken}`,
-      },
-      body: JSON.stringify({ rating }),
-    });
-    if (!response.ok) throw new Error('Failed to rate mode');
-    return response.json();
-  }
+    // Engagement
+    async likeMode(id: string): Promise<{ liked: boolean; likesCount: number }> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/modes/${id}/like`, {
+            method: 'POST',
+            headers: {Authorization: `Bearer ${this.authToken}`},
+        });
+        if (!response.ok) throw new Error('Failed to like mode');
+        return response.json();
+    }
 
-  async downloadMode(id: string): Promise<CustomMode> {
-    const response = await fetch(`${this.baseUrl}/modes/${id}/download`);
-    if (!response.ok) throw new Error('Failed to download mode');
-    return response.json();
-  }
+    async rateMode(id: string, rating: number): Promise<{ averageRating: number }> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/modes/${id}/rate`, {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+                Authorization: `Bearer ${this.authToken}`,
+            },
+            body: JSON.stringify({rating}),
+        });
+        if (!response.ok) throw new Error('Failed to rate mode');
+        return response.json();
+    }
 
-  async forkMode(id: string, overrides?: { name?: string; description?: string }): Promise<CloudMode> {
-    this.requireAuth();
-    const response = await fetch(`${this.baseUrl}/modes/${id}/fork`, {
-      method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-        Authorization: `Bearer ${this.authToken}`,
-      },
-      body: JSON.stringify(overrides || {}),
-    });
-    if (!response.ok) throw new Error('Failed to fork mode');
-    return response.json();
-  }
+    async downloadMode(id: string): Promise<CustomMode> {
+        const response = await fetch(`${this.baseUrl}/modes/${id}/download`);
+        if (!response.ok) throw new Error('Failed to download mode');
+        return response.json();
+    }
 
-  private requireAuth() {
-    if (!this.authToken) {
-      throw new Error('Authentication required');
+    async forkMode(id: string, overrides?: { name?: string; description?: string }): Promise<CloudMode> {
+        this.requireAuth();
+        const response = await fetch(`${this.baseUrl}/modes/${id}/fork`, {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+                Authorization: `Bearer ${this.authToken}`,
+            },
+            body: JSON.stringify(overrides || {}),
+        });
+        if (!response.ok) throw new Error('Failed to fork mode');
+        return response.json();
+    }
+
+    private requireAuth() {
+        if (!this.authToken) {
+            throw new Error('Authentication required');
+        }
     }
-  }
 }
 ```
 
@@ -568,166 +638,166 @@ export class CloudStorageService {
 ```typescript
 // src/hooks/useCloudStorage.ts
 
-import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
-import { CloudStorageService } from '@/lib/services/cloud-storage';
-import { useAuth } from '@/hooks/useAuth';
+import {useQuery, useMutation, useQueryClient} from '@tanstack/react-query';
+import {CloudStorageService} from '@/lib/services/cloud-storage';
+import {useAuth} from '@/hooks/useAuth';
 
 const cloudStorage = new CloudStorageService(
-  import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api/v1'
+    import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api/v1'
 );
 
 export function useCatalogModes(filters?: ModeFilters) {
-  return useQuery({
-    queryKey: ['catalog-modes', filters],
-    queryFn: () => cloudStorage.browseModes(filters),
-    staleTime: 5 * 60 * 1000, // 5 minutes
-  });
+    return useQuery({
+        queryKey: ['catalog-modes', filters],
+        queryFn: () => cloudStorage.browseModes(filters),
+        staleTime: 5 * 60 * 1000, // 5 minutes
+    });
 }
 
 export function useModeById(id: string) {
-  return useQuery({
-    queryKey: ['mode', id],
-    queryFn: () => cloudStorage.getModeById(id),
-    enabled: !!id,
-  });
+    return useQuery({
+        queryKey: ['mode', id],
+        queryFn: () => cloudStorage.getModeById(id),
+        enabled: !!id,
+    });
 }
 
 export function useSearchModes(query: string, filters?: ModeFilters) {
-  return useQuery({
-    queryKey: ['search-modes', query, filters],
-    queryFn: () => cloudStorage.searchModes(query, filters),
-    enabled: query.length > 2,
-  });
+    return useQuery({
+        queryKey: ['search-modes', query, filters],
+        queryFn: () => cloudStorage.searchModes(query, filters),
+        enabled: query.length > 2,
+    });
 }
 
 export function useUserModes() {
-  const { user, token } = useAuth();
-
-  return useQuery({
-    queryKey: ['user-modes', user?.id],
-    queryFn: () => {
-      cloudStorage.authToken = token;
-      return cloudStorage.getUserModes();
-    },
-    enabled: !!user,
-  });
+    const {user, token} = useAuth();
+
+    return useQuery({
+        queryKey: ['user-modes', user?.id],
+        queryFn: () => {
+            cloudStorage.authToken = token;
+            return cloudStorage.getUserModes();
+        },
+        enabled: !!user,
+    });
 }
 
 export function useUploadMode() {
-  const queryClient = useQueryClient();
-  const { token } = useAuth();
-
-  return useMutation({
-    mutationFn: (data: { mode: CustomMode; metadata: ModeMetadata }) => {
-      cloudStorage.authToken = token;
-      return cloudStorage.uploadMode(data.mode, data.metadata);
-    },
-    onSuccess: () => {
-      queryClient.invalidateQueries({ queryKey: ['user-modes'] });
-    },
-  });
+    const queryClient = useQueryClient();
+    const {token} = useAuth();
+
+    return useMutation({
+        mutationFn: (data: { mode: CustomMode; metadata: ModeMetadata }) => {
+            cloudStorage.authToken = token;
+            return cloudStorage.uploadMode(data.mode, data.metadata);
+        },
+        onSuccess: () => {
+            queryClient.invalidateQueries({queryKey: ['user-modes']});
+        },
+    });
 }
 
 export function useUpdateMode() {
-  const queryClient = useQueryClient();
-  const { token } = useAuth();
-
-  return useMutation({
-    mutationFn: (data: { id: string; updates: Partial<CloudMode> }) => {
-      cloudStorage.authToken = token;
-      return cloudStorage.updateMode(data.id, data.updates);
-    },
-    onSuccess: (_, variables) => {
-      queryClient.invalidateQueries({ queryKey: ['mode', variables.id] });
-      queryClient.invalidateQueries({ queryKey: ['user-modes'] });
-    },
-  });
+    const queryClient = useQueryClient();
+    const {token} = useAuth();
+
+    return useMutation({
+        mutationFn: (data: { id: string; updates: Partial<CloudMode> }) => {
+            cloudStorage.authToken = token;
+            return cloudStorage.updateMode(data.id, data.updates);
+        },
+        onSuccess: (_, variables) => {
+            queryClient.invalidateQueries({queryKey: ['mode', variables.id]});
+            queryClient.invalidateQueries({queryKey: ['user-modes']});
+        },
+    });
 }
 
 export function useDeleteMode() {
-  const queryClient = useQueryClient();
-  const { token } = useAuth();
-
-  return useMutation({
-    mutationFn: (id: string) => {
-      cloudStorage.authToken = token;
-      return cloudStorage.deleteMode(id);
-    },
-    onSuccess: () => {
-      queryClient.invalidateQueries({ queryKey: ['user-modes'] });
-    },
-  });
+    const queryClient = useQueryClient();
+    const {token} = useAuth();
+
+    return useMutation({
+        mutationFn: (id: string) => {
+            cloudStorage.authToken = token;
+            return cloudStorage.deleteMode(id);
+        },
+        onSuccess: () => {
+            queryClient.invalidateQueries({queryKey: ['user-modes']});
+        },
+    });
 }
 
 export function useLikeMode() {
-  const queryClient = useQueryClient();
-  const { token } = useAuth();
-
-  return useMutation({
-    mutationFn: (id: string) => {
-      cloudStorage.authToken = token;
-      return cloudStorage.likeMode(id);
-    },
-    onMutate: async (id) => {
-      // Optimistic update
-      await queryClient.cancelQueries({ queryKey: ['mode', id] });
-      const previousMode = queryClient.getQueryData<CloudMode>(['mode', id]);
-
-      if (previousMode) {
-        queryClient.setQueryData<CloudMode>(['mode', id], {
-          ...previousMode,
-          likes: previousMode.likes + 1,
-        });
-      }
-
-      return { previousMode };
-    },
-    onError: (err, id, context) => {
-      // Rollback on error
-      if (context?.previousMode) {
-        queryClient.setQueryData(['mode', id], context.previousMode);
-      }
-    },
-    onSettled: (_, __, id) => {
-      queryClient.invalidateQueries({ queryKey: ['mode', id] });
-    },
-  });
+    const queryClient = useQueryClient();
+    const {token} = useAuth();
+
+    return useMutation({
+        mutationFn: (id: string) => {
+            cloudStorage.authToken = token;
+            return cloudStorage.likeMode(id);
+        },
+        onMutate: async (id) => {
+            // Optimistic update
+            await queryClient.cancelQueries({queryKey: ['mode', id]});
+            const previousMode = queryClient.getQueryData<CloudMode>(['mode', id]);
+
+            if (previousMode) {
+                queryClient.setQueryData<CloudMode>(['mode', id], {
+                    ...previousMode,
+                    likes: previousMode.likes + 1,
+                });
+            }
+
+            return {previousMode};
+        },
+        onError: (err, id, context) => {
+            // Rollback on error
+            if (context?.previousMode) {
+                queryClient.setQueryData(['mode', id], context.previousMode);
+            }
+        },
+        onSettled: (_, __, id) => {
+            queryClient.invalidateQueries({queryKey: ['mode', id]});
+        },
+    });
 }
 
 export function useRateMode() {
-  const queryClient = useQueryClient();
-  const { token } = useAuth();
-
-  return useMutation({
-    mutationFn: (data: { id: string; rating: number }) => {
-      cloudStorage.authToken = token;
-      return cloudStorage.rateMode(data.id, data.rating);
-    },
-    onSuccess: (_, variables) => {
-      queryClient.invalidateQueries({ queryKey: ['mode', variables.id] });
-    },
-  });
+    const queryClient = useQueryClient();
+    const {token} = useAuth();
+
+    return useMutation({
+        mutationFn: (data: { id: string; rating: number }) => {
+            cloudStorage.authToken = token;
+            return cloudStorage.rateMode(data.id, data.rating);
+        },
+        onSuccess: (_, variables) => {
+            queryClient.invalidateQueries({queryKey: ['mode', variables.id]});
+        },
+    });
 }
 
 export function useDownloadMode() {
-  return useMutation({
-    mutationFn: (id: string) => cloudStorage.downloadMode(id),
-  });
+    return useMutation({
+        mutationFn: (id: string) => cloudStorage.downloadMode(id),
+    });
 }
 
 export function useForkMode() {
-  const queryClient = useQueryClient();
-  const { token } = useAuth();
-
-  return useMutation({
-    mutationFn: (data: { id: string; overrides?: any }) => {
-      cloudStorage.authToken = token;
-      return cloudStorage.forkMode(data.id, data.overrides);
-    },
-    onSuccess: () => {
-      queryClient.invalidateQueries({ queryKey: ['user-modes'] });
-    },
-  });
+    const queryClient = useQueryClient();
+    const {token} = useAuth();
+
+    return useMutation({
+        mutationFn: (data: { id: string; overrides?: any }) => {
+            cloudStorage.authToken = token;
+            return cloudStorage.forkMode(data.id, data.overrides);
+        },
+        onSuccess: () => {
+            queryClient.invalidateQueries({queryKey: ['user-modes']});
+        },
+    });
 }
 ```
 
@@ -741,130 +811,131 @@ export function useForkMode() {
 // src/lib/sync/sync-manager.ts
 
 interface SyncState {
-  lastSyncAt?: string;
-  pendingUploads: PendingSync[];
-  conflicts: ConflictResolution[];
+    lastSyncAt?: string;
+    pendingUploads: PendingSync[];
+    conflicts: ConflictResolution[];
 }
 
 interface PendingSync {
-  modeId: string;
-  operation: 'create' | 'update' | 'delete';
-  data: CustomMode | Partial<CustomMode>;
-  timestamp: string;
+    modeId: string;
+    operation: 'create' | 'update' | 'delete';
+    data: CustomMode | Partial<CustomMode>;
+    timestamp: string;
 }
 
 interface ConflictResolution {
-  localMode: CustomMode;
-  remoteMode: CloudMode;
-  strategy: 'local-wins' | 'remote-wins' | 'manual' | 'merge';
+    localMode: CustomMode;
+    remoteMode: CloudMode;
+    strategy: 'local-wins' | 'remote-wins' | 'manual' | 'merge';
 }
 
 export class SyncManager {
-  constructor(
-    private localStorage: LocalStorageManager,
-    private cloudStorage: CloudStorageService,
-    private queryClient: QueryClient
-  ) {}
-
-  async sync(): Promise<SyncResult> {
-    if (!navigator.onLine) {
-      return { success: false, reason: 'offline' };
+    constructor(
+        private localStorage: LocalStorageManager,
+        private cloudStorage: CloudStorageService,
+        private queryClient: QueryClient
+    ) {
     }
 
-    try {
-      // 1. Upload pending changes
-      await this.uploadPendingChanges();
+    async sync(): Promise<SyncResult> {
+        if (!navigator.onLine) {
+            return {success: false, reason: 'offline'};
+        }
+
+        try {
+            // 1. Upload pending changes
+            await this.uploadPendingChanges();
 
-      // 2. Download remote updates
-      const remoteModesCheck = await this.cloudStorage.getUserModes();
+            // 2. Download remote updates
+            const remoteModesCheck = await this.cloudStorage.getUserModes();
 
-      // 3. Detect conflicts
-      const conflicts = await this.detectConflicts(remoteModes);
+            // 3. Detect conflicts
+            const conflicts = await this.detectConflicts(remoteModes);
 
-      // 4. Resolve conflicts
-      if (conflicts.length > 0) {
-        await this.resolveConflicts(conflicts);
-      }
+            // 4. Resolve conflicts
+            if (conflicts.length > 0) {
+                await this.resolveConflicts(conflicts);
+            }
 
-      // 5. Update local cache
-      this.queryClient.setQueryData(['user-modes'], remoteModes);
+            // 5. Update local cache
+            this.queryClient.setQueryData(['user-modes'], remoteModes);
 
-      return { success: true, syncedAt: new Date().toISOString() };
-    } catch (error) {
-      console.error('Sync failed:', error);
-      return { success: false, reason: error.message };
+            return {success: true, syncedAt: new Date().toISOString()};
+        } catch (error) {
+            console.error('Sync failed:', error);
+            return {success: false, reason: error.message};
+        }
     }
-  }
 
-  private async detectConflicts(remoteModes: CloudMode[]): Promise<ConflictResolution[]> {
-    const conflicts: ConflictResolution[] = [];
-    const localModes = await this.getLocalModes();
-
-    for (const localMode of localModes) {
-      const remoteMode = remoteModes.find(m => m.id === localMode.id);
+    private async detectConflicts(remoteModes: CloudMode[]): Promise<ConflictResolution[]> {
+        const conflicts: ConflictResolution[] = [];
+        const localModes = await this.getLocalModes();
+
+        for (const localMode of localModes) {
+            const remoteMode = remoteModes.find(m => m.id === localMode.id);
+
+            if (remoteMode) {
+                const localModified = new Date(localMode.modifiedAt);
+                const remoteModified = new Date(remoteMode.modifiedAt);
+
+                if (localModified > remoteModified && remoteModified > lastSyncAt) {
+                    // Both modified since last sync - conflict!
+                    conflicts.push({
+                        localMode,
+                        remoteMode,
+                        strategy: 'manual', // Prompt user
+                    });
+                }
+            }
+        }
 
-      if (remoteMode) {
-        const localModified = new Date(localMode.modifiedAt);
-        const remoteModified = new Date(remoteMode.modifiedAt);
+        return conflicts;
+    }
 
-        if (localModified > remoteModified && remoteModified > lastSyncAt) {
-          // Both modified since last sync - conflict!
-          conflicts.push({
-            localMode,
-            remoteMode,
-            strategy: 'manual', // Prompt user
-          });
+    private async resolveConflicts(conflicts: ConflictResolution[]): Promise<void> {
+        for (const conflict of conflicts) {
+            switch (conflict.strategy) {
+                case 'local-wins':
+                    await this.cloudStorage.updateMode(conflict.localMode.id, conflict.localMode);
+                    break;
+
+                case 'remote-wins':
+                    await this.localStorage.save(conflict.remoteMode);
+                    break;
+
+                case 'merge':
+                    const merged = this.mergeControls(conflict.localMode, conflict.remoteMode);
+                    await this.cloudStorage.updateMode(merged.id, merged);
+                    await this.localStorage.save(merged);
+                    break;
+
+                case 'manual':
+                    // Emit event for UI to handle
+                    this.emitConflictEvent(conflict);
+                    break;
+            }
         }
-      }
     }
 
-    return conflicts;
-  }
-
-  private async resolveConflicts(conflicts: ConflictResolution[]): Promise<void> {
-    for (const conflict of conflicts) {
-      switch (conflict.strategy) {
-        case 'local-wins':
-          await this.cloudStorage.updateMode(conflict.localMode.id, conflict.localMode);
-          break;
-
-        case 'remote-wins':
-          await this.localStorage.save(conflict.remoteMode);
-          break;
-
-        case 'merge':
-          const merged = this.mergeControls(conflict.localMode, conflict.remoteMode);
-          await this.cloudStorage.updateMode(merged.id, merged);
-          await this.localStorage.save(merged);
-          break;
-
-        case 'manual':
-          // Emit event for UI to handle
-          this.emitConflictEvent(conflict);
-          break;
-      }
+    private mergeControls(local: CustomMode, remote: CloudMode): CustomMode {
+        // Strategy: Merge control mappings, prefer local for conflicts
+        const mergedControls = {
+            ...remote.controls,
+            ...local.controls,
+        };
+
+        return {
+            ...remote,
+            controls: mergedControls,
+            modifiedAt: new Date().toISOString(),
+            version: this.incrementVersion(remote.version),
+        };
     }
-  }
 
-  private mergeControls(local: CustomMode, remote: CloudMode): CustomMode {
-    // Strategy: Merge control mappings, prefer local for conflicts
-    const mergedControls = {
-      ...remote.controls,
-      ...local.controls,
-    };
-
-    return {
-      ...remote,
-      controls: mergedControls,
-      modifiedAt: new Date().toISOString(),
-      version: this.incrementVersion(remote.version),
-    };
-  }
-
-  private incrementVersion(version: string): string {
-    const [major, minor, patch] = version.split('.').map(Number);
-    return `${major}.${minor}.${patch + 1}`;
-  }
+    private incrementVersion(version: string): string {
+        const [major, minor, patch] = version.split('.').map(Number);
+        return `${major}.${minor}.${patch + 1}`;
+    }
 }
 ```
 
@@ -877,29 +948,29 @@ export class SyncManager {
 ```typescript
 // Supabase Auth configuration
 const supabase = createClient(supabaseUrl, supabaseAnonKey, {
-  auth: {
-    autoRefreshToken: true,
-    persistSession: true,
-    detectSessionInUrl: true,
-  },
+    auth: {
+        autoRefreshToken: true,
+        persistSession: true,
+        detectSessionInUrl: true,
+    },
 });
 
 // Sign in with OAuth
 async function signInWithGoogle() {
-  const { error } = await supabase.auth.signInWithOAuth({
-    provider: 'google',
-    options: {
-      redirectTo: `${window.location.origin}/auth/callback`,
-    },
-  });
+    const {error} = await supabase.auth.signInWithOAuth({
+        provider: 'google',
+        options: {
+            redirectTo: `${window.location.origin}/auth/callback`,
+        },
+    });
 }
 
 // Sign in with email
 async function signInWithEmail(email: string, password: string) {
-  const { error } = await supabase.auth.signInWithPassword({
-    email,
-    password,
-  });
+    const {error} = await supabase.auth.signInWithPassword({
+        email,
+        password,
+    });
 }
 ```
 
@@ -912,32 +983,41 @@ ALTER TABLE mode_likes ENABLE ROW LEVEL SECURITY;
 ALTER TABLE mode_ratings ENABLE ROW LEVEL SECURITY;
 
 -- Public modes are readable by everyone
-CREATE POLICY "Public modes are viewable by everyone"
-  ON modes FOR SELECT
-  USING (is_public = true);
+CREATE
+POLICY "Public modes are viewable by everyone"
+  ON modes FOR
+SELECT
+    USING (is_public = true);
 
 -- Users can view their own modes
-CREATE POLICY "Users can view own modes"
-  ON modes FOR SELECT
-  USING (auth.uid() = author_id);
+CREATE
+POLICY "Users can view own modes"
+  ON modes FOR
+SELECT
+    USING (auth.uid() = author_id);
 
 -- Users can create modes
-CREATE POLICY "Users can create modes"
+CREATE
+POLICY "Users can create modes"
   ON modes FOR INSERT
   WITH CHECK (auth.uid() = author_id);
 
 -- Users can update their own modes
-CREATE POLICY "Users can update own modes"
-  ON modes FOR UPDATE
-  USING (auth.uid() = author_id);
+CREATE
+POLICY "Users can update own modes"
+  ON modes FOR
+UPDATE
+    USING (auth.uid() = author_id);
 
 -- Users can delete their own modes
-CREATE POLICY "Users can delete own modes"
+CREATE
+POLICY "Users can delete own modes"
   ON modes FOR DELETE
-  USING (auth.uid() = author_id);
+USING (auth.uid() = author_id);
 
 -- Admins can do everything (set via custom claim)
-CREATE POLICY "Admins have full access"
+CREATE
+POLICY "Admins have full access"
   ON modes
   USING (
     (auth.jwt() ->> 'role')::text = 'admin'
@@ -948,34 +1028,34 @@ CREATE POLICY "Admins have full access"
 
 ```typescript
 // Basic profanity filter
-import { badWords } from '@/lib/moderation/bad-words';
+import {badWords} from '@/lib/moderation/bad-words';
 
 function moderateContent(text: string): { clean: boolean; reason?: string } {
-  const lowerText = text.toLowerCase();
+    const lowerText = text.toLowerCase();
 
-  for (const word of badWords) {
-    if (lowerText.includes(word)) {
-      return { clean: false, reason: 'Inappropriate language detected' };
+    for (const word of badWords) {
+        if (lowerText.includes(word)) {
+            return {clean: false, reason: 'Inappropriate language detected'};
+        }
     }
-  }
 
-  return { clean: true };
+    return {clean: true};
 }
 
 // Server-side validation
 async function createMode(mode: CustomMode, metadata: ModeMetadata) {
-  const nameCheck = moderateContent(mode.name);
-  if (!nameCheck.clean) {
-    throw new Error(`Mode name rejected: ${nameCheck.reason}`);
-  }
+    const nameCheck = moderateContent(mode.name);
+    if (!nameCheck.clean) {
+        throw new Error(`Mode name rejected: ${nameCheck.reason}`);
+    }
 
-  const descCheck = moderateContent(metadata.description);
-  if (!descCheck.clean) {
-    throw new Error(`Description rejected: ${descCheck.reason}`);
-  }
+    const descCheck = moderateContent(metadata.description);
+    if (!descCheck.clean) {
+        throw new Error(`Description rejected: ${descCheck.reason}`);
+    }
 
-  // Proceed with creation
-  return await db.insert(modes).values({...});
+    // Proceed with creation
+    return await db.insert(modes).values({...});
 }
 ```
 
@@ -986,6 +1066,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 #### Phase 1: Foundation (2 weeks)
 
 **Week 1: Backend Setup**
+
 - [ ] Create Supabase project
 - [ ] Design and implement database schema
 - [ ] Set up row-level security policies
@@ -993,6 +1074,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Create API endpoints (REST via PostgREST)
 
 **Week 2: Frontend Integration**
+
 - [ ] Add authentication UI components
 - [ ] Implement `CloudStorageService` class
 - [ ] Create React Query hooks for cloud operations
@@ -1000,6 +1082,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Add environment variables for API configuration
 
 **Deliverables:**
+
 - Working authentication flow
 - Basic mode upload/download
 - User can see their own modes in the cloud
@@ -1009,6 +1092,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 #### Phase 2: Library Sync (2 weeks)
 
 **Week 3: Sync Manager**
+
 - [ ] Implement `SyncManager` class
 - [ ] Add offline detection
 - [ ] Create pending operations queue
@@ -1016,6 +1100,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Build conflict resolution UI
 
 **Week 4: Library Integration**
+
 - [ ] Update Library page to show cloud modes
 - [ ] Add sync status indicator
 - [ ] Implement manual sync button
@@ -1023,6 +1108,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Create mode version history UI
 
 **Deliverables:**
+
 - Seamless sync between local and cloud
 - Conflict resolution flow
 - Version history viewer
@@ -1032,6 +1118,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 #### Phase 3: Public Catalog (2 weeks)
 
 **Week 5: Catalog Backend**
+
 - [ ] Implement search indexing
 - [ ] Add filtering and sorting endpoints
 - [ ] Create category management
@@ -1039,6 +1126,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Add analytics tracking (views, downloads)
 
 **Week 6: Catalog UI**
+
 - [ ] Update Catalog page with real data
 - [ ] Implement search functionality
 - [ ] Add category filtering
@@ -1046,6 +1134,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Build featured modes section
 
 **Deliverables:**
+
 - Fully functional public catalog
 - Search and discovery features
 - Mode detail pages
@@ -1055,6 +1144,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 #### Phase 4: Engagement (2 weeks)
 
 **Week 7: Engagement Features**
+
 - [ ] Implement like system
 - [ ] Add rating system (1-5 stars)
 - [ ] Create fork/remix functionality
@@ -1062,6 +1152,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Add activity feed
 
 **Week 8: Social Features**
+
 - [ ] Add comments on modes
 - [ ] Implement follow system
 - [ ] Create notifications
@@ -1069,6 +1160,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Add share functionality
 
 **Deliverables:**
+
 - Social engagement features
 - User profiles and activity
 - Trending modes
@@ -1078,6 +1170,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 #### Phase 5: Polish (2 weeks)
 
 **Week 9: Performance & UX**
+
 - [ ] Implement caching strategies
 - [ ] Add skeleton loaders
 - [ ] Optimize image loading
@@ -1085,6 +1178,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Add error boundaries
 
 **Week 10: Analytics & Admin**
+
 - [ ] Build admin dashboard
 - [ ] Add analytics tracking
 - [ ] Create moderation tools
@@ -1092,6 +1186,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 - [ ] Add usage metrics
 
 **Deliverables:**
+
 - Production-ready system
 - Admin tools
 - Analytics dashboard
@@ -1101,6 +1196,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 ### 8. Technology Stack
 
 #### Backend (Supabase)
+
 ```json
 {
   "platform": "Supabase",
@@ -1114,6 +1210,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 ```
 
 #### Frontend (Existing + New)
+
 ```json
 {
   "framework": "React 18.3 + TypeScript 5.8",
@@ -1130,6 +1227,7 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 ```
 
 #### Development Tools
+
 ```json
 {
   "testing": {
@@ -1151,27 +1249,31 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 ### 9. Cost Analysis
 
 #### Development Phase (Free)
+
 - Supabase Free Tier:
-  - 500MB database
-  - 1GB file storage
-  - 2GB bandwidth/month
-  - 50,000 monthly active users
+    - 500MB database
+    - 1GB file storage
+    - 2GB bandwidth/month
+    - 50,000 monthly active users
 - Total: **$0/month**
 
 #### MVP Launch (< 1,000 users)
+
 - Supabase Free Tier: **$0**
 - Domain: **$12/year**
 - Total: **~$1/month**
 
 #### Growth Phase (< 10,000 users)
+
 - Supabase Pro: **$25/month**
-  - 8GB database
-  - 100GB storage
-  - 250GB bandwidth
+    - 8GB database
+    - 100GB storage
+    - 250GB bandwidth
 - Domain: **$1/month**
 - Total: **$26/month**
 
 #### Scale Phase (< 100,000 users)
+
 - Supabase Pro: **$25/month**
 - Additional database: **~$10/month**
 - Additional bandwidth: **~$20/month**
@@ -1185,22 +1287,22 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 
 #### Technical Risks
 
-| Risk | Impact | Likelihood | Mitigation |
-|------|--------|------------|------------|
-| Supabase vendor lock-in | High | Medium | Use abstraction layer; PostgreSQL is portable |
-| Data loss/corruption | Critical | Low | Automated backups; versioning |
-| API rate limits | Medium | Medium | Implement caching; use CDN |
-| Scalability issues | High | Low | Monitor performance; upgrade plan proactively |
-| Security breach | Critical | Low | RLS policies; regular audits; penetration testing |
+| Risk                    | Impact   | Likelihood | Mitigation                                        |
+|-------------------------|----------|------------|---------------------------------------------------|
+| Supabase vendor lock-in | High     | Medium     | Use abstraction layer; PostgreSQL is portable     |
+| Data loss/corruption    | Critical | Low        | Automated backups; versioning                     |
+| API rate limits         | Medium   | Medium     | Implement caching; use CDN                        |
+| Scalability issues      | High     | Low        | Monitor performance; upgrade plan proactively     |
+| Security breach         | Critical | Low        | RLS policies; regular audits; penetration testing |
 
 #### Business Risks
 
-| Risk | Impact | Likelihood | Mitigation |
-|------|--------|------------|------------|
-| Low user adoption | High | Medium | Marketing; community building; quality content |
-| Abuse/spam | Medium | Medium | Content moderation; rate limiting |
-| Copyright issues | High | Low | DMCA process; terms of service |
-| Hosting costs exceed budget | Medium | Low | Monitor usage; optimize storage |
+| Risk                        | Impact | Likelihood | Mitigation                                     |
+|-----------------------------|--------|------------|------------------------------------------------|
+| Low user adoption           | High   | Medium     | Marketing; community building; quality content |
+| Abuse/spam                  | Medium | Medium     | Content moderation; rate limiting              |
+| Copyright issues            | High   | Low        | DMCA process; terms of service                 |
+| Hosting costs exceed budget | Medium | Low        | Monitor usage; optimize storage                |
 
 ---
 
@@ -1209,24 +1311,28 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 #### Key Performance Indicators (KPIs)
 
 **User Engagement:**
+
 - Monthly Active Users (MAU)
 - Average session duration
 - Modes created per user
 - Return rate (7-day, 30-day)
 
 **Content Metrics:**
+
 - Total modes in catalog
 - Public vs. private ratio
 - Average rating
 - Download-to-view ratio
 
 **Community Health:**
+
 - Likes per mode (average)
 - Fork rate
 - Comment activity
 - Active contributors
 
 **Technical Metrics:**
+
 - API response time (p50, p95, p99)
 - Error rate (< 0.1%)
 - Uptime (99.9% target)
@@ -1256,9 +1362,12 @@ async function createMode(mode: CustomMode, metadata: ModeMetadata) {
 
 ## Conclusion
 
-This architecture provides a scalable, cost-effective foundation for cloud mode storage and sharing. The serverless approach with Supabase allows rapid development while maintaining professional-grade security and performance. The phased implementation ensures continuous delivery of value while managing complexity.
+This architecture provides a scalable, cost-effective foundation for cloud mode storage and sharing. The serverless
+approach with Supabase allows rapid development while maintaining professional-grade security and performance. The
+phased implementation ensures continuous delivery of value while managing complexity.
 
 The system is designed to be:
+
 - **User-friendly:** Seamless sync, offline-first, intuitive UI
 - **Scalable:** From MVP to thousands of users without major rewrites
 - **Secure:** Row-level security, content moderation, auth best practices


---

_**Agent (claude-sonnet-4-5-20250929)**_

docs(auth,cloud): add authentication workplan and format cloud storage research

