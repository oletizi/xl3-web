<!-- Generated by SpecStory -->

# 2025-09-27 04:55:24Z

<!-- Claude Code Session d00e472e-7e99-4045-bb26-a18214d1c541 (2025-09-27_04-55-24Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/WORKPLAN-CONTROL-PROPERTIES.md b/WORKPLAN-CONTROL-PROPERTIES.md
new file mode 100644
index 0000000..9a8b5f0
--- /dev/null
+++ b/WORKPLAN-CONTROL-PROPERTIES.md
@@ -0,0 +1,330 @@
+# Control Properties Implementation Workplan
+
+**Status**: ✅ COMPLETE
+**Date**: 2025-09-26
+**Completed**: 2025-09-26 @ 22:30
+**Feature**: Feature 3 - Control Properties
+
+## Specification Requirements (docs/EDITOR-SPECIFICATION.md)
+
+### Feature 3.1: Users can set properties on device controls
+- [ ] The user can click on a control and the corresponding control properties editor loads
+- [ ] The control CC number in the properties editor matches the control label in the visual display
+- [ ] The property values in the properties editor are updated to match the model data structure in memory
+- [ ] When the user changes control properties in the editor, the model data structure in memory is updated accordingly
+
+## Current State Analysis
+
+### What EXISTS:
+- ✅ `src/components/editor/ControllerVisual.tsx` - Visual display of all 48 controls
+- ✅ Control definitions with IDs and CC numbers (lines 10-79)
+- ✅ Click handlers on all controls (`onControlSelect` prop)
+- ✅ `selectedControl` state in Editor.tsx (line 35)
+- ✅ Control Properties panel UI (Editor.tsx lines 152-253)
+- ✅ Property input fields (CC Number, MIDI Channel, Min/Max Value, Label)
+- ✅ `mode.controls` data structure (CustomMode interface)
+
+### What is MISSING:
+- ❌ Control data structure not properly linked to `selectedControl`
+- ❌ Property inputs use `defaultValue` instead of controlled `value`
+- ❌ No initialization of `mode.controls` with default values
+- ❌ No synchronization between selected control and displayed properties
+- ❌ No onChange handlers to update `mode.controls` when user changes inputs
+- ❌ Control type detection (knob/fader/button) from control ID
+
+## Implementation Tasks
+
+### Task 1: Create Control Metadata Utility
+**File**: Create `src/utils/controlMetadata.ts`
+
+**What to implement**:
+```typescript
+export interface ControlInfo {
+  id: string;
+  cc: number;
+  type: 'knob' | 'fader' | 'button';
+  defaultLabel: string;
+}
+
+export function getControlInfo(controlId: string): ControlInfo | null {
+  // Parse control ID (e.g., "knob-cc13" → { id: "knob-cc13", cc: 13, type: "knob" })
+  // Return control metadata
+}
+
+export function getAllControls(): ControlInfo[] {
+  // Return all 48 controls with their metadata
+}
+
+export function initializeDefaultControls(): Record<string, ControlMapping> {
+  // Create default ControlMapping for all 48 controls
+}
+```
+
+**Success criteria**:
+- Parse all control IDs correctly (knob-cc13, fader-cc5, button-cc37)
+- Extract CC number from ID
+- Detect control type (knob/fader/button)
+- Provide default labels ("Knob 13", "Fader 5", "Button 37")
+- Initialize all 48 controls with sensible defaults
+
+---
+
+### Task 2: Initialize Mode Controls on Mount
+**File**: Modify `src/pages/Editor.tsx`
+
+**Changes needed**:
+1. Import `initializeDefaultControls` utility
+2. Initialize `mode.controls` with default values on mount
+3. Use `useEffect` to run once on component mount
+
+**Example implementation**:
+```typescript
+import { initializeDefaultControls } from '@/utils/controlMetadata';
+
+const Editor = () => {
+  const [mode, setMode] = useState<CustomMode>(() => ({
+    name: 'New Custom Mode',
+    description: '',
+    version: '1.0.0',
+    controls: initializeDefaultControls(), // Initialize with defaults
+    createdAt: new Date().toISOString(),
+    modifiedAt: new Date().toISOString()
+  }));
+
+  // Rest of component...
+};
+```
+
+**Success criteria**:
+- All 48 controls initialized in `mode.controls` on mount
+- Each control has default CC number, MIDI channel, min/max values
+- Controls persist in state throughout component lifecycle
+
+---
+
+### Task 3: Sync Property Inputs with Selected Control
+**File**: Modify `src/pages/Editor.tsx`
+
+**Changes needed**:
+1. Get control info from `selectedControl` using utility
+2. Get control mapping from `mode.controls[selectedControl]`
+3. Convert all property inputs from `defaultValue` to controlled `value`
+4. Bind values to the selected control's properties
+
+**Example changes**:
+```typescript
+// Get selected control data
+const selectedControlInfo = selectedControl ? getControlInfo(selectedControl) : null;
+const selectedControlMapping = selectedControl ? mode.controls[selectedControl] : null;
+
+// In JSX - CC Number input
+<Input
+  id="cc-number"
+  type="number"
+  min="0"
+  max="127"
+  value={selectedControlMapping?.ccNumber || 0}
+  className="mt-2 bg-background/50"
+/>
+
+// Display actual CC number in Badge
+<Badge variant="secondary" className="ml-2">
+  {selectedControlInfo ? `CC ${selectedControlInfo.cc}` : selectedControl}
+</Badge>
+```
+
+**Success criteria**:
+- Clicking a control updates all property inputs to show that control's values
+- CC Number input shows the correct CC from the control (matching visual label)
+- All inputs (CC Number, MIDI Channel, Min/Max, Label) display correct values
+- Values come from `mode.controls[selectedControl]`
+
+---
+
+### Task 4: Update Mode on Property Changes
+**File**: Modify `src/pages/Editor.tsx`
+
+**Changes needed**:
+1. Create `updateControlProperty` helper function
+2. Add onChange handlers to all property inputs
+3. Update `mode.controls[selectedControl]` when user changes inputs
+4. Update `modifiedAt` timestamp when changes occur
+
+**Example implementation**:
+```typescript
+const updateControlProperty = (field: keyof ControlMapping, value: any) => {
+  if (!selectedControl) return;
+
+  setMode(prevMode => ({
+    ...prevMode,
+    controls: {
+      ...prevMode.controls,
+      [selectedControl]: {
+        ...prevMode.controls[selectedControl],
+        [field]: value
+      }
+    },
+    modifiedAt: new Date().toISOString()
+  }));
+};
+
+// In JSX - CC Number input
+<Input
+  id="cc-number"
+  type="number"
+  min="0"
+  max="127"
+  value={selectedControlMapping?.ccNumber || 0}
+  onChange={(e) => updateControlProperty('ccNumber', parseInt(e.target.value))}
+  className="mt-2 bg-background/50"
+/>
+```
+
+**Success criteria**:
+- Changing CC Number updates `mode.controls[selectedControl].ccNumber`
+- Changing MIDI Channel updates `mode.controls[selectedControl].midiChannel`
+- Changing Min/Max values updates corresponding fields
+- Changing Label updates `mode.controls[selectedControl].label`
+- `mode.modifiedAt` timestamp updates on each change
+- Changes persist when switching between controls
+
+---
+
+### Task 5: Verification with Playwright MCP
+**What to test**:
+
+**Test 1: Click control and verify properties load**
+1. Navigate to http://localhost:8081/
+2. Click on "CC 13" knob
+3. Verify "Control Properties" panel shows:
+   - Control Type badge shows "CC 13" (or control ID)
+   - CC Number input shows "13"
+   - MIDI Channel shows "1" (default)
+   - Min Value shows "0"
+   - Max Value shows "127"
+
+**Test 2: Verify CC number matches visual label**
+1. Click on "CC 53" knob (middle row, first control)
+2. Verify CC Number input shows "53"
+3. Click on "CC 5" fader
+4. Verify CC Number input shows "5"
+5. Click on "CC 45" button
+6. Verify CC Number input shows "45"
+
+**Test 3: Change properties and verify persistence**
+1. Click on "CC 13" knob
+2. Change CC Number from 13 to 99
+3. Click on "CC 14" knob (different control)
+4. Click back on "CC 13" knob
+5. Verify CC Number still shows 99
+6. Verify the change persisted in memory
+
+**Test 4: Change all property types**
+1. Click any control
+2. Change CC Number to 77
+3. Change MIDI Channel to 5
+4. Change Min Value to 10
+5. Change Max Value to 100
+6. Type custom label "My Control"
+7. Click different control, then click back
+8. Verify all values persisted
+
+**Success criteria**:
+- All tests pass
+- Properties load immediately when clicking controls
+- CC numbers match visual labels exactly
+- Property changes update the in-memory model
+- Changes persist when switching between controls
+
+---
+
+## Implementation Order
+
+1. **Task 1** - Create control metadata utility (foundation)
+2. **Task 2** - Initialize mode.controls with defaults
+3. **Task 3** - Sync property inputs with selected control (display)
+4. **Task 4** - Update mode on property changes (editing)
+5. **Task 5** - Verify with Playwright MCP (validation)
+
+## Testing Approach
+
+### Manual Testing Steps:
+
+**Basic Click Test:**
+1. Open editor at http://localhost:8081/
+2. Click any knob
+3. Verify properties panel shows control data
+4. Verify CC number matches label
+
+**Property Update Test:**
+1. Click a control
+2. Change each property field
+3. Click away and back
+4. Verify changes persisted
+
+**Cross-Control Test:**
+1. Click CC 13, set custom values
+2. Click CC 14, set different custom values
+3. Click back to CC 13
+4. Verify original values retained
+
+---
+
+## COMPLETION SUMMARY
+
+### Implementation Status: ✅ ALL TASKS COMPLETE
+
+**Task 1: Create Control Metadata Utility** ✅
+- File: `src/utils/controlMetadata.ts` (133 lines, 2.8KB)
+- Created `ControlInfo` interface
+- Implemented `getControlInfo()` - parses control IDs and extracts metadata
+- Implemented `getAllControls()` - returns all 48 controls
+- Implemented `initializeDefaultControls()` - creates default ControlMappings
+- Fixed bug: Field names corrected to match ControlMapping interface (ccNumber, minValue, maxValue)
+
+**Task 2: Initialize Mode Controls** ✅
+- File: `src/pages/Editor.tsx` (modified)
+- Imported `initializeDefaultControls` and `getControlInfo`
+- Updated `mode` state initialization to use `initializeDefaultControls()`
+- All 48 controls now initialize with proper defaults on mount
+
+**Task 3: Sync Property Inputs** ✅
+- File: `src/pages/Editor.tsx` (modified)
+- Added `selectedControlInfo` and `selectedControlMapping` computed values
+- Converted all property inputs from `defaultValue` to controlled `value` props
+- Updated Control Type badge to show `CC ${selectedControlInfo?.cc}`
+- All 5 inputs now sync with selected control data
+
+**Task 4: Update Mode on Property Changes** ✅
+- File: `src/pages/Editor.tsx` (modified)
+- Created `updateControlProperty` helper function
+- Added onChange handlers to all 5 property inputs
+- Changes update `mode.controls[selectedControl]` immutably
+- `modifiedAt` timestamp updates on each change
+
+**Task 5: Verification with Playwright MCP** ✅
+
+**Test Results**:
+- ✅ Click CC 13 knob → Properties show CC 13
+- ✅ Click CC 53 knob → Properties show CC 53
+- ✅ Click CC 5 fader → Properties show CC 5
+- ✅ Click CC 37 button → Properties show CC 37
+- ✅ Change CC 37 to 99 → Switch to CC 13 → Switch back to CC 37 → Still shows 99 (persisted!)
+
+### Files Created/Modified
+
+1. **Created**: `/Users/orion/work/xl3-web/src/utils/controlMetadata.ts` (133 lines)
+2. **Modified**: `/Users/orion/work/xl3-web/src/pages/Editor.tsx` (8 edits)
+
+### Specification Requirements Met
+
+- ✅ The user can click on a control and the corresponding control properties editor loads
+- ✅ The control CC number in the properties editor matches the control label in the visual display
+- ✅ The property values in the properties editor are updated to match the model data structure in memory
+- ✅ When the user changes control properties in the editor, the model data structure in memory is updated accordingly
+
+---
+
+**Implementation Date**: 2025-09-26
+**Verification Method**: Playwright MCP + Manual Testing
+**Result**: 🎉 SUCCESS - All requirements met and verified
\ No newline at end of file
diff --git a/docs/EDITOR-SPECIFICATION.md b/docs/EDITOR-SPECIFICATION.md
index 62a02c7..c73f90e 100644
--- a/docs/EDITOR-SPECIFICATION.md
+++ b/docs/EDITOR-SPECIFICATION.md
@@ -31,9 +31,16 @@ IMPORTANT: DEFERRED UNTIL AFTER MVP. DO NOT IMPLEMENT
 
 **Status**: UNIMPLEMENTED, DEFERRED
 
-## Feature 3: Control Properites
+## Feature 3: Control Properties
 3.1 Users can set properties on the device controls
-- [ ] The user can click on a control and the corresponding control properties editor loads
-- [ ] The control CC number in the properties editor matches the control label in the visual display
-- [ ] The property values in the properties editor are updated to match the model data structure in memory 
-- [ ] When the user changes control properties in the editor, the model data structure in memory is updated accordingly 
\ No newline at end of file
+- [x] 3.1.1 The user can click on a control and the corresponding control properties editor loads
+- [x] 3.1.2 The control CC number in the properties editor matches the control label in the visual display
+- [x] 3.1.3 The property values in the properties editor are updated to match the model data structure in memory
+- [x] 3.1.4 When the user changes control properties in the editor, the model data structure in memory is updated accordingly
+
+**Status**: ✅ IMPLEMENTED (2025-09-26 - verified with Playwright MCP, see WORKPLAN-CONTROL-PROPERTIES.md) 
+
+## Feature 4: State Persistence
+4.1 Users can reload/return to the editor and it will remember their state
+- [ ] The model data structure is persistent such that changes made to it in the editor are available when the user returns to the editor
+- [ ] The model data structure is reset to default values when the reset button is pressed
\ No newline at end of file
diff --git a/playwright.config.ts b/playwright.config.ts
index 9a62d62..4fe36c6 100644
--- a/playwright.config.ts
+++ b/playwright.config.ts
@@ -18,7 +18,7 @@ export default defineConfig({
   /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
   use: {
     /* Base URL to use in actions like `await page.goto('/')`. */
-    baseURL: 'http://localhost:8080',
+    baseURL: 'http://localhost:8081',
 
     /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
     trace: 'on-first-retry',
@@ -68,7 +68,7 @@ export default defineConfig({
   /* Run your local dev server before starting the tests */
   webServer: {
     command: 'npm run dev',
-    url: 'http://localhost:8080',
+    url: 'http://localhost:8081',
     reuseExistingServer: !process.env.CI,
     timeout: 30 * 1000,
   },
diff --git a/src/pages/Editor.tsx b/src/pages/Editor.tsx
index bceb3fb..5a761eb 100644
--- a/src/pages/Editor.tsx
+++ b/src/pages/Editor.tsx
@@ -19,21 +19,41 @@ import {
 } from "lucide-react";
 import { motion } from "framer-motion";
 import ControllerVisual from "@/components/editor/ControllerVisual";
-import { CustomMode } from "@/types/mode";
+import { CustomMode, ControlMapping } from "@/types/mode";
 import { saveMode, loadMode } from "@/utils/fileStorage";
 import { toast } from "sonner";
+import { initializeDefaultControls, getControlInfo } from "@/utils/controlMetadata";
 
 const Editor = () => {
   const [mode, setMode] = useState<CustomMode>({
     name: 'New Custom Mode',
     description: '',
     version: '1.0.0',
-    controls: {},
+    controls: initializeDefaultControls(),
     createdAt: new Date().toISOString(),
     modifiedAt: new Date().toISOString()
   });
   const [selectedControl, setSelectedControl] = useState<string | null>(null);
 
+  const selectedControlInfo = selectedControl ? getControlInfo(selectedControl) : null;
+  const selectedControlMapping = selectedControl ? mode.controls[selectedControl] : null;
+
+  const updateControlProperty = (field: keyof ControlMapping, value: any) => {
+    if (!selectedControl) return;
+
+    setMode(prevMode => ({
+      ...prevMode,
+      controls: {
+        ...prevMode.controls,
+        [selectedControl]: {
+          ...prevMode.controls[selectedControl],
+          [field]: value
+        }
+      },
+      modifiedAt: new Date().toISOString()
+    }));
+  };
+
   const handleSave = async () => {
     try {
       await saveMode(mode);
@@ -163,30 +183,32 @@ const Editor = () => {
                   <div>
                     <Label className="text-foreground">Control Type</Label>
                     <Badge variant="secondary" className="ml-2">
-                      {selectedControl}
+                      CC {selectedControlInfo?.cc}
                     </Badge>
                   </div>
                   
                   <div>
                     <Label htmlFor="cc-number" className="text-foreground">CC Number</Label>
-                    <Input 
+                    <Input
                       id="cc-number"
-                      type="number" 
-                      min="0" 
-                      max="127" 
-                      defaultValue="1"
+                      type="number"
+                      min="0"
+                      max="127"
+                      value={selectedControlMapping?.ccNumber || 0}
+                      onChange={(e) => updateControlProperty('ccNumber', parseInt(e.target.value))}
                       className="mt-2 bg-background/50"
                     />
                   </div>
                   
                   <div>
                     <Label htmlFor="midi-channel" className="text-foreground">MIDI Channel</Label>
-                    <Input 
+                    <Input
                       id="midi-channel"
-                      type="number" 
-                      min="1" 
-                      max="16" 
-                      defaultValue="1"
+                      type="number"
+                      min="1"
+                      max="16"
+                      value={selectedControlMapping?.midiChannel || 1}
+                      onChange={(e) => updateControlProperty('midiChannel', parseInt(e.target.value))}
                       className="mt-2 bg-background/50"
                     />
                   </div>
@@ -194,23 +216,25 @@ const Editor = () => {
                   <div className="grid grid-cols-2 gap-2">
                     <div>
                       <Label htmlFor="min-val" className="text-foreground">Min Value</Label>
-                      <Input 
+                      <Input
                         id="min-val"
-                        type="number" 
-                        min="0" 
-                        max="127" 
-                        defaultValue="0"
+                        type="number"
+                        min="0"
+                        max="127"
+                        value={selectedControlMapping?.minValue || 0}
+                        onChange={(e) => updateControlProperty('minValue', parseInt(e.target.value))}
                         className="mt-2 bg-background/50"
                       />
                     </div>
                     <div>
                       <Label htmlFor="max-val" className="text-foreground">Max Value</Label>
-                      <Input 
+                      <Input
                         id="max-val"
-                        type="number" 
-                        min="0" 
-                        max="127" 
-                        defaultValue="127"
+                        type="number"
+                        min="0"
+                        max="127"
+                        value={selectedControlMapping?.maxValue || 127}
+                        onChange={(e) => updateControlProperty('maxValue', parseInt(e.target.value))}
                         className="mt-2 bg-background/50"
                       />
                     </div>
@@ -220,9 +244,11 @@ const Editor = () => {
                 <TabsContent value="advanced" className="space-y-4">
                   <div>
                     <Label htmlFor="control-name" className="text-foreground">Control Label</Label>
-                    <Input 
+                    <Input
                       id="control-name"
                       placeholder="Custom name..."
+                      value={selectedControlMapping?.label || ''}
+                      onChange={(e) => updateControlProperty('label', e.target.value)}
                       className="mt-2 bg-background/50"
                     />
                   </div>
diff --git a/src/utils/controlMetadata.ts b/src/utils/controlMetadata.ts
new file mode 100644
index 0000000..20f5ef5
--- /dev/null
+++ b/src/utils/controlMetadata.ts
@@ -0,0 +1,136 @@
+import type { ControlMapping } from '@/types/mode';
+
+export interface ControlInfo {
+  id: string;
+  cc: number;
+  type: 'knob' | 'fader' | 'button';
+  defaultLabel: string;
+}
+
+/**
+ * Parse control ID and return control information
+ * Supports formats: "knob-cc13", "fader-cc5", "button-cc37"
+ */
+export function getControlInfo(controlId: string): ControlInfo | null {
+  const match = controlId.match(/^(knob|fader|button)-cc(\d+)$/);
+  if (!match) {
+    return null;
+  }
+
+  const [, type, ccStr] = match;
+  const cc = parseInt(ccStr, 10);
+
+  if (isNaN(cc) || cc < 0 || cc > 127) {
+    return null;
+  }
+
+  // Validate CC numbers are in expected ranges
+  const validType = type as 'knob' | 'fader' | 'button';
+  if (!isValidCCForType(cc, validType)) {
+    return null;
+  }
+
+  return {
+    id: controlId,
+    cc,
+    type: validType,
+    defaultLabel: `${type.charAt(0).toUpperCase() + type.slice(1)} ${cc}`
+  };
+}
+
+/**
+ * Validate that CC number is in the expected range for control type
+ */
+function isValidCCForType(cc: number, type: 'knob' | 'fader' | 'button'): boolean {
+  switch (type) {
+    case 'knob':
+      // Knobs: CC 13-20, 53, 22-36
+      return (cc >= 13 && cc <= 20) || cc === 53 || (cc >= 22 && cc <= 36);
+    case 'fader':
+      // Faders: CC 5-12
+      return cc >= 5 && cc <= 12;
+    case 'button':
+      // Buttons: CC 37-52
+      return cc >= 37 && cc <= 52;
+    default:
+      return false;
+  }
+}
+
+/**
+ * Get all 48 control definitions
+ */
+export function getAllControls(): ControlInfo[] {
+  const controls: ControlInfo[] = [];
+
+  // Knobs: CC 13-20, 53, 22-36 (24 total)
+  for (let cc = 13; cc <= 20; cc++) {
+    controls.push({
+      id: `knob-cc${cc}`,
+      cc,
+      type: 'knob',
+      defaultLabel: `Knob ${cc}`
+    });
+  }
+
+  // CC 53 knob
+  controls.push({
+    id: 'knob-cc53',
+    cc: 53,
+    type: 'knob',
+    defaultLabel: 'Knob 53'
+  });
+
+  for (let cc = 22; cc <= 36; cc++) {
+    controls.push({
+      id: `knob-cc${cc}`,
+      cc,
+      type: 'knob',
+      defaultLabel: `Knob ${cc}`
+    });
+  }
+
+  // Faders: CC 5-12 (8 total)
+  for (let cc = 5; cc <= 12; cc++) {
+    controls.push({
+      id: `fader-cc${cc}`,
+      cc,
+      type: 'fader',
+      defaultLabel: `Fader ${cc}`
+    });
+  }
+
+  // Buttons: CC 37-52 (16 total)
+  for (let cc = 37; cc <= 52; cc++) {
+    controls.push({
+      id: `button-cc${cc}`,
+      cc,
+      type: 'button',
+      defaultLabel: `Button ${cc}`
+    });
+  }
+
+  return controls;
+}
+
+/**
+ * Initialize default control mappings for all 48 controls
+ */
+export function initializeDefaultControls(): Record<string, ControlMapping> {
+  const controls = getAllControls();
+  const mappings: Record<string, ControlMapping> = {};
+
+  for (const control of controls) {
+    mappings[control.id] = {
+      id: control.id,
+      type: control.type,
+      ccNumber: control.cc,
+      midiChannel: 1,
+      minValue: 0,
+      maxValue: 127,
+      label: control.defaultLabel
+    };
+  }
+
+  return mappings;
+}
\ No newline at end of file
diff --git a/test-results/.last-run.json b/test-results/.last-run.json
index 5f549ae..cbcc1fb 100644
--- a/test-results/.last-run.json
+++ b/test-results/.last-run.json
@@ -1,6 +1,4 @@
 {
-  "status": "failed",
-  "failedTests": [
-    "a752c70704b4aae41c6b-1b7e42e7ba1f2470959c"
-  ]
+  "status": "passed",
+  "failedTests": []
 }
\ No newline at end of file
diff --git a/test-results/device-autoconnect-Device--663d0-trol-updates-property-panel-webkit/error-context.md b/test-results/device-autoconnect-Device--663d0-trol-updates-property-panel-webkit/error-context.md
deleted file mode 100644
index 049a9fc..0000000
--- a/test-results/device-autoconnect-Device--663d0-trol-updates-property-panel-webkit/error-context.md
+++ /dev/null
@@ -1,132 +0,0 @@
-# Page snapshot
-
-```yaml
-- generic [ref=e2]:
-  - region "Notifications (F8)":
-    - list
-  - region "Notifications alt+T"
-  - generic [ref=e3]:
-    - banner [ref=e4]:
-      - generic [ref=e5]:
-        - link "XL 3" [ref=e6]:
-          - /url: /
-          - img [ref=e8]
-          - heading "XL 3" [level=1] [ref=e11]
-        - navigation [ref=e12]:
-          - link "Editor" [ref=e13]:
-            - /url: /
-            - button "Editor" [ref=e15] [cursor=pointer]:
-              - img
-              - text: Editor
-          - link "Library" [ref=e16]:
-            - /url: /library
-            - button "Library" [ref=e18] [cursor=pointer]:
-              - img
-              - text: Library
-          - link "Catalog" [ref=e19]:
-            - /url: /catalog
-            - button "Catalog" [ref=e21] [cursor=pointer]:
-              - img
-              - text: Catalog
-        - generic [ref=e22]:
-          - button "Disconnected" [ref=e23] [cursor=pointer]:
-            - img
-            - generic [ref=e24] [cursor=pointer]: Disconnected
-          - button [ref=e25] [cursor=pointer]:
-            - img
-    - main [ref=e26]:
-      - generic [ref=e27]:
-        - generic [ref=e28]:
-          - generic [ref=e29]:
-            - heading "Mode Editor" [level=1] [ref=e30]
-            - paragraph [ref=e31]: Design custom control mappings for your Launch Control XL3
-          - generic [ref=e32]:
-            - button "Reset" [ref=e33] [cursor=pointer]:
-              - img
-              - text: Reset
-            - button "Import" [ref=e34] [cursor=pointer]:
-              - img
-              - text: Import
-            - button "Export" [ref=e35] [cursor=pointer]:
-              - img
-              - text: Export
-            - button "Send" [ref=e36] [cursor=pointer]:
-              - img
-              - text: Send
-            - button "Save" [ref=e37] [cursor=pointer]:
-              - img
-              - text: Save
-        - generic [ref=e38]:
-          - img [ref=e43]:
-            - generic [ref=e48]: CC 13
-            - generic [ref=e52]: CC 14
-            - generic [ref=e56]: CC 15
-            - generic [ref=e60]: CC 16
-            - generic [ref=e64]: CC 17
-            - generic [ref=e68]: CC 18
-            - generic [ref=e72]: CC 19
-            - generic [ref=e76]: CC 20
-            - generic [ref=e80]: CC 53
-            - generic [ref=e84]: CC 22
-            - generic [ref=e88]: CC 23
-            - generic [ref=e92]: CC 24
-            - generic [ref=e96]: CC 25
-            - generic [ref=e100]: CC 26
-            - generic [ref=e104]: CC 27
-            - generic [ref=e108]: CC 28
-            - generic [ref=e112]: CC 29
-            - generic [ref=e116]: CC 30
-            - generic [ref=e120]: CC 31
-            - generic [ref=e124]: CC 32
-            - generic [ref=e128]: CC 33
-            - generic [ref=e132]: CC 34
-            - generic [ref=e136]: CC 35
-            - generic [ref=e140]: CC 36
-            - generic [ref=e144]: CC 5
-            - generic [ref=e148]: CC 6
-            - generic [ref=e152]: CC 7
-            - generic [ref=e156]: CC 8
-            - generic [ref=e160]: CC 9
-            - generic [ref=e164]: CC 10
-            - generic [ref=e168]: CC 11
-            - generic [ref=e172]: CC 12
-            - generic [ref=e176]: CC 37
-            - generic [ref=e180]: CC 38
-            - generic [ref=e184]: CC 39
-            - generic [ref=e188]: CC 40
-            - generic [ref=e192]: CC 41
-            - generic [ref=e196]: CC 42
-            - generic [ref=e200]: CC 43
-            - generic [ref=e204]: CC 44
-            - generic [ref=e208]: CC 45
-            - generic [ref=e212]: CC 46
-            - generic [ref=e216]: CC 47
-            - generic [ref=e220]: CC 48
-            - generic [ref=e224]: CC 49
-            - generic [ref=e228]: CC 50
-            - generic [ref=e232]: CC 51
-            - generic [ref=e236]: CC 52
-          - generic [ref=e237]:
-            - generic [ref=e238]:
-              - heading "Mode Settings" [level=3] [ref=e239]
-              - generic [ref=e240]:
-                - generic [ref=e241]:
-                  - generic [ref=e242]: Mode Name
-                  - textbox "Mode Name" [ref=e243]: New Custom Mode
-                - generic [ref=e244]:
-                  - generic [ref=e245]: Description
-                  - textbox "Description" [ref=e246]
-            - generic [ref=e247]:
-              - heading "Control Properties" [level=3] [ref=e248]
-              - generic [ref=e249]:
-                - img [ref=e250]
-                - paragraph [ref=e253]: Select a control on the device to configure its properties
-    - contentinfo [ref=e254]:
-      - generic [ref=e256]:
-        - paragraph [ref=e257]: XL 3 Web UI - Professional Mode Editor
-        - generic [ref=e258]:
-          - generic [ref=e259]: Build with ⚡ by Lovable
-          - generic [ref=e260]:
-            - img [ref=e261]
-            - generic [ref=e263]: Ready
-```
\ No newline at end of file
diff --git a/test-results/device-autoconnect-Device--663d0-trol-updates-property-panel-webkit/test-failed-1.png b/test-results/device-autoconnect-Device--663d0-trol-updates-property-panel-webkit/test-failed-1.png
deleted file mode 100644
index f2e36d1..0000000
Binary files a/test-results/device-autoconnect-Device--663d0-trol-updates-property-panel-webkit/test-failed-1.png and /dev/null differ
diff --git a/tests/e2e/feature-1-device-autoconnect.spec.ts b/tests/e2e/feature-1-device-autoconnect.spec.ts
new file mode 100644
index 0000000..743a1d2
--- /dev/null
+++ b/tests/e2e/feature-1-device-autoconnect.spec.ts
@@ -0,0 +1,93 @@
+import { test, expect } from '@playwright/test';
+
+/**
+ * Feature 1: Device MIDI Auto-Connect
+ *
+ * Tests that the web app automatically connects to the Launch Control XL3
+ * device when it loads or when a new device is connected.
+ *
+ * Requirements:
+ * - App detects device, if connected
+ * - App initiates MIDI SysEx handshake
+ * - On successful handshake, connection status switches from "Disconnected" to "Connected"
+ *
+ * NOTE: This test requires a physical Launch Control XL3 device to be connected.
+ * If no device is connected, the test will fail.
+ */
+
+test.describe('Feature 1: Device MIDI Auto-Connect', () => {
+  test.beforeEach(async ({ page, context }) => {
+    // Grant MIDI permissions
+    await context.grantPermissions(['midi-sysex', 'midi']);
+
+    // Navigate to the editor page
+    await page.goto('http://localhost:8081/');
+  });
+
+  test('should auto-connect to LCXL3 device and update connection status', async ({ page }) => {
+    // Collect console logs
+    const consoleLogs: string[] = [];
+    page.on('console', msg => {
+      if (msg.type() === 'log') {
+        consoleLogs.push(msg.text());
+      }
+    });
+
+    // Wait for the page to load
+    await expect(page.getByRole('heading', { name: 'Mode Editor' })).toBeVisible();
+
+    // Find the connection button (it's in the top nav)
+    const connectionButton = page.locator('button').filter({ hasText: /Disconnected|Connected/i }).first();
+
+    // Wait for auto-connect to complete (max 10 seconds)
+    // The connection status should change from "Disconnected" to "Connected: LCXL3 1 MIDI"
+    await expect(connectionButton).toContainText('Connected', { timeout: 10000 });
+
+    // Verify the full connection status text includes the device name
+    await expect(connectionButton).toContainText('LCXL3 1 MIDI');
+
+    // Give time for console logs to accumulate
+    await page.waitForTimeout(500);
+
+    // Check that handshake logs are present
+    const hasHandshakeLogs = consoleLogs.some(log =>
+      log.includes('LCXL3 handshake successful') ||
+      log.includes('Sent device inquiry')
+    );
+
+    expect(hasHandshakeLogs).toBeTruthy();
+  });
+
+  test('should show correct connection state in UI', async ({ page }) => {
+    // Wait for page to load
+    await expect(page.getByRole('heading', { name: 'Mode Editor' })).toBeVisible();
+
+    // Find the connection button
+    const connectionButton = page.locator('button').filter({ hasText: /Connected/i }).first();
+    await expect(connectionButton).toBeVisible({ timeout: 10000 });
+
+    // Verify the button shows connected state with device name
+    const hasConnectedText = await connectionButton.evaluate((el) => {
+      const text = el.textContent || '';
+      return text.includes('Connected') && text.includes('LCXL3');
+    });
+
+    expect(hasConnectedText).toBeTruthy();
+  });
+
+  test('should maintain connection throughout page interaction', async ({ page }) => {
+    // Wait for page to load
+    await expect(page.getByRole('heading', { name: 'Mode Editor' })).toBeVisible();
+
+    // Wait for initial connection
+    const connectionButton = page.locator('button').filter({ hasText: /Connected/i }).first();
+    await expect(connectionButton).toContainText('Connected', { timeout: 10000 });
+
+    // Interact with the page (click different controls)
+    await page.getByRole('textbox', { name: 'Mode Name' }).fill('Test Mode');
+
+    // Verify connection status is still "Connected" after interaction
+    await expect(connectionButton).toContainText('Connected');
+    await expect(connectionButton).toContainText('LCXL3');
+  });
+});
\ No newline at end of file
diff --git a/tests/e2e/feature-3-control-properties.spec.ts b/tests/e2e/feature-3-control-properties.spec.ts
new file mode 100644
index 0000000..900ef16
--- /dev/null
+++ b/tests/e2e/feature-3-control-properties.spec.ts
@@ -0,0 +1,229 @@
+import { test, expect } from '@playwright/test';
+
+/**
+ * Feature 3: Control Properties
+ *
+ * Tests that users can click on device controls and set their properties
+ * in the properties editor.
+ *
+ * Requirements:
+ * 3.1.1 - User can click on a control and the corresponding control properties editor loads
+ * 3.1.2 - Control CC number in properties editor matches the control label in visual display
+ * 3.1.3 - Property values in properties editor are updated to match the model data structure
+ * 3.1.4 - When user changes control properties, the model data structure is updated accordingly
+ */
+
+test.describe('Feature 3: Control Properties', () => {
+  test.beforeEach(async ({ page }) => {
+    // Navigate to the editor page
+    await page.goto('http://localhost:8081/');
+
+    // Wait for the page to fully load
+    await expect(page.getByRole('heading', { name: 'Mode Editor' })).toBeVisible();
+  });
+
+  test('3.1.1 - should load control properties editor when clicking a control', async ({ page }) => {
+    // Initially, the properties panel should show "Select a control" message
+    await expect(page.getByText('Select a control on the device to configure its properties')).toBeVisible();
+
+    // Click on the first knob (CC 13) - using JavaScript to dispatch event
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      // Find CC 13 knob (cx=160, cy=120, r=18)
+      for (const circle of circles) {
+        if (circle.getAttribute('cx') === '160' &&
+            circle.getAttribute('cy') === '120' &&
+            circle.getAttribute('r') === '18') {
+          const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+          circle.dispatchEvent(event);
+          break;
+        }
+      }
+    });
+
+    // Control Properties panel should load with tabs
+    await expect(page.getByRole('tab', { name: 'Mapping' })).toBeVisible();
+    await expect(page.getByRole('tab', { name: 'Advanced' })).toBeVisible();
+
+    // Should show control type badge
+    await expect(page.getByText('Control Type')).toBeVisible();
+  });
+
+  test('3.1.2 - should display CC number matching the visual control label', async ({ page }) => {
+    // Test CC 13 knob
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2]; // CC 13 is at index 2
+      const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+      knob.dispatchEvent(event);
+    });
+
+    // The control type badge should show "CC 13"
+    await expect(page.locator('text=CC 13').first()).toBeVisible();
+
+    // The CC Number input should show "13"
+    const ccNumberInput = page.getByRole('spinbutton', { name: 'CC Number' });
+    await expect(ccNumberInput).toHaveValue('13');
+
+    // Test a different control - CC 53 (middle row, first knob)
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      for (const circle of circles) {
+        if (circle.getAttribute('cx') === '160' &&
+            circle.getAttribute('cy') === '200' &&
+            circle.getAttribute('r') === '18') {
+          const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+          circle.dispatchEvent(event);
+          break;
+        }
+      }
+    });
+
+    // Should now show CC 53
+    await expect(page.locator('text=CC 53').first()).toBeVisible();
+    await expect(ccNumberInput).toHaveValue('53');
+  });
+
+  test('3.1.3 - should display property values from model data structure', async ({ page }) => {
+    // Click on CC 13 knob
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2];
+      const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+      knob.dispatchEvent(event);
+    });
+
+    // Verify all default property values are displayed
+    await expect(page.getByRole('spinbutton', { name: 'CC Number' })).toHaveValue('13');
+    await expect(page.getByRole('spinbutton', { name: 'MIDI Channel' })).toHaveValue('1');
+    await expect(page.getByRole('spinbutton', { name: 'Min Value' })).toHaveValue('0');
+    await expect(page.getByRole('spinbutton', { name: 'Max Value' })).toHaveValue('127');
+  });
+
+  test('3.1.4 - should update model when changing control properties', async ({ page }) => {
+    // Click on CC 13 knob
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2];
+      const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+      knob.dispatchEvent(event);
+    });
+
+    // Change CC Number to 99
+    const ccNumberInput = page.getByRole('spinbutton', { name: 'CC Number' });
+    await ccNumberInput.fill('99');
+
+    // Verify the value changed
+    await expect(ccNumberInput).toHaveValue('99');
+
+    // Switch to a different control (CC 14)
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      for (const circle of circles) {
+        if (circle.getAttribute('cx') === '240' &&
+            circle.getAttribute('cy') === '120' &&
+            circle.getAttribute('r') === '18') {
+          const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+          circle.dispatchEvent(event);
+          break;
+        }
+      }
+    });
+
+    // Should show CC 14's default value
+    await expect(ccNumberInput).toHaveValue('14');
+
+    // Switch back to CC 13
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2];
+      const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+      knob.dispatchEvent(event);
+    });
+
+    // The changed value should persist (still 99)
+    await expect(ccNumberInput).toHaveValue('99');
+  });
+
+  test('should update all property fields and persist changes', async ({ page }) => {
+    // Click on CC 13 knob
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2];
+      const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+      knob.dispatchEvent(event);
+    });
+
+    // Change all properties
+    await page.getByRole('spinbutton', { name: 'CC Number' }).fill('77');
+    await page.getByRole('spinbutton', { name: 'MIDI Channel' }).fill('5');
+    await page.getByRole('spinbutton', { name: 'Min Value' }).fill('10');
+    await page.getByRole('spinbutton', { name: 'Max Value' }).fill('100');
+
+    // Switch to CC 14
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      for (const circle of circles) {
+        if (circle.getAttribute('cx') === '240' &&
+            circle.getAttribute('cy') === '120' &&
+            circle.getAttribute('r') === '18') {
+          const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+          circle.dispatchEvent(event);
+          break;
+        }
+      }
+    });
+
+    // Switch back to CC 13
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2];
+      const event = new MouseEvent('click', { bubbles: true, cancelable: true });
+      knob.dispatchEvent(event);
+    });
+
+    // All changes should persist
+    await expect(page.getByRole('spinbutton', { name: 'CC Number' })).toHaveValue('77');
+    await expect(page.getByRole('spinbutton', { name: 'MIDI Channel' })).toHaveValue('5');
+    await expect(page.getByRole('spinbutton', { name: 'Min Value' })).toHaveValue('10');
+    await expect(page.getByRole('spinbutton', { name: 'Max Value' })).toHaveValue('100');
+  });
+
+  test('should work with different control types (knobs, faders, buttons)', async ({ page }) => {
+    // Test a knob (CC 13)
+    await page.evaluate(() => {
+      const circles = document.querySelectorAll('svg circle');
+      const knob = circles[2];
+      knob.dispatchEvent(new MouseEvent('click', { bubbles: true }));
+    });
+    await expect(page.getByRole('spinbutton', { name: 'CC Number' })).toHaveValue('13');
+
+    // Test a fader (CC 5) - faders are rectangles
+    await page.evaluate(() => {
+      const rects = document.querySelectorAll('svg rect');
+      for (const rect of rects) {
+        if (rect.getAttribute('x') === '145' &&
+            rect.getAttribute('width') === '30' &&
+            rect.getAttribute('height') === '20') {
+          rect.dispatchEvent(new MouseEvent('click', { bubbles: true }));
+          break;
+        }
+      }
+    });
+    await expect(page.getByRole('spinbutton', { name: 'CC Number' })).toHaveValue('5');
+
+    // Test a button (CC 37)
+    await page.evaluate(() => {
+      const rects = document.querySelectorAll('svg rect');
+      for (const rect of rects) {
+        if (rect.getAttribute('x') === '135' &&
+            rect.getAttribute('y') === '510' &&
+            rect.getAttribute('width') === '50') {
+          rect.dispatchEvent(new MouseEvent('click', { bubbles: true }));
+          break;
+        }
+      }
+    });
+    await expect(page.getByRole('spinbutton', { name: 'CC Number' })).toHaveValue('37');
+  });
+});
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

feat(editor): implement control properties with click selection and persistent state updates

