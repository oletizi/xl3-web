<!-- Generated by SpecStory -->

# Profile Screen Name Feature Implementation Plan (2025-10-09 22:17:41Z)

<!-- Claude Code Session 60f67a56-f71f-4f2e-b325-df7bc2f73666 (2025-10-09_22-17-41Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/docs/1.0/profile/implementation/workplan.md b/docs/1.0/profile/implementation/workplan.md
new file mode 100644
index 0000000..620b6fb
--- /dev/null
+++ b/docs/1.0/profile/implementation/workplan.md
@@ -0,0 +1,1580 @@
+# User Profile Page with Screen Name Selection - Implementation Plan
+
+## Executive Summary
+
+This document outlines the implementation plan for a user profile page that allows users to view and change their screen names by selecting from auto-generated options. The feature builds on the existing friendly screen name system and follows the project's interface-first architecture.
+
+---
+
+## Table of Contents
+
+1. [Architecture Overview](#architecture-overview)
+2. [Database Changes](#database-changes)
+3. [Service Layer](#service-layer)
+4. [API Design](#api-design)
+5. [Component Breakdown](#component-breakdown)
+6. [User Flow & UX](#user-flow--ux)
+7. [Security Considerations](#security-considerations)
+8. [Testing Strategy](#testing-strategy)
+9. [Implementation Phases](#implementation-phases)
+10. [File Structure](#file-structure)
+11. [Success Criteria](#success-criteria)
+
+---
+
+## Architecture Overview
+
+### High-Level Design
+
+```
+┌─────────────────────────────────────────────────────────────┐
+│                      User Profile Page                       │
+│  ┌──────────────────────────────────────────────────────┐   │
+│  │  ProfileHeader (Current screen name, avatar)         │   │
+│  ├──────────────────────────────────────────────────────┤   │
+│  │  ScreenNameSelector                                  │   │
+│  │  ┌────────────────────────────────────────────────┐  │   │
+│  │  │ • Generate Options (5-10 names)                │  │   │
+│  │  │ • Select Radio Button                          │  │   │
+│  │  │ • Regenerate Button                            │  │   │
+│  │  │ • Save Button                                  │  │   │
+│  │  └────────────────────────────────────────────────┘  │   │
+│  └──────────────────────────────────────────────────────┘   │
+└─────────────────────────────────────────────────────────────┘
+                            ↓
+┌─────────────────────────────────────────────────────────────┐
+│                    React Query Hooks                         │
+│  • useUserProfile() - Fetch current profile                 │
+│  • useGenerateScreenNames() - Generate options              │
+│  • useUpdateScreenName() - Save selection                   │
+└─────────────────────────────────────────────────────────────┘
+                            ↓
+┌─────────────────────────────────────────────────────────────┐
+│                 UserProfileService (DI)                      │
+│  • getUserProfile()                                          │
+│  • generateScreenNameOptions(count)                          │
+│  • updateScreenName(newName)                                 │
+│  • validateScreenNameUnique(name)                            │
+└─────────────────────────────────────────────────────────────┘
+                            ↓
+┌─────────────────────────────────────────────────────────────┐
+│                    Supabase Database                         │
+│  • user_profiles table                                       │
+│  • generate_friendly_screenname() function                   │
+│  • RLS policies for profile updates                          │
+└─────────────────────────────────────────────────────────────┘
+```
+
+### Design Principles
+
+1. **Interface-First**: All services implement clear interfaces
+2. **Dependency Injection**: Services injected via constructors
+3. **No Fallbacks**: Throw descriptive errors instead of using mock data
+4. **Type Safety**: Comprehensive TypeScript types throughout
+5. **Optimistic Updates**: UI updates immediately, rollback on error
+6. **Single Responsibility**: Each component has one clear purpose
+
+---
+
+## Database Changes
+
+### New Database Functions
+
+#### `generate_screen_name_batch(count INTEGER)`
+
+Generate multiple unique screen name options in a single call.
+
+```sql
+-- Migration: 20251009_generate_screen_name_batch.sql
+
+CREATE OR REPLACE FUNCTION generate_screen_name_batch(count INTEGER DEFAULT 10)
+RETURNS TABLE(screen_name TEXT) AS $$
+DECLARE
+  max_attempts INT := count * 5; -- Allow up to 5x attempts
+  attempts INT := 0;
+  generated_name TEXT;
+  names TEXT[] := '{}';
+BEGIN
+  -- Generate unique screen names
+  WHILE array_length(names, 1) < count AND attempts < max_attempts LOOP
+    attempts := attempts + 1;
+    generated_name := generate_friendly_screenname();
+
+    -- Check if name is unique (not in existing profiles and not in our batch)
+    IF NOT EXISTS (
+      SELECT 1 FROM user_profiles WHERE user_profiles.screen_name = generated_name
+    ) AND NOT (generated_name = ANY(names)) THEN
+      names := array_append(names, generated_name);
+    END IF;
+  END LOOP;
+
+  -- Return the generated names
+  RETURN QUERY SELECT unnest(names);
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION generate_screen_name_batch(INTEGER) IS
+  'Generates a batch of unique friendly screen names for user selection';
+```
+
+#### `validate_screen_name_available(name TEXT)`
+
+Validate that a screen name is available for use.
+
+```sql
+-- Migration: 20251009_validate_screen_name_available.sql
+
+CREATE OR REPLACE FUNCTION validate_screen_name_available(name TEXT)
+RETURNS BOOLEAN AS $$
+BEGIN
+  RETURN NOT EXISTS (
+    SELECT 1 FROM user_profiles WHERE screen_name = name
+  );
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION validate_screen_name_available(TEXT) IS
+  'Checks if a screen name is available (not already taken)';
+```
+
+### RLS Policy Updates
+
+Add RLS policy to allow users to update their own profile:
+
+```sql
+-- Migration: 20251009_profile_update_policy.sql
+
+-- Allow users to update their own profile
+CREATE POLICY "Users can update own profile"
+  ON user_profiles
+  FOR UPDATE
+  USING (auth.uid() = id)
+  WITH CHECK (auth.uid() = id);
+
+-- Allow users to read their own profile
+CREATE POLICY "Users can read own profile"
+  ON user_profiles
+  FOR SELECT
+  USING (auth.uid() = id);
+```
+
+---
+
+## Service Layer
+
+### UserProfileService Interface
+
+```typescript
+// src/services/user-profile-service.ts
+
+/**
+ * User profile data
+ */
+export interface UserProfile {
+  id: string;
+  screenName: string;
+  avatarUrl?: string;
+  createdAt: string;
+  modifiedAt: string;
+}
+
+/**
+ * Database row type (snake_case)
+ */
+interface UserProfileRow {
+  id: string;
+  screen_name: string;
+  avatar_url: string | null;
+  created_at: string;
+  modified_at: string;
+}
+
+/**
+ * Interface for user profile operations
+ */
+export interface IUserProfileService {
+  /**
+   * Get the current user's profile
+   */
+  getUserProfile(): Promise<UserProfile>;
+
+  /**
+   * Generate multiple screen name options
+   *
+   * @param count Number of options to generate (default: 10)
+   * @returns Array of available screen names
+   */
+  generateScreenNameOptions(count?: number): Promise<string[]>;
+
+  /**
+   * Update the user's screen name
+   *
+   * @param newScreenName The new screen name to set
+   * @throws Error if screen name is already taken
+   */
+  updateScreenName(newScreenName: string): Promise<UserProfile>;
+
+  /**
+   * Validate that a screen name is available
+   *
+   * @param screenName Screen name to validate
+   * @returns true if available, false if taken
+   */
+  validateScreenNameAvailable(screenName: string): Promise<boolean>;
+}
+```
+
+### UserProfileService Implementation
+
+```typescript
+// src/services/user-profile-service.ts
+
+import { SupabaseClient } from '@supabase/supabase-js';
+
+/**
+ * UserProfileService implementation using Supabase
+ */
+export class UserProfileService implements IUserProfileService {
+  private readonly supabase: SupabaseClient;
+
+  constructor(supabase: SupabaseClient) {
+    this.supabase = supabase;
+  }
+
+  /**
+   * Get current user ID from session
+   */
+  private async getCurrentUserId(): Promise<string> {
+    const { data: { user }, error } = await this.supabase.auth.getUser();
+
+    if (error || !user) {
+      throw new Error('User not authenticated. Please sign in to access profile.');
+    }
+
+    return user.id;
+  }
+
+  /**
+   * Convert database row to UserProfile
+   */
+  private toUserProfile(row: UserProfileRow): UserProfile {
+    return {
+      id: row.id,
+      screenName: row.screen_name,
+      avatarUrl: row.avatar_url || undefined,
+      createdAt: row.created_at,
+      modifiedAt: row.modified_at,
+    };
+  }
+
+  async getUserProfile(): Promise<UserProfile> {
+    const userId = await this.getCurrentUserId();
+
+    const { data, error } = await this.supabase
+      .from('user_profiles')
+      .select('*')
+      .eq('id', userId)
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to fetch user profile: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('User profile not found. Profile should exist for authenticated users.');
+    }
+
+    return this.toUserProfile(data as UserProfileRow);
+  }
+
+  async generateScreenNameOptions(count: number = 10): Promise<string[]> {
+    const { data, error } = await this.supabase
+      .rpc('generate_screen_name_batch', { count });
+
+    if (error) {
+      throw new Error(`Failed to generate screen name options: ${error.message}`);
+    }
+
+    if (!data || data.length === 0) {
+      throw new Error('Failed to generate screen name options. Please try again.');
+    }
+
+    return data.map((row: { screen_name: string }) => row.screen_name);
+  }
+
+  async updateScreenName(newScreenName: string): Promise<UserProfile> {
+    const userId = await this.getCurrentUserId();
+
+    // Validate screen name is available
+    const isAvailable = await this.validateScreenNameAvailable(newScreenName);
+    if (!isAvailable) {
+      throw new Error(`Screen name "${newScreenName}" is already taken. Please choose another.`);
+    }
+
+    const { data, error } = await this.supabase
+      .from('user_profiles')
+      .update({ screen_name: newScreenName })
+      .eq('id', userId)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to update screen name: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('Failed to update screen name. No data returned from database.');
+    }
+
+    return this.toUserProfile(data as UserProfileRow);
+  }
+
+  async validateScreenNameAvailable(screenName: string): Promise<boolean> {
+    const { data, error } = await this.supabase
+      .rpc('validate_screen_name_available', { name: screenName });
+
+    if (error) {
+      throw new Error(`Failed to validate screen name: ${error.message}`);
+    }
+
+    return data === true;
+  }
+}
+
+/**
+ * Factory function to create UserProfileService
+ */
+export function createUserProfileService(supabase: SupabaseClient): IUserProfileService {
+  return new UserProfileService(supabase);
+}
+```
+
+---
+
+## API Design
+
+### React Query Hooks
+
+```typescript
+// src/hooks/use-user-profile.ts
+
+import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
+import { useSupabase } from '@/hooks/use-supabase';
+import { createUserProfileService, UserProfile } from '@/services/user-profile-service';
+import { toast } from '@/components/ui/sonner';
+
+/**
+ * Query keys for user profile queries
+ */
+export const userProfileKeys = {
+  all: ['userProfile'] as const,
+  profile: () => [...userProfileKeys.all, 'current'] as const,
+  screenNameOptions: () => [...userProfileKeys.all, 'screenNameOptions'] as const,
+};
+
+/**
+ * Hook to fetch current user profile
+ */
+export function useUserProfile() {
+  const supabase = useSupabase();
+  const service = createUserProfileService(supabase);
+
+  return useQuery({
+    queryKey: userProfileKeys.profile(),
+    queryFn: () => service.getUserProfile(),
+    staleTime: 5 * 60 * 1000, // 5 minutes
+  });
+}
+
+/**
+ * Hook to generate screen name options
+ */
+export function useGenerateScreenNames(count: number = 10) {
+  const supabase = useSupabase();
+  const service = createUserProfileService(supabase);
+
+  return useQuery({
+    queryKey: [...userProfileKeys.screenNameOptions(), count],
+    queryFn: () => service.generateScreenNameOptions(count),
+    staleTime: 0, // Always fetch fresh names
+    gcTime: 0, // Don't cache
+  });
+}
+
+/**
+ * Hook to update screen name with optimistic updates
+ */
+export function useUpdateScreenName() {
+  const supabase = useSupabase();
+  const service = createUserProfileService(supabase);
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: (newScreenName: string) => service.updateScreenName(newScreenName),
+
+    // Optimistic update
+    onMutate: async (newScreenName: string) => {
+      // Cancel outgoing refetches
+      await queryClient.cancelQueries({ queryKey: userProfileKeys.profile() });
+
+      // Snapshot previous value
+      const previousProfile = queryClient.getQueryData<UserProfile>(
+        userProfileKeys.profile()
+      );
+
+      // Optimistically update
+      if (previousProfile) {
+        queryClient.setQueryData<UserProfile>(
+          userProfileKeys.profile(),
+          {
+            ...previousProfile,
+            screenName: newScreenName,
+          }
+        );
+      }
+
+      return { previousProfile };
+    },
+
+    // Rollback on error
+    onError: (error, newScreenName, context) => {
+      if (context?.previousProfile) {
+        queryClient.setQueryData(
+          userProfileKeys.profile(),
+          context.previousProfile
+        );
+      }
+
+      toast.error('Failed to Update Screen Name', {
+        description: error instanceof Error ? error.message : 'Unknown error occurred',
+      });
+    },
+
+    // Success
+    onSuccess: (updatedProfile) => {
+      queryClient.setQueryData(
+        userProfileKeys.profile(),
+        updatedProfile
+      );
+
+      toast.success('Screen Name Updated', {
+        description: `Your screen name is now "${updatedProfile.screenName}"`,
+      });
+    },
+
+    // Always refetch after error or success
+    onSettled: () => {
+      queryClient.invalidateQueries({ queryKey: userProfileKeys.profile() });
+    },
+  });
+}
+
+/**
+ * Hook to validate screen name availability
+ */
+export function useValidateScreenName() {
+  const supabase = useSupabase();
+  const service = createUserProfileService(supabase);
+
+  return useMutation({
+    mutationFn: (screenName: string) => service.validateScreenNameAvailable(screenName),
+  });
+}
+```
+
+---
+
+## Component Breakdown
+
+### 1. Profile Page (`src/pages/Profile.tsx`)
+
+**Responsibility**: Top-level page container
+
+**Props**: None (uses routing)
+
+**Features**:
+- Layout with header and navigation
+- Profile header section
+- Screen name selector section
+- Loading and error states
+
+```typescript
+export function Profile(): React.ReactElement {
+  const { data: profile, isLoading, error } = useUserProfile();
+
+  if (isLoading) {
+    return <ProfileSkeleton />;
+  }
+
+  if (error) {
+    return <ProfileError error={error} />;
+  }
+
+  if (!profile) {
+    return <ProfileError error={new Error('Profile not found')} />;
+  }
+
+  return (
+    <div className="container mx-auto p-6 max-w-4xl">
+      <ProfileHeader profile={profile} />
+      <Separator className="my-6" />
+      <ScreenNameSection profile={profile} />
+    </div>
+  );
+}
+```
+
+### 2. ProfileHeader (`src/components/profile/ProfileHeader.tsx`)
+
+**Responsibility**: Display user's current profile information
+
+**Props**:
+```typescript
+interface ProfileHeaderProps {
+  profile: UserProfile;
+}
+```
+
+**Features**:
+- Avatar display (or initials if no avatar)
+- Current screen name
+- Join date
+- Profile statistics (optional future enhancement)
+
+### 3. ScreenNameSection (`src/components/profile/ScreenNameSection.tsx`)
+
+**Responsibility**: Orchestrate screen name selection flow
+
+**Props**:
+```typescript
+interface ScreenNameSectionProps {
+  profile: UserProfile;
+}
+```
+
+**Features**:
+- Title and description
+- ScreenNamePicker component
+- Save button with loading state
+- Cancel button to revert changes
+
+### 4. ScreenNamePicker (`src/components/profile/ScreenNamePicker.tsx`)
+
+**Responsibility**: Generate and display screen name options
+
+**Props**:
+```typescript
+interface ScreenNamePickerProps {
+  currentScreenName: string;
+  onSelect: (screenName: string) => void;
+  selectedScreenName?: string;
+}
+```
+
+**Features**:
+- Generate initial 10 options on mount
+- Radio group for selection
+- Regenerate button (fetches new batch)
+- Loading states during generation
+- Visual indication of current name if in list
+
+```typescript
+export function ScreenNamePicker({
+  currentScreenName,
+  onSelect,
+  selectedScreenName,
+}: ScreenNamePickerProps): React.ReactElement {
+  const [optionCount] = React.useState(10);
+  const { data: options, isLoading, refetch, isFetching } = useGenerateScreenNames(optionCount);
+
+  const handleRegenerate = () => {
+    refetch();
+  };
+
+  return (
+    <Card>
+      <CardHeader>
+        <CardTitle>Choose a Screen Name</CardTitle>
+        <CardDescription>
+          Select a friendly screen name from the options below
+        </CardDescription>
+      </CardHeader>
+      <CardContent>
+        {isLoading ? (
+          <ScreenNameOptionsSkeleton count={optionCount} />
+        ) : options ? (
+          <RadioGroup value={selectedScreenName} onValueChange={onSelect}>
+            {options.map((name) => (
+              <div key={name} className="flex items-center space-x-2">
+                <RadioGroupItem value={name} id={name} />
+                <Label htmlFor={name} className="flex-1 cursor-pointer">
+                  {name}
+                  {name === currentScreenName && (
+                    <Badge variant="secondary" className="ml-2">
+                      Current
+                    </Badge>
+                  )}
+                </Label>
+              </div>
+            ))}
+          </RadioGroup>
+        ) : (
+          <div className="text-center text-muted-foreground">
+            Failed to generate options
+          </div>
+        )}
+      </CardContent>
+      <CardFooter>
+        <Button
+          variant="outline"
+          onClick={handleRegenerate}
+          disabled={isFetching}
+        >
+          {isFetching ? (
+            <>
+              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+              Generating...
+            </>
+          ) : (
+            <>
+              <RefreshCw className="mr-2 h-4 w-4" />
+              Regenerate Options
+            </>
+          )}
+        </Button>
+      </CardFooter>
+    </Card>
+  );
+}
+```
+
+### 5. ProfileSkeleton (`src/components/profile/ProfileSkeleton.tsx`)
+
+**Responsibility**: Loading state placeholder
+
+**Features**:
+- Shimmer effect
+- Matches layout of Profile page
+
+### 6. ProfileError (`src/components/profile/ProfileError.tsx`)
+
+**Responsibility**: Error state display
+
+**Props**:
+```typescript
+interface ProfileErrorProps {
+  error: Error;
+}
+```
+
+**Features**:
+- Error message display
+- Retry button
+- Navigation back to home
+
+---
+
+## User Flow & UX
+
+### Happy Path Flow
+
+```
+1. User clicks "Profile" in navigation
+   ↓
+2. Profile page loads with current screen name
+   ↓
+3. User sees "Choose a Screen Name" section
+   ↓
+4. 10 screen name options are auto-generated and displayed
+   ↓
+5. User clicks radio button to select a new name
+   ↓
+6. "Save" button becomes enabled
+   ↓
+7. User clicks "Save"
+   ↓
+8. Optimistic update: UI shows new name immediately
+   ↓
+9. API request completes successfully
+   ↓
+10. Success toast: "Screen name updated!"
+   ↓
+11. Profile displays new screen name
+```
+
+### Alternative Flows
+
+#### Regenerate Options
+```
+1. User views initial 10 options
+   ↓
+2. User doesn't like any options
+   ↓
+3. User clicks "Regenerate Options"
+   ↓
+4. Button shows loading state
+   ↓
+5. New batch of 10 options appears
+   ↓
+6. Previous selection is cleared
+```
+
+#### Screen Name Taken (Edge Case)
+```
+1. User selects name "happy-panda-42"
+   ↓
+2. Another user takes that name before save
+   ↓
+3. User clicks "Save"
+   ↓
+4. API returns error: "Screen name already taken"
+   ↓
+5. Optimistic update rolls back
+   ↓
+6. Error toast displays
+   ↓
+7. User can select different name or regenerate
+```
+
+#### Cancel Changes
+```
+1. User selects new name
+   ↓
+2. User clicks "Cancel"
+   ↓
+3. Selection is cleared
+   ↓
+4. No API call made
+```
+
+### UX Considerations
+
+1. **Immediate Feedback**: Optimistic updates make the UI feel instant
+2. **Clear Selection State**: Radio buttons with labels, current name badged
+3. **Loading States**: Skeletons and spinners during async operations
+4. **Error Recovery**: Clear error messages with actionable next steps
+5. **Accessibility**: Keyboard navigation, screen reader support, ARIA labels
+6. **Mobile Responsive**: Stack layout on small screens
+7. **Visual Hierarchy**: Clear sections with cards and separators
+
+---
+
+## Security Considerations
+
+### Row Level Security (RLS)
+
+All database operations must respect RLS policies:
+
+```sql
+-- Users can only read their own profile
+CREATE POLICY "Users can read own profile"
+  ON user_profiles
+  FOR SELECT
+  USING (auth.uid() = id);
+
+-- Users can only update their own profile
+CREATE POLICY "Users can update own profile"
+  ON user_profiles
+  FOR UPDATE
+  USING (auth.uid() = id)
+  WITH CHECK (auth.uid() = id);
+```
+
+### Validation Requirements
+
+1. **Server-Side Validation**:
+   - Screen name uniqueness check before update
+   - Screen name format validation (matches pattern)
+   - Rate limiting on screen name changes (optional future)
+
+2. **Client-Side Validation**:
+   - Non-empty selection
+   - Selection from generated options only
+   - Disable save if no changes
+
+3. **Authentication**:
+   - All API calls require authenticated user
+   - Service layer validates auth.uid() matches profile.id
+
+### Attack Vectors to Prevent
+
+1. **Race Conditions**: Two users selecting same name
+   - Mitigation: Database uniqueness constraint + validation before update
+
+2. **Enumeration**: Guessing valid screen names
+   - Mitigation: Only allow selection from generated options
+
+3. **Spam**: Rapid screen name changes
+   - Mitigation: (Future) Rate limit updates per user per day
+
+4. **SQL Injection**: Malicious input in screen name
+   - Mitigation: Parameterized queries (Supabase handles this)
+
+---
+
+## Testing Strategy
+
+### Unit Tests
+
+#### Service Layer Tests
+
+```typescript
+// src/services/user-profile-service.test.ts
+
+describe('UserProfileService', () => {
+  let service: UserProfileService;
+  let mockSupabase: jest.Mocked<SupabaseClient>;
+
+  beforeEach(() => {
+    mockSupabase = createMockSupabaseClient();
+    service = new UserProfileService(mockSupabase);
+  });
+
+  describe('getUserProfile', () => {
+    it('should fetch user profile successfully', async () => {
+      const mockProfile = {
+        id: 'user-123',
+        screen_name: 'happy-panda-42',
+        avatar_url: null,
+        created_at: '2025-01-01T00:00:00Z',
+        modified_at: '2025-01-01T00:00:00Z',
+      };
+
+      mockSupabase.from.mockReturnValue({
+        select: jest.fn().mockReturnValue({
+          eq: jest.fn().mockReturnValue({
+            single: jest.fn().mockResolvedValue({ data: mockProfile, error: null }),
+          }),
+        }),
+      });
+
+      const result = await service.getUserProfile();
+
+      expect(result).toEqual({
+        id: 'user-123',
+        screenName: 'happy-panda-42',
+        avatarUrl: undefined,
+        createdAt: '2025-01-01T00:00:00Z',
+        modifiedAt: '2025-01-01T00:00:00Z',
+      });
+    });
+
+    it('should throw error when user not authenticated', async () => {
+      mockSupabase.auth.getUser.mockResolvedValue({
+        data: { user: null },
+        error: new Error('Not authenticated'),
+      });
+
+      await expect(service.getUserProfile()).rejects.toThrow(
+        'User not authenticated'
+      );
+    });
+  });
+
+  describe('generateScreenNameOptions', () => {
+    it('should generate 10 screen names by default', async () => {
+      const mockNames = Array.from({ length: 10 }, (_, i) => ({
+        screen_name: `test-name-${i}`,
+      }));
+
+      mockSupabase.rpc.mockResolvedValue({ data: mockNames, error: null });
+
+      const result = await service.generateScreenNameOptions();
+
+      expect(result).toHaveLength(10);
+      expect(mockSupabase.rpc).toHaveBeenCalledWith('generate_screen_name_batch', {
+        count: 10,
+      });
+    });
+
+    it('should throw error when generation fails', async () => {
+      mockSupabase.rpc.mockResolvedValue({
+        data: null,
+        error: new Error('Generation failed'),
+      });
+
+      await expect(service.generateScreenNameOptions()).rejects.toThrow(
+        'Failed to generate screen name options'
+      );
+    });
+  });
+
+  describe('updateScreenName', () => {
+    it('should update screen name when available', async () => {
+      // Mock availability check
+      mockSupabase.rpc.mockResolvedValueOnce({ data: true, error: null });
+
+      // Mock update
+      const updatedProfile = {
+        id: 'user-123',
+        screen_name: 'cool-cat-99',
+        avatar_url: null,
+        created_at: '2025-01-01T00:00:00Z',
+        modified_at: '2025-01-02T00:00:00Z',
+      };
+
+      mockSupabase.from.mockReturnValue({
+        update: jest.fn().mockReturnValue({
+          eq: jest.fn().mockReturnValue({
+            select: jest.fn().mockReturnValue({
+              single: jest.fn().mockResolvedValue({ data: updatedProfile, error: null }),
+            }),
+          }),
+        }),
+      });
+
+      const result = await service.updateScreenName('cool-cat-99');
+
+      expect(result.screenName).toBe('cool-cat-99');
+    });
+
+    it('should throw error when name is taken', async () => {
+      // Mock availability check returning false
+      mockSupabase.rpc.mockResolvedValue({ data: false, error: null });
+
+      await expect(service.updateScreenName('taken-name-123')).rejects.toThrow(
+        'Screen name "taken-name-123" is already taken'
+      );
+    });
+  });
+});
+```
+
+#### Hook Tests
+
+```typescript
+// src/hooks/use-user-profile.test.tsx
+
+import { renderHook, waitFor } from '@testing-library/react';
+import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
+import { useUserProfile, useUpdateScreenName } from './use-user-profile';
+
+const createWrapper = () => {
+  const queryClient = new QueryClient({
+    defaultOptions: { queries: { retry: false } },
+  });
+  return ({ children }: { children: React.ReactNode }) => (
+    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
+  );
+};
+
+describe('useUserProfile', () => {
+  it('should fetch user profile', async () => {
+    const { result } = renderHook(() => useUserProfile(), {
+      wrapper: createWrapper(),
+    });
+
+    await waitFor(() => expect(result.current.isSuccess).toBe(true));
+
+    expect(result.current.data).toBeDefined();
+    expect(result.current.data?.screenName).toBeTruthy();
+  });
+});
+
+describe('useUpdateScreenName', () => {
+  it('should update screen name optimistically', async () => {
+    const { result: profileResult } = renderHook(() => useUserProfile(), {
+      wrapper: createWrapper(),
+    });
+
+    await waitFor(() => expect(profileResult.current.isSuccess).toBe(true));
+
+    const originalName = profileResult.current.data?.screenName;
+
+    const { result: mutationResult } = renderHook(() => useUpdateScreenName(), {
+      wrapper: createWrapper(),
+    });
+
+    mutationResult.current.mutate('new-name-123');
+
+    await waitFor(() => expect(mutationResult.current.isSuccess).toBe(true));
+
+    expect(profileResult.current.data?.screenName).toBe('new-name-123');
+    expect(originalName).not.toBe('new-name-123');
+  });
+});
+```
+
+### Component Tests
+
+```typescript
+// src/components/profile/ScreenNamePicker.test.tsx
+
+import { render, screen, fireEvent } from '@testing-library/react';
+import { ScreenNamePicker } from './ScreenNamePicker';
+
+describe('ScreenNamePicker', () => {
+  const mockOnSelect = jest.fn();
+
+  beforeEach(() => {
+    mockOnSelect.mockClear();
+  });
+
+  it('should display generated screen name options', async () => {
+    render(
+      <ScreenNamePicker
+        currentScreenName="old-name-42"
+        onSelect={mockOnSelect}
+      />
+    );
+
+    // Wait for options to load
+    const options = await screen.findAllByRole('radio');
+    expect(options).toHaveLength(10);
+  });
+
+  it('should call onSelect when option is clicked', async () => {
+    render(
+      <ScreenNamePicker
+        currentScreenName="old-name-42"
+        onSelect={mockOnSelect}
+      />
+    );
+
+    const firstOption = await screen.findByRole('radio', { name: /test-name-0/i });
+    fireEvent.click(firstOption);
+
+    expect(mockOnSelect).toHaveBeenCalledWith('test-name-0');
+  });
+
+  it('should regenerate options when button clicked', async () => {
+    render(
+      <ScreenNamePicker
+        currentScreenName="old-name-42"
+        onSelect={mockOnSelect}
+      />
+    );
+
+    const regenerateButton = screen.getByText(/regenerate/i);
+    fireEvent.click(regenerateButton);
+
+    // Should show loading state
+    expect(screen.getByText(/generating/i)).toBeInTheDocument();
+  });
+
+  it('should badge current screen name if in list', async () => {
+    render(
+      <ScreenNamePicker
+        currentScreenName="happy-panda-42"
+        onSelect={mockOnSelect}
+      />
+    );
+
+    // Mock one of the options to be the current name
+    const currentBadge = await screen.findByText(/current/i);
+    expect(currentBadge).toBeInTheDocument();
+  });
+});
+```
+
+### Integration Tests
+
+```typescript
+// e2e/profile.spec.ts (Playwright)
+
+import { test, expect } from '@playwright/test';
+
+test.describe('Profile Page', () => {
+  test.beforeEach(async ({ page }) => {
+    // Login as test user
+    await page.goto('/login');
+    await page.fill('[name="email"]', 'test@example.com');
+    await page.fill('[name="password"]', 'password123');
+    await page.click('button[type="submit"]');
+    await page.waitForURL('/');
+  });
+
+  test('should display current screen name', async ({ page }) => {
+    await page.goto('/profile');
+
+    const screenName = await page.textContent('[data-testid="current-screen-name"]');
+    expect(screenName).toBeTruthy();
+  });
+
+  test('should change screen name successfully', async ({ page }) => {
+    await page.goto('/profile');
+
+    // Wait for options to load
+    await page.waitForSelector('[role="radio"]');
+
+    // Select first option
+    const firstOption = page.locator('[role="radio"]').first();
+    await firstOption.click();
+
+    // Click save
+    await page.click('button:has-text("Save")');
+
+    // Should see success toast
+    await expect(page.locator('.sonner-toast')).toContainText('Screen Name Updated');
+
+    // Screen name should update in UI
+    const newName = await firstOption.getAttribute('value');
+    const displayedName = await page.textContent('[data-testid="current-screen-name"]');
+    expect(displayedName).toBe(newName);
+  });
+
+  test('should regenerate screen name options', async ({ page }) => {
+    await page.goto('/profile');
+
+    // Get first option text
+    const firstOption = page.locator('[role="radio"]').first();
+    const originalText = await firstOption.getAttribute('value');
+
+    // Click regenerate
+    await page.click('button:has-text("Regenerate")');
+
+    // Wait for new options
+    await page.waitForTimeout(500);
+
+    // First option should be different
+    const newText = await firstOption.getAttribute('value');
+    expect(newText).not.toBe(originalText);
+  });
+});
+```
+
+### Test Coverage Goals
+
+- **Service Layer**: 90%+ coverage
+- **Hooks**: 85%+ coverage
+- **Components**: 80%+ coverage
+- **E2E Critical Paths**: 100% coverage
+
+---
+
+## Implementation Phases
+
+### Phase 1: Foundation (Week 1)
+
+**Goals**: Database + Service Layer + Types
+
+**Tasks**:
+1. ✅ Create database migration for `generate_screen_name_batch()`
+2. ✅ Create database migration for `validate_screen_name_available()`
+3. ✅ Add RLS policies for profile updates
+4. ✅ Create `UserProfile` type definitions
+5. ✅ Implement `IUserProfileService` interface
+6. ✅ Implement `UserProfileService` class
+7. ✅ Write unit tests for service layer
+8. ✅ Test database functions manually via SQL
+
+**Deliverables**:
+- Migration files in `supabase/migrations/`
+- Service implementation in `src/services/user-profile-service.ts`
+- Service tests in `src/services/user-profile-service.test.ts`
+- 90%+ test coverage for service layer
+
+**Success Criteria**:
+- All migrations apply cleanly
+- RLS policies enforce user access
+- Service layer passes all tests
+- TypeScript compilation succeeds with no errors
+
+---
+
+### Phase 2: API Layer (Week 1-2)
+
+**Goals**: React Query Hooks + API Integration
+
+**Tasks**:
+1. ✅ Create `useUserProfile()` hook
+2. ✅ Create `useGenerateScreenNames()` hook
+3. ✅ Create `useUpdateScreenName()` hook with optimistic updates
+4. ✅ Create `useValidateScreenName()` hook (optional, for future)
+5. ✅ Implement query key structure
+6. ✅ Configure cache policies (stale times, GC)
+7. ✅ Write hook tests
+8. ✅ Test optimistic update rollback scenarios
+
+**Deliverables**:
+- Hooks in `src/hooks/use-user-profile.ts`
+- Hook tests in `src/hooks/use-user-profile.test.tsx`
+- 85%+ test coverage for hooks
+
+**Success Criteria**:
+- Hooks integrate with service layer correctly
+- Optimistic updates work and rollback on error
+- Cache invalidation happens appropriately
+- All hook tests pass
+
+---
+
+### Phase 3: UI Components (Week 2)
+
+**Goals**: Build Profile Page Components
+
+**Tasks**:
+1. ✅ Create Profile page route in `src/pages/Profile.tsx`
+2. ✅ Create `ProfileHeader` component
+3. ✅ Create `ScreenNameSection` component
+4. ✅ Create `ScreenNamePicker` component
+5. ✅ Create `ProfileSkeleton` component
+6. ✅ Create `ProfileError` component
+7. ✅ Add Profile link to navigation
+8. ✅ Write component tests
+9. ✅ Implement responsive design (mobile/tablet/desktop)
+
+**Deliverables**:
+- Profile page in `src/pages/Profile.tsx`
+- Components in `src/components/profile/`
+- Component tests in `src/components/profile/*.test.tsx`
+- 80%+ test coverage for components
+
+**Success Criteria**:
+- Profile page renders correctly
+- All components responsive
+- Loading and error states work
+- Component tests pass
+
+---
+
+### Phase 4: Integration & Polish (Week 2-3)
+
+**Goals**: E2E Testing + UX Refinements
+
+**Tasks**:
+1. ✅ Write Playwright E2E tests for critical flows
+2. ✅ Manual QA testing on staging environment
+3. ✅ Accessibility audit (keyboard nav, screen readers)
+4. ✅ Performance testing (load times, interaction delays)
+5. ✅ Error handling review (all error paths tested)
+6. ✅ UI polish (animations, transitions, micro-interactions)
+7. ✅ Documentation updates (user guide, API docs)
+8. ✅ Code review with team
+9. ✅ Security audit (RLS, validation, auth)
+
+**Deliverables**:
+- E2E tests in `e2e/profile.spec.ts`
+- User documentation in `docs/1.0/profile/user-guide.md`
+- Security audit report in `docs/1.0/profile/security-audit.md`
+- Performance metrics document
+
+**Success Criteria**:
+- All E2E tests pass
+- Accessibility score 100% (Lighthouse)
+- Performance score 90+ (Lighthouse)
+- Zero security vulnerabilities identified
+- Code review approved by 2+ engineers
+
+---
+
+### Phase 5: Deployment (Week 3)
+
+**Goals**: Production Deployment
+
+**Tasks**:
+1. ✅ Deploy migrations to staging
+2. ✅ Deploy application to staging
+3. ✅ Staging smoke tests
+4. ✅ Load testing on staging
+5. ✅ Create deployment runbook
+6. ✅ Deploy migrations to production
+7. ✅ Deploy application to production
+8. ✅ Production smoke tests
+9. ✅ Monitor error rates and performance
+10. ✅ Announce feature to users
+
+**Deliverables**:
+- Deployment runbook in `docs/1.0/profile/deployment.md`
+- Rollback plan in case of issues
+- Monitoring dashboard with alerts
+- Release notes for users
+
+**Success Criteria**:
+- Zero downtime deployment
+- No increase in error rates
+- Page load time < 2 seconds (p95)
+- Positive user feedback
+
+---
+
+## File Structure
+
+```
+xl3-web/
+├── docs/
+│   └── 1.0/
+│       └── profile/
+│           ├── implementation/
+│           │   └── workplan.md (this file)
+│           ├── user-guide.md
+│           ├── security-audit.md
+│           └── deployment.md
+│
+├── supabase/
+│   └── migrations/
+│       ├── 20251009_generate_screen_name_batch.sql (NEW)
+│       ├── 20251009_validate_screen_name_available.sql (NEW)
+│       └── 20251009_profile_update_policy.sql (NEW)
+│
+├── src/
+│   ├── services/
+│   │   ├── user-profile-service.ts (NEW)
+│   │   └── user-profile-service.test.ts (NEW)
+│   │
+│   ├── hooks/
+│   │   ├── use-user-profile.ts (NEW)
+│   │   └── use-user-profile.test.tsx (NEW)
+│   │
+│   ├── types/
+│   │   └── user-profile.ts (NEW - if types are separate)
+│   │
+│   ├── pages/
+│   │   └── Profile.tsx (NEW)
+│   │
+│   ├── components/
+│   │   └── profile/ (NEW)
+│   │       ├── ProfileHeader.tsx
+│   │       ├── ProfileHeader.test.tsx
+│   │       ├── ScreenNameSection.tsx
+│   │       ├── ScreenNameSection.test.tsx
+│   │       ├── ScreenNamePicker.tsx
+│   │       ├── ScreenNamePicker.test.tsx
+│   │       ├── ProfileSkeleton.tsx
+│   │       ├── ProfileError.tsx
+│   │       └── index.ts (barrel export)
+│   │
+│   └── routes/ (or wherever routing is configured)
+│       └── index.tsx (MODIFY - add /profile route)
+│
+└── e2e/
+    └── profile.spec.ts (NEW)
+```
+
+### Files to Create
+
+**New Files**:
+- 3 database migrations
+- 2 service files (implementation + tests)
+- 2 hook files (implementation + tests)
+- 1 page file
+- 8 component files (6 components + 2 test files)
+- 1 E2E test file
+- 4 documentation files
+
+**Total**: ~21 new files
+
+**Modified Files**:
+- Routing configuration (add `/profile` route)
+- Navigation component (add "Profile" link)
+- Main layout (if needed for navigation)
+
+**Total**: ~3 modified files
+
+---
+
+## Success Criteria
+
+### Functional Requirements
+
+✅ Users can view their current screen name on profile page
+✅ Users can generate 10 screen name options
+✅ Users can regenerate options unlimited times
+✅ Users can select one option from the list
+✅ Users can save their selection and update their profile
+✅ Screen name updates are reflected immediately (optimistic update)
+✅ Error handling for taken screen names works correctly
+✅ Loading states display appropriately during async operations
+
+### Non-Functional Requirements
+
+✅ **Performance**: Profile page loads in < 2 seconds (p95)
+✅ **Performance**: Screen name generation takes < 500ms (p95)
+✅ **Accessibility**: WCAG 2.1 AA compliant
+✅ **Accessibility**: Full keyboard navigation support
+✅ **Accessibility**: Screen reader tested and functional
+✅ **Security**: RLS policies prevent unauthorized access
+✅ **Security**: All inputs validated server-side
+✅ **Testing**: 85%+ code coverage across all layers
+✅ **Testing**: All critical paths covered by E2E tests
+✅ **Mobile**: Responsive design works on all screen sizes
+✅ **UX**: Optimistic updates make UI feel instant
+✅ **UX**: Clear error messages guide users to resolution
+
+### Quality Gates
+
+Before merging to main branch:
+
+- [ ] All unit tests passing (100%)
+- [ ] All E2E tests passing (100%)
+- [ ] Code coverage meets targets (85%+)
+- [ ] TypeScript compilation successful with no errors
+- [ ] Linting passes with no errors
+- [ ] Code reviewed and approved by 2+ engineers
+- [ ] Security audit completed with no high/critical issues
+- [ ] Accessibility audit completed with 100% score
+- [ ] Performance benchmarks met (page load < 2s)
+- [ ] Manual QA sign-off on staging environment
+- [ ] Documentation complete and reviewed
+- [ ] Deployment runbook tested on staging
+
+---
+
+## Risk Mitigation
+
+### Identified Risks
+
+| Risk | Impact | Probability | Mitigation |
+|------|--------|-------------|------------|
+| Race condition: two users select same name | High | Low | Database uniqueness constraint + validation before update |
+| Screen name generation fails to produce unique names | Medium | Low | Batch generation with retry logic, fallback to UUID suffix |
+| Optimistic update causes UI inconsistency | Medium | Low | Rollback on error, refetch after success |
+| Performance degradation with large user base | Medium | Medium | Index on screen_name column, cache query results |
+| User changes screen name too frequently | Low | Medium | (Future) Rate limit updates per user per day |
+| Accessibility issues block users | High | Low | Comprehensive accessibility testing before launch |
+
+### Rollback Plan
+
+If critical issues occur in production:
+
+1. **Immediate Rollback**:
+   - Revert application deployment to previous version
+   - Keep database migrations in place (they don't break existing functionality)
+   - Monitor error rates return to baseline
+
+2. **Partial Rollback**:
+   - Hide "Profile" link from navigation via feature flag
+   - Keep backend functionality intact
+   - Investigate and fix issues in staging
+
+3. **Data Integrity**:
+   - No data loss risk (only adding new functionality)
+   - Existing screen names remain unchanged
+   - New screen names can be manually corrected if needed
+
+---
+
+## Future Enhancements
+
+Features to consider after v1.0:
+
+1. **Custom Screen Names**: Allow users to type their own name (with validation)
+2. **Avatar Upload**: Add avatar image upload and cropping
+3. **Profile Statistics**: Display user activity metrics (modes created, likes, etc.)
+4. **Profile Visibility**: Toggle profile visibility to other users
+5. **Screen Name History**: Track screen name changes for moderation
+6. **Rate Limiting**: Limit screen name changes to once per week
+7. **Premium Names**: Offer curated/premium screen names for paid users
+8. **Name Reservation**: Allow users to reserve a name before changing
+9. **Social Links**: Add fields for GitHub, Twitter, website, etc.
+10. **Profile Badges**: Display achievement badges on profile
+
+---
+
+## Appendix
+
+### Database Schema
+
+```sql
+-- user_profiles table (existing)
+CREATE TABLE user_profiles (
+  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
+  screen_name TEXT UNIQUE NOT NULL,
+  avatar_url TEXT,
+  created_at TIMESTAMPTZ DEFAULT NOW(),
+  modified_at TIMESTAMPTZ DEFAULT NOW()
+);
+
+-- Indexes
+CREATE UNIQUE INDEX idx_user_profiles_screen_name ON user_profiles(screen_name);
+CREATE INDEX idx_user_profiles_created_at ON user_profiles(created_at DESC);
+
+-- RLS Policies
+ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
+
+CREATE POLICY "Users can read own profile"
+  ON user_profiles FOR SELECT
+  USING (auth.uid() = id);
+
+CREATE POLICY "Users can update own profile"
+  ON user_profiles FOR UPDATE
+  USING (auth.uid() = id)
+  WITH CHECK (auth.uid() = id);
+```
+
+### API Reference
+
+#### `GET /profile`
+Returns current user's profile
+
+**Response**:
+```json
+{
+  "id": "user-uuid",
+  "screenName": "happy-panda-42",
+  "avatarUrl": "https://...",
+  "createdAt": "2025-01-01T00:00:00Z",
+  "modifiedAt": "2025-01-02T00:00:00Z"
+}
+```
+
+#### `POST /profile/generate-screen-names`
+Generates batch of screen name options
+
+**Request**:
+```json
+{
+  "count": 10
+}
+```
+
+**Response**:
+```json
+{
+  "screenNames": [
+    "happy-panda-42",
+    "brave-falcon-17",
+    "clever-otter-89",
+    ...
+  ]
+}
+```
+
+#### `PUT /profile/screen-name`
+Updates user's screen name
+
+**Request**:
+```json
+{
+  "screenName": "cool-cat-99"
+}
+```
+
+**Response**:
+```json
+{
+  "id": "user-uuid",
+  "screenName": "cool-cat-99",
+  "avatarUrl": "https://...",
+  "createdAt": "2025-01-01T00:00:00Z",
+  "modifiedAt": "2025-01-02T12:00:00Z"
+}
+```
+
+**Errors**:
+- `400 Bad Request`: Screen name invalid or missing
+- `409 Conflict`: Screen name already taken
+- `401 Unauthorized`: User not authenticated
+
+---
+
+## Changelog
+
+| Version | Date | Author | Changes |
+|---------|------|--------|---------|
+| 1.0 | 2025-10-09 | AI Agent Team | Initial implementation plan |
+
+---
+
+**Document Status**: ✅ Ready for Implementation
+
+**Next Steps**:
+1. Review plan with engineering team
+2. Estimate effort and timeline
+3. Assign engineers to phases
+4. Create GitHub issues/tickets for tasks
+5. Begin Phase 1 implementation
+
+---
+
+*This plan follows the project's architectural patterns and coding standards as defined in `CLAUDE.md` and the existing codebase. All implementations must adhere to interface-first design, dependency injection, and comprehensive error handling without fallbacks.*
diff --git a/scripts/FRIENDLY_SCREENNAMES.sql b/scripts/FRIENDLY_SCREENNAMES.sql
new file mode 100644
index 0000000..2315bc6
--- /dev/null
+++ b/scripts/FRIENDLY_SCREENNAMES.sql
@@ -0,0 +1,117 @@
+-- ============================================================================
+-- FRIENDLY SCREEN NAMES GENERATOR
+-- Generates memorable, anonymous screen names like "happy-panda-42"
+-- ============================================================================
+
+-- Create arrays of adjectives and nouns for friendly name generation
+CREATE OR REPLACE FUNCTION generate_friendly_screenname()
+RETURNS TEXT AS $$
+DECLARE
+  adjectives TEXT[] := ARRAY[
+    'happy', 'clever', 'bright', 'swift', 'brave', 'calm', 'cool', 'eager',
+    'fair', 'gentle', 'jolly', 'kind', 'lively', 'merry', 'nice', 'proud',
+    'quick', 'quiet', 'witty', 'wise', 'bold', 'cosmic', 'daring', 'epic',
+    'fancy', 'glad', 'groovy', 'keen', 'lucky', 'magic', 'neat', 'noble',
+    'peppy', 'super', 'wild', 'zany', 'stellar', 'prime', 'radiant', 'shiny'
+  ];
+  nouns TEXT[] := ARRAY[
+    'panda', 'falcon', 'tiger', 'eagle', 'bear', 'wolf', 'fox', 'hawk',
+    'lion', 'otter', 'raven', 'swan', 'whale', 'lynx', 'cobra', 'crane',
+    'moose', 'bison', 'gecko', 'koala', 'lemur', 'meerkat', 'Phoenix', 'dragon',
+    'unicorn', 'griffin', 'pegasus', 'sphinx', 'hydra', 'kraken', 'comet',
+    'nebula', 'pulsar', 'quasar', 'nova', 'meteor', 'aurora', 'zenith', 'quantum'
+  ];
+  adj TEXT;
+  noun TEXT;
+  num TEXT;
+BEGIN
+  -- Select random adjective and noun
+  adj := adjectives[1 + floor(random() * array_length(adjectives, 1))::int];
+  noun := nouns[1 + floor(random() * array_length(nouns, 1))::int];
+  -- Generate random 2-3 digit number
+  num := (10 + floor(random() * 990))::text;
+
+  RETURN adj || '-' || noun || '-' || num;
+END;
+$$ LANGUAGE plpgsql;
+
+-- Update the trigger function to generate friendly names
+CREATE OR REPLACE FUNCTION handle_new_user()
+RETURNS TRIGGER AS $$
+DECLARE
+  random_name TEXT;
+  attempt_count INT := 0;
+BEGIN
+  -- Generate random friendly screen name
+  LOOP
+    random_name := generate_friendly_screenname();
+
+    -- Try to insert
+    BEGIN
+      INSERT INTO user_profiles (id, screen_name)
+      VALUES (NEW.id, random_name);
+
+      RETURN NEW;
+    EXCEPTION
+      WHEN unique_violation THEN
+        -- Try again with a new random name
+        attempt_count := attempt_count + 1;
+        IF attempt_count > 20 THEN
+          -- Fallback to UUID-based name if we can't find a unique friendly name
+          random_name := CONCAT('user-', SUBSTRING(gen_random_uuid()::text, 1, 8));
+          INSERT INTO user_profiles (id, screen_name)
+          VALUES (NEW.id, random_name);
+          RETURN NEW;
+        END IF;
+    END;
+  END LOOP;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION generate_friendly_screenname() IS 'Generates memorable anonymous screen names like "happy-panda-42"';
+COMMENT ON FUNCTION handle_new_user() IS 'Automatically creates a user profile with friendly screen name on signup';
+
+-- Update existing user profiles to friendly names
+-- Temporarily disable trigger to avoid modified_at error
+ALTER TABLE user_profiles DISABLE TRIGGER user_profiles_updated_at;
+
+DO $$
+DECLARE
+  profile_record RECORD;
+  new_name TEXT;
+  attempt_count INT;
+BEGIN
+  FOR profile_record IN SELECT id FROM user_profiles LOOP
+    attempt_count := 0;
+    LOOP
+      new_name := generate_friendly_screenname();
+
+      BEGIN
+        UPDATE user_profiles
+        SET screen_name = new_name
+        WHERE id = profile_record.id;
+
+        EXIT; -- Success, exit the loop
+      EXCEPTION
+        WHEN unique_violation THEN
+          attempt_count := attempt_count + 1;
+          IF attempt_count > 20 THEN
+            -- Fallback to UUID-based name
+            new_name := CONCAT('user-', SUBSTRING(gen_random_uuid()::text, 1, 8));
+            UPDATE user_profiles
+            SET screen_name = new_name
+            WHERE id = profile_record.id;
+            EXIT;
+          END IF;
+      END;
+    END LOOP;
+  END LOOP;
+END $$;
+
+-- Re-enable trigger
+ALTER TABLE user_profiles ENABLE TRIGGER user_profiles_updated_at;
+
+-- ============================================================================
+-- VERIFICATION QUERY - Run after executing above
+-- ============================================================================
+-- SELECT id, screen_name FROM user_profiles ORDER BY created_at DESC LIMIT 10;
diff --git a/src/services/cloud-mode-service.ts b/src/services/cloud-mode-service.ts
index 8251cf0..0f8cd3e 100644
--- a/src/services/cloud-mode-service.ts
+++ b/src/services/cloud-mode-service.ts
@@ -557,7 +557,7 @@ export class CloudModeService implements ICloudModeService {
     const to = from + limit - 1;
     query = query.range(from, to);
 
-    const { data, error, count } = await query;
+    const { data: modesData, error, count } = await query;
 
     if (error) {
       throw new Error(`Failed to fetch public modes: ${error.message}`);
@@ -566,8 +566,32 @@ export class CloudModeService implements ICloudModeService {
     const total = count || 0;
     const totalPages = Math.ceil(total / limit);
 
+    // Fetch unique author profiles for all modes
+    const authorIds = [...new Set((modesData || []).map(mode => mode.author_id))];
+    const { data: profilesData } = await this.supabase
+      .from('user_profiles')
+      .select('id, screen_name, avatar_url')
+      .in('id', authorIds);
+
+    // Create a map of profiles by id
+    const profilesMap = new Map(
+      (profilesData || []).map(profile => [profile.id, profile])
+    );
+
+    // Merge profile data into modes
+    const modesWithProfiles = (modesData || []).map(row => {
+      const profile = profilesMap.get(row.author_id);
+      return this.toCloudMode({
+        ...row,
+        user_profiles: profile ? {
+          screen_name: profile.screen_name,
+          avatar_url: profile.avatar_url,
+        } : null,
+      } as any);
+    });
+
     return {
-      data: (data || []).map((row) => this.toCloudMode(row as ModeRow)),
+      data: modesWithProfiles,
       pagination: {
         page,
         limit,
diff --git a/supabase/migrations/20251009145500_friendly_screennames.sql b/supabase/migrations/20251009145500_friendly_screennames.sql
new file mode 100644
index 0000000..aaa6337
--- /dev/null
+++ b/supabase/migrations/20251009145500_friendly_screennames.sql
@@ -0,0 +1,110 @@
+-- Generate friendly screen names like "happy-panda-42"
+
+-- Create function to generate friendly screen names
+CREATE OR REPLACE FUNCTION generate_friendly_screenname()
+RETURNS TEXT AS $$
+DECLARE
+  adjectives TEXT[] := ARRAY[
+    'happy', 'clever', 'bright', 'swift', 'brave', 'calm', 'cool', 'eager',
+    'fair', 'gentle', 'jolly', 'kind', 'lively', 'merry', 'nice', 'proud',
+    'quick', 'quiet', 'witty', 'wise', 'bold', 'cosmic', 'daring', 'epic',
+    'fancy', 'glad', 'groovy', 'keen', 'lucky', 'magic', 'neat', 'noble',
+    'peppy', 'super', 'wild', 'zany', 'stellar', 'prime', 'radiant', 'shiny'
+  ];
+  nouns TEXT[] := ARRAY[
+    'panda', 'falcon', 'tiger', 'eagle', 'bear', 'wolf', 'fox', 'hawk',
+    'lion', 'otter', 'raven', 'swan', 'whale', 'lynx', 'cobra', 'crane',
+    'moose', 'bison', 'gecko', 'koala', 'lemur', 'meerkat', 'Phoenix', 'dragon',
+    'unicorn', 'griffin', 'pegasus', 'sphinx', 'hydra', 'kraken', 'comet',
+    'nebula', 'pulsar', 'quasar', 'nova', 'meteor', 'aurora', 'zenith', 'quantum'
+  ];
+  adj TEXT;
+  noun TEXT;
+  num TEXT;
+BEGIN
+  -- Select random adjective and noun
+  adj := adjectives[1 + floor(random() * array_length(adjectives, 1))::int];
+  noun := nouns[1 + floor(random() * array_length(nouns, 1))::int];
+  -- Generate random 2-3 digit number
+  num := (10 + floor(random() * 990))::text;
+
+  RETURN adj || '-' || noun || '-' || num;
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION generate_friendly_screenname() IS 'Generates memorable anonymous screen names like "happy-panda-42"';
+
+-- Update the trigger function to generate friendly names
+CREATE OR REPLACE FUNCTION handle_new_user()
+RETURNS TRIGGER AS $$
+DECLARE
+  random_name TEXT;
+  attempt_count INT := 0;
+BEGIN
+  -- Generate random friendly screen name
+  LOOP
+    random_name := generate_friendly_screenname();
+
+    -- Try to insert
+    BEGIN
+      INSERT INTO user_profiles (id, screen_name)
+      VALUES (NEW.id, random_name);
+
+      RETURN NEW;
+    EXCEPTION
+      WHEN unique_violation THEN
+        -- Try again with a new random name
+        attempt_count := attempt_count + 1;
+        IF attempt_count > 20 THEN
+          -- Fallback to UUID-based name if we can't find a unique friendly name
+          random_name := CONCAT('user-', SUBSTRING(gen_random_uuid()::text, 1, 8));
+          INSERT INTO user_profiles (id, screen_name)
+          VALUES (NEW.id, random_name);
+          RETURN NEW;
+        END IF;
+    END;
+  END LOOP;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION handle_new_user() IS 'Automatically creates a user profile with friendly screen name on signup';
+
+-- Update existing user profiles to friendly names
+-- Temporarily disable trigger to avoid modified_at error
+ALTER TABLE user_profiles DISABLE TRIGGER user_profiles_updated_at;
+
+DO $$
+DECLARE
+  profile_record RECORD;
+  new_name TEXT;
+  attempt_count INT;
+BEGIN
+  FOR profile_record IN SELECT id FROM user_profiles LOOP
+    attempt_count := 0;
+    LOOP
+      new_name := generate_friendly_screenname();
+
+      BEGIN
+        UPDATE user_profiles
+        SET screen_name = new_name
+        WHERE id = profile_record.id;
+
+        EXIT; -- Success, exit the loop
+      EXCEPTION
+        WHEN unique_violation THEN
+          attempt_count := attempt_count + 1;
+          IF attempt_count > 20 THEN
+            -- Fallback to UUID-based name
+            new_name := CONCAT('user-', SUBSTRING(gen_random_uuid()::text, 1, 8));
+            UPDATE user_profiles
+            SET screen_name = new_name
+            WHERE id = profile_record.id;
+            EXIT;
+          END IF;
+      END;
+    END LOOP;
+  END LOOP;
+END $$;
+
+-- Re-enable trigger
+ALTER TABLE user_profiles ENABLE TRIGGER user_profiles_updated_at;


---

_**Agent (claude-sonnet-4-5-20250929)**_

docs(profile): add implementation plan and friendly screenname system

