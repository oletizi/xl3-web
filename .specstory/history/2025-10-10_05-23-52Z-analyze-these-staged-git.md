<!-- Generated by SpecStory -->

# Debugging Python Web Scraper with Selenium and BeautifulSoup (2025-10-10 05:23:52Z)

<!-- Claude Code Session ff962b92-21de-4832-8c9a-8f2644faaac0 (2025-10-10_05-23-52Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/src/components/editor/SlotCard.tsx b/src/components/editor/SlotCard.tsx
new file mode 100644
index 0000000..47e016a
--- /dev/null
+++ b/src/components/editor/SlotCard.tsx
@@ -0,0 +1,60 @@
+import { Badge } from '@/components/ui/badge';
+import { Card } from '@/components/ui/card';
+import { Check, AlertTriangle, RefreshCw, HelpCircle } from 'lucide-react';
+import { cn } from '@/lib/utils';
+import type { SyncStatus } from '@/utils/syncDetection';
+
+interface SlotCardProps {
+  slotIndex: number;
+  slotName: string;
+  isActive: boolean;
+  syncStatus: SyncStatus;
+  onClick: () => void;
+}
+
+export function SlotCard({
+  slotIndex,
+  slotName,
+  isActive,
+  syncStatus,
+  onClick
+}: SlotCardProps) {
+  const syncIcon = {
+    synced: <Check className="w-4 h-4 text-green-500" />,
+    modified: <AlertTriangle className="w-4 h-4 text-orange-500" />,
+    syncing: <RefreshCw className="w-4 h-4 text-blue-500 animate-spin" />,
+    unknown: <HelpCircle className="w-4 h-4 text-gray-400" />
+  }[syncStatus];
+
+  return (
+    <Card
+      onClick={onClick}
+      role="button"
+      tabIndex={0}
+      onKeyDown={(e) => {
+        if (e.key === 'Enter' || e.key === ' ') {
+          e.preventDefault();
+          onClick();
+        }
+      }}
+      aria-pressed={isActive}
+      aria-label={`Slot ${slotIndex}: ${slotName}${isActive ? ' (active)' : ''}`}
+      className={cn(
+        'flex flex-col items-center justify-center p-3 cursor-pointer',
+        'min-w-[80px] transition-all hover:shadow-md',
+        'focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2',
+        isActive && 'ring-2 ring-primary shadow-glow-primary'
+      )}
+    >
+      <div className="flex items-center justify-between w-full mb-1">
+        <Badge variant={isActive ? 'default' : 'outline'} className="text-xs">
+          {slotIndex}
+        </Badge>
+        {isActive && syncIcon}
+      </div>
+      <span className="text-sm font-medium text-center line-clamp-1">
+        {slotName}
+      </span>
+    </Card>
+  );
+}
diff --git a/src/components/editor/SlotSelector.tsx b/src/components/editor/SlotSelector.tsx
new file mode 100644
index 0000000..c6f2736
--- /dev/null
+++ b/src/components/editor/SlotSelector.tsx
@@ -0,0 +1,60 @@
+import { Button } from '@/components/ui/button';
+import { RefreshCw } from 'lucide-react';
+import { SlotCard } from './SlotCard';
+import type { SyncStatus } from '@/utils/syncDetection';
+import { cn } from '@/lib/utils';
+
+interface SlotSelectorProps {
+  slotNames: string[];
+  activeSlotIndex: number;
+  syncStatus: SyncStatus;
+  onSlotSelect: (index: number) => void;
+  onRefreshSlots: () => void;
+  isLoadingSlots: boolean;
+  isDeviceConnected: boolean;
+}
+
+export function SlotSelector({
+  slotNames,
+  activeSlotIndex,
+  syncStatus,
+  onSlotSelect,
+  onRefreshSlots,
+  isLoadingSlots,
+  isDeviceConnected
+}: SlotSelectorProps) {
+  return (
+    <div className="w-full">
+      <div className="flex items-center justify-between mb-3">
+        <h3 className="text-lg font-semibold text-foreground">
+          Device Slots
+        </h3>
+        <Button
+          variant="outline"
+          size="sm"
+          onClick={onRefreshSlots}
+          disabled={!isDeviceConnected || isLoadingSlots}
+        >
+          <RefreshCw className={cn(
+            'w-4 h-4 mr-2',
+            isLoadingSlots && 'animate-spin'
+          )} />
+          Refresh
+        </Button>
+      </div>
+
+      <div className="flex gap-2 overflow-x-auto pb-2">
+        {slotNames.map((name, index) => (
+          <SlotCard
+            key={index}
+            slotIndex={index}
+            slotName={name}
+            isActive={index === activeSlotIndex}
+            syncStatus={index === activeSlotIndex ? syncStatus : 'unknown'}
+            onClick={() => onSlotSelect(index)}
+          />
+        ))}
+      </div>
+    </div>
+  );
+}
diff --git a/src/contexts/LCXL3Context.tsx b/src/contexts/LCXL3Context.tsx
index 42bca37..6db7040 100644
--- a/src/contexts/LCXL3Context.tsx
+++ b/src/contexts/LCXL3Context.tsx
@@ -9,6 +9,7 @@ interface LCXL3ContextType {
   isInitialized: boolean;
   error: string | null;
   fetchCurrentMode: () => Promise<LCXL3CustomMode>;
+  fetchAllSlotNames: () => Promise<string[]>;
 }
 
 const LCXL3Context = createContext<LCXL3ContextType | undefined>(undefined);
@@ -33,4 +34,4 @@ export function useLCXL3Device() {
     throw new Error('useLCXL3Device must be used within a LCXL3Provider');
   }
   return context;
-}
\ No newline at end of file
+}
diff --git a/src/hooks/useLCXL3Device.ts b/src/hooks/useLCXL3Device.ts
index 4e6cbfe..df447b1 100644
--- a/src/hooks/useLCXL3Device.ts
+++ b/src/hooks/useLCXL3Device.ts
@@ -364,8 +364,30 @@ export function useLCXL3Device() {
     return mode;
   };
 
+  const fetchAllSlotNames = async (): Promise<string[]> => {
+    if (!state.device || !state.isConnected) {
+      throw new Error('Device not connected');
+    }
+
+    const names: string[] = [];
+
+    // Load each slot and extract its name
+    for (let i = 0; i < 15; i++) {
+      try {
+        const mode = await state.device.loadCustomMode(i);
+        names.push(mode.name || `Slot ${i}`);
+      } catch (error) {
+        console.warn(`Failed to load slot ${i}:`, error);
+        names.push(`---`); // Empty slot indicator
+      }
+    }
+
+    return names;
+  };
+
   return {
     ...state,
-    fetchCurrentMode
+    fetchCurrentMode,
+    fetchAllSlotNames
   };
-}
\ No newline at end of file
+}
diff --git a/src/pages/Editor.tsx b/src/pages/Editor.tsx
index 3e1a566..b1f9892 100644
--- a/src/pages/Editor.tsx
+++ b/src/pages/Editor.tsx
@@ -21,11 +21,15 @@ import {
 } from "lucide-react";
 import { motion } from "framer-motion";
 import ControllerVisual from "@/components/editor/ControllerVisual";
+import { SlotSelector } from "@/components/editor/SlotSelector";
 import { CustomMode, ControlMapping } from "@/types/mode";
 import { saveMode, loadMode } from "@/utils/fileStorage";
 import { toast } from "sonner";
 import { initializeDefaultControls, getControlInfo } from "@/utils/controlMetadata";
 import { loadModeFromStorage, saveModeToStorage, clearModeFromStorage } from "@/utils/statePersistence";
+import { saveActiveSlot, loadActiveSlot, saveSlotNames, loadSlotNames } from "@/utils/slotPersistence";
+import { checkSlotSync } from "@/utils/syncDetection";
+import type { SyncStatus } from "@/utils/syncDetection";
 import { useLCXL3Device } from "@/contexts/LCXL3Context";
 import { lcxl3ModeToCustomMode, customModeToLCXL3Mode } from "@/utils/modeConverter";
 import { VERSION as LCXL3_VERSION } from "@oletizi/launch-control-xl3";
@@ -59,7 +63,14 @@ const Editor = () => {
   });
   const [selectedControl, setSelectedControl] = useState<string | null>(null);
   const [saveDialogOpen, setSaveDialogOpen] = useState(false);
-  const { device, isConnected: lcxl3Connected, fetchCurrentMode } = useLCXL3Device();
+  const [activeSlotIndex, setActiveSlotIndex] = useState<number>(() => loadActiveSlot());
+  const [slotNames, setSlotNames] = useState<string[]>(() => {
+    const cached = loadSlotNames();
+    return cached || Array.from({ length: 15 }, (_, i) => `Slot ${i}`);
+  });
+  const [syncStatus, setSyncStatus] = useState<SyncStatus>('unknown');
+  const [isLoadingSlots, setIsLoadingSlots] = useState(false);
+  const { device, isConnected: lcxl3Connected, fetchCurrentMode, fetchAllSlotNames } = useLCXL3Device();
 
   // Fetch mode from cloud if ID is in query params
   const { data: cloudMode, isLoading: isLoadingCloudMode } = useModeById(
@@ -136,10 +147,16 @@ const Editor = () => {
   };
 
   const handleFetch = async () => {
+    if (!device) {
+      toast.error('Device not connected');
+      return;
+    }
+
     try {
-      toast.info('Fetching mode from device...');
+      setSyncStatus('syncing');
+      toast.info(`Fetching mode from slot ${activeSlotIndex}...`);
 
-      const lcxl3Mode = await fetchCurrentMode();
+      const lcxl3Mode = await device.loadCustomMode(activeSlotIndex);
       console.log('Raw mode from device:', lcxl3Mode);
       console.log('Controls array:', lcxl3Mode.controls);
 
@@ -174,8 +191,10 @@ const Editor = () => {
         controls: mergedControls
       });
 
-      toast.success('Mode fetched successfully from device!');
+      setSyncStatus('synced');
+      toast.success(`Mode fetched successfully from slot ${activeSlotIndex}!`);
     } catch (error) {
+      setSyncStatus('unknown');
       const message = error instanceof Error ? error.message : 'Failed to fetch mode';
       toast.error(`Fetch failed: ${message}`);
       console.error('Fetch error:', error);
@@ -189,13 +208,16 @@ const Editor = () => {
     }
 
     try {
-      toast.info('Sending mode to device...');
+      setSyncStatus('syncing');
+      toast.info(`Sending mode to slot ${activeSlotIndex}...`);
 
       const lcxl3Mode = customModeToLCXL3Mode(mode);
-      await device.saveCustomMode(0, lcxl3Mode);
+      await device.saveCustomMode(activeSlotIndex, lcxl3Mode);
 
-      toast.success('Mode sent successfully to device!');
+      setSyncStatus('synced');
+      toast.success(`Mode sent successfully to slot ${activeSlotIndex}!`);
     } catch (error) {
+      setSyncStatus('unknown');
       const message = error instanceof Error ? error.message : 'Failed to send mode';
       toast.error(`Send failed: ${message}`);
       console.error('Send error:', error);
@@ -212,6 +234,42 @@ const Editor = () => {
     });
   };
 
+  // Fetch all slot names from device
+  const handleRefreshSlots = async () => {
+    if (!device || !lcxl3Connected) return;
+
+    setIsLoadingSlots(true);
+    try {
+      const names = await fetchAllSlotNames();
+      setSlotNames(names);
+      saveSlotNames(names);
+      toast.success('Slot names refreshed');
+    } catch (error) {
+      toast.error('Failed to fetch slot names');
+      console.error(error);
+    } finally {
+      setIsLoadingSlots(false);
+    }
+  };
+
+  // Handle slot selection
+  const handleSlotSelect = async (index: number) => {
+    setActiveSlotIndex(index);
+    saveActiveSlot(index);
+
+    // Check sync status for new slot
+    if (device && lcxl3Connected) {
+      try {
+        setSyncStatus('syncing');
+        const deviceMode = await device.loadCustomMode(index);
+        const isSync = await checkSlotSync(mode, deviceMode);
+        setSyncStatus(isSync ? 'synced' : 'modified');
+      } catch {
+        setSyncStatus('unknown');
+      }
+    }
+  };
+
   // Effect to load cloud mode when fetched from query parameter
   useEffect(() => {
     if (cloudMode && modeIdParam) {
@@ -237,7 +295,17 @@ const Editor = () => {
 
   useEffect(() => {
     saveModeToStorage(mode);
-  }, [mode]);
+
+    // Mark as modified when buffer changes (unless we just fetched/sent)
+    // Small delay to avoid race condition with fetch/send
+    const timeoutId = setTimeout(() => {
+      if (syncStatus === 'synced') {
+        setSyncStatus('modified');
+      }
+    }, 100);
+
+    return () => clearTimeout(timeoutId);
+  }, [mode, syncStatus]);
 
   return (
     <div className="container mx-auto px-4 py-8 space-y-8">
@@ -306,6 +374,24 @@ const Editor = () => {
       <div className="grid grid-cols-1 xl:grid-cols-4 gap-8">
         {/* Main Editor Area */}
         <div className="xl:col-span-3 space-y-6">
+          {/* Slot Selector */}
+          <motion.div
+            initial={{ opacity: 0, y: 20 }}
+            animate={{ opacity: 1, y: 0 }}
+          >
+            <Card className="p-6 bg-gradient-surface border-border/50">
+              <SlotSelector
+                slotNames={slotNames}
+                activeSlotIndex={activeSlotIndex}
+                syncStatus={syncStatus}
+                onSlotSelect={handleSlotSelect}
+                onRefreshSlots={handleRefreshSlots}
+                isLoadingSlots={isLoadingSlots}
+                isDeviceConnected={lcxl3Connected}
+              />
+            </Card>
+          </motion.div>
+
           {/* Controller Visual */}
           <motion.div
             initial={{ opacity: 0, y: 20 }}
diff --git a/src/utils/slotPersistence.ts b/src/utils/slotPersistence.ts
new file mode 100644
index 0000000..46b80a7
--- /dev/null
+++ b/src/utils/slotPersistence.ts
@@ -0,0 +1,47 @@
+const ACTIVE_SLOT_KEY = 'lcxl3-active-slot';
+const SLOT_NAMES_KEY = 'lcxl3-slot-names';
+
+export function saveActiveSlot(slotIndex: number): void {
+  if (slotIndex < 0 || slotIndex > 14) {
+    throw new Error(`Invalid slot index: ${slotIndex}`);
+  }
+  localStorage.setItem(ACTIVE_SLOT_KEY, String(slotIndex));
+}
+
+export function loadActiveSlot(): number {
+  const stored = localStorage.getItem(ACTIVE_SLOT_KEY);
+  const parsed = parseInt(stored || '0', 10);
+
+  if (isNaN(parsed) || parsed < 0 || parsed > 14) {
+    return 0; // Default to slot 0
+  }
+
+  return parsed;
+}
+
+export function saveSlotNames(names: string[]): void {
+  if (names.length !== 15) {
+    throw new Error(`Expected 15 slot names, got ${names.length}`);
+  }
+  localStorage.setItem(SLOT_NAMES_KEY, JSON.stringify(names));
+}
+
+export function loadSlotNames(): string[] | null {
+  const stored = localStorage.getItem(SLOT_NAMES_KEY);
+  if (!stored) return null;
+
+  try {
+    const parsed = JSON.parse(stored);
+    if (Array.isArray(parsed) && parsed.length === 15) {
+      return parsed;
+    }
+    return null;
+  } catch {
+    return null;
+  }
+}
+
+export function clearSlotData(): void {
+  localStorage.removeItem(ACTIVE_SLOT_KEY);
+  localStorage.removeItem(SLOT_NAMES_KEY);
+}
diff --git a/src/utils/syncDetection.ts b/src/utils/syncDetection.ts
new file mode 100644
index 0000000..6490ba1
--- /dev/null
+++ b/src/utils/syncDetection.ts
@@ -0,0 +1,98 @@
+import type { CustomMode } from '@/types/mode';
+import type { LCXL3CustomMode } from '@/utils/modeConverter';
+import { lcxl3ModeToCustomMode } from '@/utils/modeConverter';
+
+/**
+ * Simple hash function for mode data
+ */
+function hashMode(mode: CustomMode): string {
+  // Create a stable representation of controls only
+  const controlsKeys = Object.keys(mode.controls).sort();
+  const controlsData = controlsKeys.map(key => {
+    const c = mode.controls[key];
+    return `${key}:${c.ccNumber}:${c.midiChannel}:${c.minValue}:${c.maxValue}`;
+  }).join('|');
+
+  // Simple hash (not cryptographic, just for comparison)
+  let hash = 0;
+  for (let i = 0; i < controlsData.length; i++) {
+    const char = controlsData.charCodeAt(i);
+    hash = ((hash << 5) - hash) + char;
+    hash = hash & hash; // Convert to 32-bit integer
+  }
+
+  return hash.toString(36);
+}
+
+/**
+ * Compare two modes for equality (ignoring timestamps/metadata)
+ */
+export function modesAreEqual(a: CustomMode, b: CustomMode): boolean {
+  return hashMode(a) === hashMode(b);
+}
+
+/**
+ * Check if edit buffer matches device slot
+ */
+export async function checkSlotSync(
+  editBuffer: CustomMode,
+  deviceMode: LCXL3CustomMode
+): Promise<boolean> {
+  const convertedDeviceMode = lcxl3ModeToCustomMode(deviceMode);
+  return modesAreEqual(editBuffer, convertedDeviceMode);
+}
+
+export type SyncStatus = 'synced' | 'modified' | 'syncing' | 'unknown';
+
+/**
+ * Sync tracker that uses optimistic updates
+ */
+export class SyncTracker {
+  private lastKnownDeviceHash: string | null = null;
+  private lastEditBufferHash: string | null = null;
+
+  /**
+   * Mark that we just fetched from device
+   */
+  markFetched(mode: CustomMode): void {
+    const hash = hashMode(mode);
+    this.lastKnownDeviceHash = hash;
+    this.lastEditBufferHash = hash;
+  }
+
+  /**
+   * Mark that we just sent to device
+   */
+  markSent(mode: CustomMode): void {
+    const hash = hashMode(mode);
+    this.lastKnownDeviceHash = hash;
+    this.lastEditBufferHash = hash;
+  }
+
+  /**
+   * Mark that edit buffer changed
+   */
+  markEdited(mode: CustomMode): void {
+    this.lastEditBufferHash = hashMode(mode);
+  }
+
+  /**
+   * Get sync status without device read
+   */
+  getOptimisticStatus(): SyncStatus {
+    if (this.lastKnownDeviceHash === null) return 'unknown';
+    if (this.lastEditBufferHash === null) return 'unknown';
+
+    return this.lastKnownDeviceHash === this.lastEditBufferHash
+      ? 'synced'
+      : 'modified';
+  }
+
+  /**
+   * Reset tracker (e.g., when switching slots)
+   */
+  reset(): void {
+    this.lastKnownDeviceHash = null;
+    this.lastEditBufferHash = null;
+  }
+}


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(editor): add multi-slot management with sync status tracking

