<!-- Generated by SpecStory -->

# Screen Name Generation Bug Fix Completed (2025-10-09 23:48:01Z)

<!-- Claude Code Session c608dbbe-4f57-4ba6-8522-b52f696dde2c (2025-10-09_23-48-01Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/docs/1.0/profile/implementation/workplan.md b/docs/1.0/profile/implementation/workplan.md
index 620b6fb..916d0df 100644
--- a/docs/1.0/profile/implementation/workplan.md
+++ b/docs/1.0/profile/implementation/workplan.md
@@ -1,5 +1,37 @@
 # User Profile Page with Screen Name Selection - Implementation Plan
 
+## ðŸŽ¯ Implementation Status: Phases 1-3 Complete (October 9, 2025)
+
+**Current Phase**: Testing & Polish (Phase 4)
+
+### âœ… Completed Work:
+- **Phase 1 (Foundation)**: Database migrations, service layer, and tests complete
+  - Migration `20251009160000_profile_batch_functions.sql` applied to production
+  - Migration `20251009XXXXXX_fix_batch_generation_null_array.sql` applied (bug fix for empty array case)
+  - `UserProfileService` implemented with full test coverage
+  - RLS policies enforced for profile security
+  - **Bug Fixed**: `generate_screen_name_batch()` now handles empty array case with `COALESCE(array_length(names, 1), 0)`
+
+- **Phase 2 (API Layer)**: React Query hooks with optimistic updates complete
+  - `useUserProfile()`, `useGenerateScreenNames()`, `useUpdateScreenName()` implemented
+  - Query cache management and optimistic UI updates working
+  - Toast notifications for user feedback
+
+- **Phase 3 (UI Components)**: Profile page and all components built
+  - Profile page with responsive design
+  - All components (`ProfileHeader`, `ScreenNameSection`, `ScreenNamePicker`, etc.)
+  - Navigation integration complete (/profile route active)
+  - TypeScript compilation: âœ… Zero errors
+  - ESLint: âœ… Zero errors
+  - **Screen name generation now working**: Tested and verified with 5 unique names
+
+### ðŸš§ Remaining Work:
+- Phase 2: Hook tests (pending)
+- Phase 4: E2E tests, accessibility audit, performance testing
+- Phase 5: Deployment to production
+
+---
+
 ## Executive Summary
 
 This document outlines the implementation plan for a user profile page that allows users to view and change their screen names by selecting from auto-generated options. The feature builds on the existing friendly screen name system and follows the project's interface-first architecture.
diff --git a/src/App.tsx b/src/App.tsx
index cf134eb..74be5ac 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -10,6 +10,7 @@ import Editor from "./pages/Editor";
 import Library from "./pages/Library";
 import Catalog from "./pages/Catalog";
 import ModeDetail from "./pages/ModeDetail";
+import Profile from "./pages/Profile";
 import { Login } from "./pages/Login";
 import { AuthCallback } from "./pages/AuthCallback";
 import NotFound from "./pages/NotFound";
@@ -33,6 +34,7 @@ const App = () => (
             <Route path="/library" element={<ProtectedRoute><Layout><Library /></Layout></ProtectedRoute>} />
             <Route path="/catalog" element={<ProtectedRoute><Layout><Catalog /></Layout></ProtectedRoute>} />
             <Route path="/modes/:id" element={<ProtectedRoute><Layout><ModeDetail /></Layout></ProtectedRoute>} />
+            <Route path="/profile" element={<ProtectedRoute><Layout><Profile /></Layout></ProtectedRoute>} />
 
             {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
             <Route path="*" element={<Layout><NotFound /></Layout>} />
diff --git a/src/components/auth/UserProfile.tsx b/src/components/auth/UserProfile.tsx
index 7758334..e93ed1f 100644
--- a/src/components/auth/UserProfile.tsx
+++ b/src/components/auth/UserProfile.tsx
@@ -33,6 +33,10 @@ export function UserProfile() {
     }
   };
 
+  const handleProfileClick = () => {
+    navigate('/profile');
+  };
+
   const avatarUrl = user.user_metadata?.avatar_url;
   const fullName = user.user_metadata?.full_name || user.email;
   const email = user.email;
@@ -71,6 +75,13 @@ export function UserProfile() {
           </div>
         </DropdownMenuLabel>
         <DropdownMenuSeparator />
+        <DropdownMenuItem
+          onClick={handleProfileClick}
+          className="cursor-pointer"
+        >
+          <User className="mr-2 h-4 w-4" />
+          <span>Profile</span>
+        </DropdownMenuItem>
         <DropdownMenuItem
           onClick={handleSignOut}
           disabled={signingOut}
diff --git a/src/components/profile/ProfileError.tsx b/src/components/profile/ProfileError.tsx
new file mode 100644
index 0000000..6a59d23
--- /dev/null
+++ b/src/components/profile/ProfileError.tsx
@@ -0,0 +1,64 @@
+/**
+ * ProfileError Component
+ *
+ * Error state display with retry and navigation options.
+ */
+
+import { useNavigate } from 'react-router-dom';
+import { useUserProfile } from '@/hooks/use-user-profile';
+import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
+import { Button } from '@/components/ui/button';
+import { Alert, AlertDescription } from '@/components/ui/alert';
+import { AlertCircle, Home, RefreshCw } from 'lucide-react';
+
+interface ProfileErrorProps {
+  error: Error;
+}
+
+export function ProfileError({ error }: ProfileErrorProps) {
+  const navigate = useNavigate();
+  const { refetch } = useUserProfile();
+
+  const handleRetry = () => {
+    refetch();
+  };
+
+  const handleGoHome = () => {
+    navigate('/');
+  };
+
+  return (
+    <div className="container mx-auto p-6 max-w-4xl">
+      <Card>
+        <CardHeader>
+          <CardTitle className="flex items-center space-x-2">
+            <AlertCircle className="h-6 w-6 text-destructive" />
+            <span>Profile Error</span>
+          </CardTitle>
+          <CardDescription>
+            We encountered an error loading your profile
+          </CardDescription>
+        </CardHeader>
+        <CardContent className="space-y-4">
+          <Alert variant="destructive">
+            <AlertCircle className="h-4 w-4" />
+            <AlertDescription>
+              {error.message || 'An unknown error occurred while loading your profile.'}
+            </AlertDescription>
+          </Alert>
+
+          <div className="flex items-center space-x-2">
+            <Button onClick={handleRetry} variant="default">
+              <RefreshCw className="mr-2 h-4 w-4" />
+              Retry
+            </Button>
+            <Button onClick={handleGoHome} variant="outline">
+              <Home className="mr-2 h-4 w-4" />
+              Go to Home
+            </Button>
+          </div>
+        </CardContent>
+      </Card>
+    </div>
+  );
+}
diff --git a/src/components/profile/ProfileHeader.tsx b/src/components/profile/ProfileHeader.tsx
new file mode 100644
index 0000000..2af44d4
--- /dev/null
+++ b/src/components/profile/ProfileHeader.tsx
@@ -0,0 +1,79 @@
+/**
+ * ProfileHeader Component
+ *
+ * Displays user's current profile information including avatar, screen name, and join date.
+ */
+
+import { UserProfile } from '@/services/user-profile-service';
+import { Card, CardContent } from '@/components/ui/card';
+import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
+import { Badge } from '@/components/ui/badge';
+import { Calendar, User as UserIcon } from 'lucide-react';
+
+interface ProfileHeaderProps {
+  profile: UserProfile;
+}
+
+export function ProfileHeader({ profile }: ProfileHeaderProps) {
+  // Get initials for fallback avatar
+  const getInitials = (screenName: string): string => {
+    const parts = screenName.split('-');
+    if (parts.length >= 2) {
+      return `${parts[0][0]}${parts[1][0]}`.toUpperCase();
+    }
+    return screenName.substring(0, 2).toUpperCase();
+  };
+
+  // Format date for display
+  const formatDate = (dateString: string): string => {
+    const date = new Date(dateString);
+    return date.toLocaleDateString('en-US', {
+      year: 'numeric',
+      month: 'long',
+      day: 'numeric',
+    });
+  };
+
+  return (
+    <Card>
+      <CardContent className="pt-6">
+        <div className="flex items-center space-x-6">
+          <Avatar className="h-24 w-24">
+            <AvatarImage src={profile.avatarUrl} alt={profile.screenName} />
+            <AvatarFallback className="text-2xl">
+              {getInitials(profile.screenName)}
+            </AvatarFallback>
+          </Avatar>
+
+          <div className="flex-1 space-y-3">
+            <div>
+              <div className="flex items-center space-x-3">
+                <h1
+                  className="text-3xl font-bold"
+                  data-testid="current-screen-name"
+                >
+                  {profile.screenName}
+                </h1>
+                <Badge variant="secondary">
+                  <UserIcon className="h-3 w-3 mr-1" />
+                  User
+                </Badge>
+              </div>
+            </div>
+
+            <div className="flex items-center text-sm text-muted-foreground">
+              <Calendar className="h-4 w-4 mr-2" />
+              <span>Joined {formatDate(profile.createdAt)}</span>
+            </div>
+
+            {profile.bio && (
+              <p className="text-sm text-muted-foreground max-w-2xl">
+                {profile.bio}
+              </p>
+            )}
+          </div>
+        </div>
+      </CardContent>
+    </Card>
+  );
+}
diff --git a/src/components/profile/ProfileSkeleton.tsx b/src/components/profile/ProfileSkeleton.tsx
new file mode 100644
index 0000000..b4ed215
--- /dev/null
+++ b/src/components/profile/ProfileSkeleton.tsx
@@ -0,0 +1,56 @@
+/**
+ * ProfileSkeleton Component
+ *
+ * Loading placeholder matching the Profile page layout.
+ */
+
+import { Card, CardContent, CardHeader } from '@/components/ui/card';
+import { Skeleton } from '@/components/ui/skeleton';
+import { Separator } from '@/components/ui/separator';
+
+export function ProfileSkeleton() {
+  return (
+    <div className="container mx-auto p-6 max-w-4xl">
+      {/* Profile Header Skeleton */}
+      <Card>
+        <CardContent className="pt-6">
+          <div className="flex items-center space-x-6">
+            <Skeleton className="h-24 w-24 rounded-full" />
+            <div className="flex-1 space-y-3">
+              <Skeleton className="h-8 w-48" />
+              <Skeleton className="h-4 w-32" />
+            </div>
+          </div>
+        </CardContent>
+      </Card>
+
+      <Separator className="my-6" />
+
+      {/* Screen Name Section Skeleton */}
+      <Card>
+        <CardHeader>
+          <Skeleton className="h-6 w-32" />
+          <Skeleton className="h-4 w-64 mt-2" />
+        </CardHeader>
+        <CardContent className="space-y-4">
+          <Card>
+            <CardHeader>
+              <Skeleton className="h-5 w-48" />
+              <Skeleton className="h-4 w-96 mt-2" />
+            </CardHeader>
+            <CardContent>
+              <div className="space-y-3">
+                {Array.from({ length: 10 }).map((_, i) => (
+                  <div key={i} className="flex items-center space-x-2">
+                    <Skeleton className="h-4 w-4 rounded-full" />
+                    <Skeleton className="h-4 w-48" />
+                  </div>
+                ))}
+              </div>
+            </CardContent>
+          </Card>
+        </CardContent>
+      </Card>
+    </div>
+  );
+}
diff --git a/src/components/profile/ScreenNamePicker.tsx b/src/components/profile/ScreenNamePicker.tsx
new file mode 100644
index 0000000..a07e697
--- /dev/null
+++ b/src/components/profile/ScreenNamePicker.tsx
@@ -0,0 +1,107 @@
+/**
+ * ScreenNamePicker Component
+ *
+ * Generates and displays screen name options with radio selection.
+ * Includes regenerate functionality.
+ */
+
+import { useGenerateScreenNames } from '@/hooks/use-user-profile';
+import {
+  Card,
+  CardContent,
+  CardDescription,
+  CardFooter,
+  CardHeader,
+  CardTitle,
+} from '@/components/ui/card';
+import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
+import { Label } from '@/components/ui/label';
+import { Badge } from '@/components/ui/badge';
+import { Button } from '@/components/ui/button';
+import { Skeleton } from '@/components/ui/skeleton';
+import { Loader2, RefreshCw } from 'lucide-react';
+
+interface ScreenNamePickerProps {
+  currentScreenName: string;
+  onSelect: (screenName: string) => void;
+  selectedScreenName?: string;
+}
+
+export function ScreenNamePicker({
+  currentScreenName,
+  onSelect,
+  selectedScreenName,
+}: ScreenNamePickerProps) {
+  const { data: options, isLoading, refetch, isFetching } = useGenerateScreenNames(10);
+
+  const handleRegenerate = () => {
+    refetch();
+  };
+
+  return (
+    <Card>
+      <CardHeader>
+        <CardTitle>Choose a Screen Name</CardTitle>
+        <CardDescription>
+          Select a friendly screen name from the options below, or regenerate for more choices
+        </CardDescription>
+      </CardHeader>
+      <CardContent>
+        {isLoading ? (
+          <div className="space-y-3">
+            {Array.from({ length: 10 }).map((_, i) => (
+              <div key={i} className="flex items-center space-x-2">
+                <Skeleton className="h-4 w-4 rounded-full" />
+                <Skeleton className="h-4 w-48" />
+              </div>
+            ))}
+          </div>
+        ) : options && options.length > 0 ? (
+          <RadioGroup value={selectedScreenName} onValueChange={onSelect}>
+            <div className="space-y-3">
+              {options.map((name) => (
+                <div key={name} className="flex items-center space-x-2">
+                  <RadioGroupItem value={name} id={name} />
+                  <Label
+                    htmlFor={name}
+                    className="flex-1 cursor-pointer text-base hover:text-primary transition-colors"
+                  >
+                    {name}
+                    {name === currentScreenName && (
+                      <Badge variant="secondary" className="ml-2">
+                        Current
+                      </Badge>
+                    )}
+                  </Label>
+                </div>
+              ))}
+            </div>
+          </RadioGroup>
+        ) : (
+          <div className="text-center text-muted-foreground py-8">
+            Failed to generate options. Please try regenerating.
+          </div>
+        )}
+      </CardContent>
+      <CardFooter>
+        <Button
+          variant="outline"
+          onClick={handleRegenerate}
+          disabled={isFetching}
+        >
+          {isFetching ? (
+            <>
+              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+              Generating...
+            </>
+          ) : (
+            <>
+              <RefreshCw className="mr-2 h-4 w-4" />
+              Regenerate Options
+            </>
+          )}
+        </Button>
+      </CardFooter>
+    </Card>
+  );
+}
diff --git a/src/components/profile/ScreenNameSection.tsx b/src/components/profile/ScreenNameSection.tsx
new file mode 100644
index 0000000..a832c4d
--- /dev/null
+++ b/src/components/profile/ScreenNameSection.tsx
@@ -0,0 +1,83 @@
+/**
+ * ScreenNameSection Component
+ *
+ * Orchestrates screen name selection flow with save/cancel actions.
+ */
+
+import { useState } from 'react';
+import { UserProfile } from '@/services/user-profile-service';
+import { useUpdateScreenName } from '@/hooks/use-user-profile';
+import { ScreenNamePicker } from '@/components/profile/ScreenNamePicker';
+import { Button } from '@/components/ui/button';
+import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
+import { Loader2 } from 'lucide-react';
+
+interface ScreenNameSectionProps {
+  profile: UserProfile;
+}
+
+export function ScreenNameSection({ profile }: ScreenNameSectionProps) {
+  const [selectedScreenName, setSelectedScreenName] = useState<string>();
+  const updateScreenName = useUpdateScreenName();
+
+  const handleSave = () => {
+    if (selectedScreenName && selectedScreenName !== profile.screenName) {
+      updateScreenName.mutate(selectedScreenName, {
+        onSuccess: () => {
+          setSelectedScreenName(undefined);
+        },
+      });
+    }
+  };
+
+  const handleCancel = () => {
+    setSelectedScreenName(undefined);
+  };
+
+  const hasChanges = selectedScreenName && selectedScreenName !== profile.screenName;
+
+  return (
+    <div className="space-y-4">
+      <Card>
+        <CardHeader>
+          <CardTitle>Screen Name</CardTitle>
+          <CardDescription>
+            Update your screen name to personalize your profile
+          </CardDescription>
+        </CardHeader>
+        <CardContent className="space-y-4">
+          <ScreenNamePicker
+            currentScreenName={profile.screenName}
+            onSelect={setSelectedScreenName}
+            selectedScreenName={selectedScreenName}
+          />
+
+          {hasChanges && (
+            <div className="flex items-center justify-end space-x-2 pt-4">
+              <Button
+                variant="outline"
+                onClick={handleCancel}
+                disabled={updateScreenName.isPending}
+              >
+                Cancel
+              </Button>
+              <Button
+                onClick={handleSave}
+                disabled={updateScreenName.isPending}
+              >
+                {updateScreenName.isPending ? (
+                  <>
+                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                    Saving...
+                  </>
+                ) : (
+                  'Save Screen Name'
+                )}
+              </Button>
+            </div>
+          )}
+        </CardContent>
+      </Card>
+    </div>
+  );
+}
diff --git a/src/components/profile/index.ts b/src/components/profile/index.ts
new file mode 100644
index 0000000..629d022
--- /dev/null
+++ b/src/components/profile/index.ts
@@ -0,0 +1,9 @@
+/**
+ * Profile components barrel export
+ */
+
+export { ProfileHeader } from './ProfileHeader';
+export { ScreenNameSection } from './ScreenNameSection';
+export { ScreenNamePicker } from './ScreenNamePicker';
+export { ProfileSkeleton } from './ProfileSkeleton';
+export { ProfileError } from './ProfileError';
diff --git a/src/hooks/use-user-profile.ts b/src/hooks/use-user-profile.ts
new file mode 100644
index 0000000..d1b0733
--- /dev/null
+++ b/src/hooks/use-user-profile.ts
@@ -0,0 +1,243 @@
+/**
+ * React Query hooks for user profile operations
+ *
+ * Provides hooks for fetching and updating user profiles, including screen name
+ * selection. Implements optimistic updates, cache management, and error handling.
+ *
+ * @module hooks/use-user-profile
+ */
+
+import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
+import { supabase } from '@/lib/supabase';
+import { createUserProfileService } from '@/services/user-profile-service';
+import type { UserProfile } from '@/services/user-profile-service';
+import { toast } from '@/hooks/use-toast';
+
+// ============================================================================
+// SERVICE SINGLETON
+// ============================================================================
+
+/**
+ * Singleton UserProfileService instance
+ * Uses the global Supabase client
+ */
+const userProfileService = createUserProfileService(supabase);
+
+// ============================================================================
+// QUERY KEYS
+// ============================================================================
+
+/**
+ * Centralized query key factory for user profile
+ *
+ * Provides consistent query keys for React Query cache management.
+ */
+export const userProfileKeys = {
+  /** Base key for all user profile queries */
+  all: ['userProfile'] as const,
+
+  /** Key for current user's profile */
+  profile: () => [...userProfileKeys.all, 'current'] as const,
+
+  /** Key for screen name options with count */
+  screenNameOptions: (count: number) => [...userProfileKeys.all, 'screenNameOptions', count] as const,
+};
+
+// ============================================================================
+// QUERY HOOKS
+// ============================================================================
+
+/**
+ * Hook to fetch current user profile
+ *
+ * Fetches the authenticated user's profile including screen name and avatar.
+ * Requires authentication.
+ *
+ * @returns React Query result with user profile
+ *
+ * @example
+ * ```tsx
+ * function ProfilePage() {
+ *   const { data: profile, isLoading, error } = useUserProfile();
+ *
+ *   if (isLoading) return <ProfileSkeleton />;
+ *   if (error) return <ProfileError error={error} />;
+ *
+ *   return <ProfileHeader profile={profile} />;
+ * }
+ * ```
+ */
+export function useUserProfile() {
+  return useQuery({
+    queryKey: userProfileKeys.profile(),
+    queryFn: () => userProfileService.getUserProfile(),
+    staleTime: 5 * 60 * 1000, // 5 minutes
+    gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
+    retry: 1, // Only retry once for auth errors
+  });
+}
+
+/**
+ * Hook to generate screen name options
+ *
+ * Generates a batch of unique screen name options for user selection.
+ * Does not cache results (always fetches fresh names).
+ *
+ * @param count Number of options to generate (default: 10)
+ * @returns React Query result with screen name array
+ *
+ * @example
+ * ```tsx
+ * function ScreenNamePicker() {
+ *   const { data: options, isLoading, refetch } = useGenerateScreenNames(10);
+ *
+ *   const handleRegenerate = () => {
+ *     refetch();
+ *   };
+ *
+ *   return (
+ *     <>
+ *       {options?.map(name => <NameOption key={name} name={name} />)}
+ *       <Button onClick={handleRegenerate}>Regenerate</Button>
+ *     </>
+ *   );
+ * }
+ * ```
+ */
+export function useGenerateScreenNames(count: number = 10) {
+  return useQuery({
+    queryKey: userProfileKeys.screenNameOptions(count),
+    queryFn: () => userProfileService.generateScreenNameOptions(count),
+    staleTime: 0, // Always fetch fresh names
+    gcTime: 0, // Don't cache
+  });
+}
+
+// ============================================================================
+// MUTATION HOOKS
+// ============================================================================
+
+/**
+ * Hook to update user's screen name with optimistic updates
+ *
+ * Updates the user's screen name with immediate UI feedback via optimistic updates.
+ * Automatically rolls back on error and shows toast notifications.
+ *
+ * @returns React Query mutation for updating screen name
+ *
+ * @example
+ * ```tsx
+ * function ScreenNameSection({ profile }) {
+ *   const [selected, setSelected] = useState<string>();
+ *   const updateScreenName = useUpdateScreenName();
+ *
+ *   const handleSave = () => {
+ *     if (selected) {
+ *       updateScreenName.mutate(selected);
+ *     }
+ *   };
+ *
+ *   return (
+ *     <>
+ *       <ScreenNamePicker onSelect={setSelected} />
+ *       <Button onClick={handleSave} disabled={updateScreenName.isPending}>
+ *         Save
+ *       </Button>
+ *     </>
+ *   );
+ * }
+ * ```
+ */
+export function useUpdateScreenName() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: (newScreenName: string) => userProfileService.updateScreenName(newScreenName),
+
+    // Optimistic update
+    onMutate: async (newScreenName: string) => {
+      // Cancel outgoing refetches
+      await queryClient.cancelQueries({ queryKey: userProfileKeys.profile() });
+
+      // Snapshot previous value
+      const previousProfile = queryClient.getQueryData<UserProfile>(
+        userProfileKeys.profile()
+      );
+
+      // Optimistically update
+      if (previousProfile) {
+        queryClient.setQueryData<UserProfile>(
+          userProfileKeys.profile(),
+          {
+            ...previousProfile,
+            screenName: newScreenName,
+          }
+        );
+      }
+
+      return { previousProfile };
+    },
+
+    // Rollback on error
+    onError: (error, newScreenName, context) => {
+      if (context?.previousProfile) {
+        queryClient.setQueryData(
+          userProfileKeys.profile(),
+          context.previousProfile
+        );
+      }
+
+      toast({
+        title: 'Failed to Update Screen Name',
+        description: error instanceof Error ? error.message : 'Unknown error occurred',
+        variant: 'destructive',
+      });
+    },
+
+    // Success
+    onSuccess: (updatedProfile) => {
+      queryClient.setQueryData(
+        userProfileKeys.profile(),
+        updatedProfile
+      );
+
+      toast({
+        title: 'Screen Name Updated',
+        description: `Your screen name is now "${updatedProfile.screenName}"`,
+      });
+    },
+
+    // Always refetch after error or success
+    onSettled: () => {
+      queryClient.invalidateQueries({ queryKey: userProfileKeys.profile() });
+    },
+  });
+}
+
+/**
+ * Hook to validate screen name availability
+ *
+ * Checks if a screen name is available without updating the profile.
+ * Useful for real-time validation.
+ *
+ * @returns React Query mutation for validation
+ *
+ * @example
+ * ```tsx
+ * function ScreenNameValidator({ name }) {
+ *   const validateName = useValidateScreenName();
+ *
+ *   const handleCheck = async () => {
+ *     const isAvailable = await validateName.mutateAsync(name);
+ *     console.log(`${name} is ${isAvailable ? 'available' : 'taken'}`);
+ *   };
+ *
+ *   return <Button onClick={handleCheck}>Check Availability</Button>;
+ * }
+ * ```
+ */
+export function useValidateScreenName() {
+  return useMutation({
+    mutationFn: (screenName: string) => userProfileService.validateScreenNameAvailable(screenName),
+  });
+}
diff --git a/src/pages/Profile.tsx b/src/pages/Profile.tsx
new file mode 100644
index 0000000..d892dae
--- /dev/null
+++ b/src/pages/Profile.tsx
@@ -0,0 +1,39 @@
+/**
+ * Profile Page
+ *
+ * Main user profile page allowing users to view and update their screen name.
+ * Integrates ProfileHeader and ScreenNameSection components.
+ */
+
+import { useUserProfile } from '@/hooks/use-user-profile';
+import { ProfileHeader } from '@/components/profile/ProfileHeader';
+import { ScreenNameSection } from '@/components/profile/ScreenNameSection';
+import { ProfileSkeleton } from '@/components/profile/ProfileSkeleton';
+import { ProfileError } from '@/components/profile/ProfileError';
+import { Separator } from '@/components/ui/separator';
+
+export function Profile() {
+  const { data: profile, isLoading, error } = useUserProfile();
+
+  if (isLoading) {
+    return <ProfileSkeleton />;
+  }
+
+  if (error) {
+    return <ProfileError error={error as Error} />;
+  }
+
+  if (!profile) {
+    return <ProfileError error={new Error('Profile not found')} />;
+  }
+
+  return (
+    <div className="container mx-auto p-6 max-w-4xl">
+      <ProfileHeader profile={profile} />
+      <Separator className="my-6" />
+      <ScreenNameSection profile={profile} />
+    </div>
+  );
+}
+
+export default Profile;
diff --git a/src/services/user-profile-service.test.ts b/src/services/user-profile-service.test.ts
new file mode 100644
index 0000000..416c538
--- /dev/null
+++ b/src/services/user-profile-service.test.ts
@@ -0,0 +1,463 @@
+/**
+ * UserProfileService Tests
+ *
+ * Comprehensive test coverage for user profile operations including:
+ * - Profile retrieval
+ * - Screen name generation
+ * - Screen name updates
+ * - Screen name validation
+ * - Error handling
+ * - Data transformation (snake_case to camelCase)
+ */
+
+import { SupabaseClient } from '@supabase/supabase-js';
+import {
+  UserProfileService,
+  IUserProfileService,
+  UserProfile,
+  createUserProfileService,
+} from '@/services/user-profile-service';
+
+// ============================================================================
+// Mock Supabase Client
+// ============================================================================
+
+/**
+ * Create a mock Supabase client for testing
+ */
+function createMockSupabaseClient(): jest.Mocked<SupabaseClient> {
+  return {
+    auth: {
+      getUser: jest.fn(),
+    },
+    from: jest.fn(),
+    rpc: jest.fn(),
+  } as unknown as jest.Mocked<SupabaseClient>;
+}
+
+// ============================================================================
+// Test Suite
+// ============================================================================
+
+describe('UserProfileService', () => {
+  let service: IUserProfileService;
+  let mockSupabase: jest.Mocked<SupabaseClient>;
+
+  beforeEach(() => {
+    mockSupabase = createMockSupabaseClient();
+    service = new UserProfileService(mockSupabase);
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  // ==========================================================================
+  // Factory Function Tests
+  // ==========================================================================
+
+  describe('createUserProfileService', () => {
+    it('should create a UserProfileService instance', () => {
+      const instance = createUserProfileService(mockSupabase);
+      expect(instance).toBeInstanceOf(UserProfileService);
+    });
+
+    it('should implement IUserProfileService interface', () => {
+      const instance = createUserProfileService(mockSupabase);
+      expect(instance.getUserProfile).toBeDefined();
+      expect(instance.generateScreenNameOptions).toBeDefined();
+      expect(instance.updateScreenName).toBeDefined();
+      expect(instance.validateScreenNameAvailable).toBeDefined();
+    });
+  });
+
+  // ==========================================================================
+  // getUserProfile Tests
+  // ==========================================================================
+
+  describe('getUserProfile', () => {
+    it('should fetch user profile successfully', async () => {
+      const mockUserId = 'user-123';
+      const mockProfileRow = {
+        id: mockUserId,
+        screen_name: 'happy-panda-42',
+        avatar_url: null,
+        bio: null,
+        created_at: '2025-01-01T00:00:00Z',
+        updated_at: '2025-01-01T00:00:00Z',
+      };
+
+      // Mock auth.getUser
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: mockUserId } },
+        error: null,
+      });
+
+      // Mock from().select().eq().single()
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: mockProfileRow,
+        error: null,
+      });
+      const mockEq = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ select: mockSelect });
+
+      const result = await service.getUserProfile();
+
+      expect(result).toEqual({
+        id: mockUserId,
+        screenName: 'happy-panda-42',
+        avatarUrl: undefined,
+        bio: undefined,
+        createdAt: '2025-01-01T00:00:00Z',
+        modifiedAt: '2025-01-01T00:00:00Z',
+      });
+      expect(mockSupabase.from).toHaveBeenCalledWith('user_profiles');
+      expect(mockSelect).toHaveBeenCalledWith('*');
+      expect(mockEq).toHaveBeenCalledWith('id', mockUserId);
+    });
+
+    it('should transform snake_case DB fields to camelCase', async () => {
+      const mockProfileRow = {
+        id: 'user-456',
+        screen_name: 'clever-falcon-99',
+        avatar_url: 'https://example.com/avatar.jpg',
+        bio: 'Test bio',
+        created_at: '2025-02-01T00:00:00Z',
+        updated_at: '2025-02-02T00:00:00Z',
+      };
+
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: 'user-456' } },
+        error: null,
+      });
+
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: mockProfileRow,
+        error: null,
+      });
+      const mockEq = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ select: mockSelect });
+
+      const result = await service.getUserProfile();
+
+      expect(result.screenName).toBe('clever-falcon-99');
+      expect(result.avatarUrl).toBe('https://example.com/avatar.jpg');
+      expect(result.bio).toBe('Test bio');
+      expect(result.createdAt).toBe('2025-02-01T00:00:00Z');
+      expect(result.modifiedAt).toBe('2025-02-02T00:00:00Z');
+    });
+
+    it('should throw error when user not authenticated', async () => {
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: null },
+        error: new Error('Not authenticated'),
+      });
+
+      await expect(service.getUserProfile()).rejects.toThrow(
+        'User not authenticated. Please sign in to access profile.'
+      );
+    });
+
+    it('should throw error when profile not found', async () => {
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: 'user-789' } },
+        error: null,
+      });
+
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: null,
+        error: null,
+      });
+      const mockEq = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ select: mockSelect });
+
+      await expect(service.getUserProfile()).rejects.toThrow(
+        'User profile not found. Profile should exist for authenticated users.'
+      );
+    });
+
+    it('should throw error when database query fails', async () => {
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: 'user-123' } },
+        error: null,
+      });
+
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: null,
+        error: { message: 'Database connection failed' },
+      });
+      const mockEq = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ select: mockSelect });
+
+      await expect(service.getUserProfile()).rejects.toThrow(
+        'Failed to fetch user profile: Database connection failed'
+      );
+    });
+  });
+
+  // ==========================================================================
+  // generateScreenNameOptions Tests
+  // ==========================================================================
+
+  describe('generateScreenNameOptions', () => {
+    it('should generate 10 screen names by default', async () => {
+      const mockNames = Array.from({ length: 10 }, (_, i) => ({
+        screen_name: `test-name-${i}`,
+      }));
+
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: mockNames,
+        error: null,
+      });
+
+      const result = await service.generateScreenNameOptions();
+
+      expect(result).toHaveLength(10);
+      expect(result).toEqual([
+        'test-name-0',
+        'test-name-1',
+        'test-name-2',
+        'test-name-3',
+        'test-name-4',
+        'test-name-5',
+        'test-name-6',
+        'test-name-7',
+        'test-name-8',
+        'test-name-9',
+      ]);
+      expect(mockSupabase.rpc).toHaveBeenCalledWith('generate_screen_name_batch', {
+        count: 10,
+      });
+    });
+
+    it('should generate custom count of screen names', async () => {
+      const mockNames = Array.from({ length: 5 }, (_, i) => ({
+        screen_name: `custom-name-${i}`,
+      }));
+
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: mockNames,
+        error: null,
+      });
+
+      const result = await service.generateScreenNameOptions(5);
+
+      expect(result).toHaveLength(5);
+      expect(mockSupabase.rpc).toHaveBeenCalledWith('generate_screen_name_batch', {
+        count: 5,
+      });
+    });
+
+    it('should throw error when generation fails', async () => {
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: null,
+        error: { message: 'Generation failed' },
+      });
+
+      await expect(service.generateScreenNameOptions()).rejects.toThrow(
+        'Failed to generate screen name options: Generation failed'
+      );
+    });
+
+    it('should throw error when no names generated', async () => {
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: [],
+        error: null,
+      });
+
+      await expect(service.generateScreenNameOptions()).rejects.toThrow(
+        'Failed to generate screen name options. Please try again.'
+      );
+    });
+
+    it('should throw error when data is null', async () => {
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: null,
+        error: null,
+      });
+
+      await expect(service.generateScreenNameOptions()).rejects.toThrow(
+        'Failed to generate screen name options. Please try again.'
+      );
+    });
+  });
+
+  // ==========================================================================
+  // updateScreenName Tests
+  // ==========================================================================
+
+  describe('updateScreenName', () => {
+    it('should update screen name when available', async () => {
+      const mockUserId = 'user-123';
+      const newScreenName = 'cool-cat-99';
+      const updatedProfile = {
+        id: mockUserId,
+        screen_name: newScreenName,
+        avatar_url: null,
+        bio: null,
+        created_at: '2025-01-01T00:00:00Z',
+        updated_at: '2025-01-02T00:00:00Z',
+      };
+
+      // Mock auth.getUser
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: mockUserId } },
+        error: null,
+      });
+
+      // Mock availability check (rpc)
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: true,
+        error: null,
+      });
+
+      // Mock update query
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: updatedProfile,
+        error: null,
+      });
+      const mockSelect = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockEq = jest.fn().mockReturnValue({ select: mockSelect });
+      const mockUpdate = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ update: mockUpdate });
+
+      const result = await service.updateScreenName(newScreenName);
+
+      expect(result.screenName).toBe(newScreenName);
+      expect(mockSupabase.rpc).toHaveBeenCalledWith('validate_screen_name_available', {
+        name: newScreenName,
+      });
+      expect(mockUpdate).toHaveBeenCalledWith({ screen_name: newScreenName });
+      expect(mockEq).toHaveBeenCalledWith('id', mockUserId);
+    });
+
+    it('should throw error when name is already taken', async () => {
+      const takenName = 'taken-name-123';
+
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: 'user-456' } },
+        error: null,
+      });
+
+      // Mock availability check returning false
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: false,
+        error: null,
+      });
+
+      await expect(service.updateScreenName(takenName)).rejects.toThrow(
+        `Screen name "${takenName}" is already taken. Please choose another.`
+      );
+    });
+
+    it('should throw error when user not authenticated', async () => {
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: null },
+        error: new Error('Not authenticated'),
+      });
+
+      await expect(service.updateScreenName('new-name')).rejects.toThrow(
+        'User not authenticated. Please sign in to access profile.'
+      );
+    });
+
+    it('should throw error when update fails', async () => {
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: 'user-789' } },
+        error: null,
+      });
+
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: true,
+        error: null,
+      });
+
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: null,
+        error: { message: 'Update failed' },
+      });
+      const mockSelect = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockEq = jest.fn().mockReturnValue({ select: mockSelect });
+      const mockUpdate = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ update: mockUpdate });
+
+      await expect(service.updateScreenName('new-name')).rejects.toThrow(
+        'Failed to update screen name: Update failed'
+      );
+    });
+
+    it('should throw error when no data returned after update', async () => {
+      (mockSupabase.auth.getUser as jest.Mock).mockResolvedValue({
+        data: { user: { id: 'user-999' } },
+        error: null,
+      });
+
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: true,
+        error: null,
+      });
+
+      const mockSingle = jest.fn().mockResolvedValue({
+        data: null,
+        error: null,
+      });
+      const mockSelect = jest.fn().mockReturnValue({ single: mockSingle });
+      const mockEq = jest.fn().mockReturnValue({ select: mockSelect });
+      const mockUpdate = jest.fn().mockReturnValue({ eq: mockEq });
+      (mockSupabase.from as jest.Mock).mockReturnValue({ update: mockUpdate });
+
+      await expect(service.updateScreenName('new-name')).rejects.toThrow(
+        'Failed to update screen name. No data returned from database.'
+      );
+    });
+  });
+
+  // ==========================================================================
+  // validateScreenNameAvailable Tests
+  // ==========================================================================
+
+  describe('validateScreenNameAvailable', () => {
+    it('should return true when name is available', async () => {
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: true,
+        error: null,
+      });
+
+      const result = await service.validateScreenNameAvailable('available-name');
+
+      expect(result).toBe(true);
+      expect(mockSupabase.rpc).toHaveBeenCalledWith('validate_screen_name_available', {
+        name: 'available-name',
+      });
+    });
+
+    it('should return false when name is taken', async () => {
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: false,
+        error: null,
+      });
+
+      const result = await service.validateScreenNameAvailable('taken-name');
+
+      expect(result).toBe(false);
+      expect(mockSupabase.rpc).toHaveBeenCalledWith('validate_screen_name_available', {
+        name: 'taken-name',
+      });
+    });
+
+    it('should throw error when validation fails', async () => {
+      (mockSupabase.rpc as jest.Mock).mockResolvedValue({
+        data: null,
+        error: { message: 'Validation error' },
+      });
+
+      await expect(service.validateScreenNameAvailable('test-name')).rejects.toThrow(
+        'Failed to validate screen name: Validation error'
+      );
+    });
+  });
+});
diff --git a/src/services/user-profile-service.ts b/src/services/user-profile-service.ts
new file mode 100644
index 0000000..7916ffa
--- /dev/null
+++ b/src/services/user-profile-service.ts
@@ -0,0 +1,243 @@
+/**
+ * UserProfileService - Interface-first service for user profile operations
+ *
+ * This service handles user profile management including screen name selection
+ * and updates. Uses dependency injection for the Supabase client.
+ *
+ * @module services/user-profile-service
+ */
+
+import { SupabaseClient } from '@supabase/supabase-js';
+
+// ============================================================================
+// Type Definitions
+// ============================================================================
+
+/**
+ * User profile data
+ */
+export interface UserProfile {
+  id: string;
+  screenName: string;
+  avatarUrl?: string;
+  bio?: string;
+  createdAt: string;
+  modifiedAt: string;
+}
+
+/**
+ * Database row type (snake_case from PostgreSQL)
+ */
+interface UserProfileRow {
+  id: string;
+  screen_name: string;
+  avatar_url: string | null;
+  bio: string | null;
+  created_at: string;
+  updated_at: string;
+}
+
+// ============================================================================
+// Service Interface
+// ============================================================================
+
+/**
+ * Interface for user profile operations
+ */
+export interface IUserProfileService {
+  /**
+   * Get the current user's profile
+   */
+  getUserProfile(): Promise<UserProfile>;
+
+  /**
+   * Generate multiple screen name options
+   *
+   * @param count Number of options to generate (default: 10)
+   * @returns Array of available screen names
+   */
+  generateScreenNameOptions(count?: number): Promise<string[]>;
+
+  /**
+   * Update the user's screen name
+   *
+   * @param newScreenName The new screen name to set
+   * @throws Error if screen name is already taken
+   */
+  updateScreenName(newScreenName: string): Promise<UserProfile>;
+
+  /**
+   * Validate that a screen name is available
+   *
+   * @param screenName Screen name to validate
+   * @returns true if available, false if taken
+   */
+  validateScreenNameAvailable(screenName: string): Promise<boolean>;
+}
+
+// ============================================================================
+// Service Implementation
+// ============================================================================
+
+/**
+ * UserProfileService implementation using Supabase
+ */
+export class UserProfileService implements IUserProfileService {
+  /**
+   * Supabase client injected via constructor
+   */
+  private readonly supabase: SupabaseClient;
+
+  /**
+   * Create a new UserProfileService
+   *
+   * @param supabase - Supabase client instance
+   */
+  constructor(supabase: SupabaseClient) {
+    this.supabase = supabase;
+  }
+
+  /**
+   * Get current user ID from session
+   *
+   * @returns User ID
+   * @throws Error if user is not authenticated
+   */
+  private async getCurrentUserId(): Promise<string> {
+    const {
+      data: { user },
+      error,
+    } = await this.supabase.auth.getUser();
+
+    if (error || !user) {
+      throw new Error('User not authenticated. Please sign in to access profile.');
+    }
+
+    return user.id;
+  }
+
+  /**
+   * Convert database row to UserProfile
+   *
+   * @param row - Database row from Supabase
+   * @returns UserProfile object
+   */
+  private toUserProfile(row: UserProfileRow): UserProfile {
+    return {
+      id: row.id,
+      screenName: row.screen_name,
+      avatarUrl: row.avatar_url || undefined,
+      bio: row.bio || undefined,
+      createdAt: row.created_at,
+      modifiedAt: row.updated_at,
+    };
+  }
+
+  /**
+   * Get the current user's profile
+   */
+  async getUserProfile(): Promise<UserProfile> {
+    const userId = await this.getCurrentUserId();
+
+    const { data, error } = await this.supabase
+      .from('user_profiles')
+      .select('*')
+      .eq('id', userId)
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to fetch user profile: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('User profile not found. Profile should exist for authenticated users.');
+    }
+
+    return this.toUserProfile(data as UserProfileRow);
+  }
+
+  /**
+   * Generate multiple screen name options
+   *
+   * @param count Number of options to generate (default: 10)
+   * @returns Array of available screen names
+   */
+  async generateScreenNameOptions(count: number = 10): Promise<string[]> {
+    const { data, error } = await this.supabase
+      .rpc('generate_screen_name_batch', { count });
+
+    if (error) {
+      throw new Error(`Failed to generate screen name options: ${error.message}`);
+    }
+
+    if (!data || data.length === 0) {
+      throw new Error('Failed to generate screen name options. Please try again.');
+    }
+
+    return data.map((row: { screen_name: string }) => row.screen_name);
+  }
+
+  /**
+   * Update the user's screen name
+   *
+   * @param newScreenName The new screen name to set
+   * @throws Error if screen name is already taken
+   */
+  async updateScreenName(newScreenName: string): Promise<UserProfile> {
+    const userId = await this.getCurrentUserId();
+
+    // Validate screen name is available
+    const isAvailable = await this.validateScreenNameAvailable(newScreenName);
+    if (!isAvailable) {
+      throw new Error(`Screen name "${newScreenName}" is already taken. Please choose another.`);
+    }
+
+    const { data, error } = await this.supabase
+      .from('user_profiles')
+      .update({ screen_name: newScreenName })
+      .eq('id', userId)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to update screen name: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('Failed to update screen name. No data returned from database.');
+    }
+
+    return this.toUserProfile(data as UserProfileRow);
+  }
+
+  /**
+   * Validate that a screen name is available
+   *
+   * @param screenName Screen name to validate
+   * @returns true if available, false if taken
+   */
+  async validateScreenNameAvailable(screenName: string): Promise<boolean> {
+    const { data, error } = await this.supabase
+      .rpc('validate_screen_name_available', { name: screenName });
+
+    if (error) {
+      throw new Error(`Failed to validate screen name: ${error.message}`);
+    }
+
+    return data === true;
+  }
+}
+
+// ============================================================================
+// Factory Function
+// ============================================================================
+
+/**
+ * Create a UserProfileService instance
+ *
+ * @param supabase - Supabase client instance
+ * @returns UserProfileService instance
+ */
+export function createUserProfileService(supabase: SupabaseClient): IUserProfileService {
+  return new UserProfileService(supabase);
+}
diff --git a/supabase/migrations/20251009160000_generate_screen_name_batch.sql b/supabase/migrations/20251009160000_generate_screen_name_batch.sql
new file mode 100644
index 0000000..4586e13
--- /dev/null
+++ b/supabase/migrations/20251009160000_generate_screen_name_batch.sql
@@ -0,0 +1,32 @@
+-- Migration: 20251009160000_generate_screen_name_batch.sql
+-- Description: Create function to generate batches of unique screen names
+-- Created: 2025-10-09
+
+CREATE OR REPLACE FUNCTION generate_screen_name_batch(count INTEGER DEFAULT 10)
+RETURNS TABLE(screen_name TEXT) AS $$
+DECLARE
+  max_attempts INT := count * 5; -- Allow up to 5x attempts
+  attempts INT := 0;
+  generated_name TEXT;
+  names TEXT[] := '{}';
+BEGIN
+  -- Generate unique screen names
+  WHILE array_length(names, 1) IS NULL OR array_length(names, 1) < count AND attempts < max_attempts LOOP
+    attempts := attempts + 1;
+    generated_name := generate_friendly_screenname();
+
+    -- Check if name is unique (not in existing profiles and not in our batch)
+    IF NOT EXISTS (
+      SELECT 1 FROM user_profiles WHERE user_profiles.screen_name = generated_name
+    ) AND NOT (generated_name = ANY(names)) THEN
+      names := array_append(names, generated_name);
+    END IF;
+  END LOOP;
+
+  -- Return the generated names
+  RETURN QUERY SELECT unnest(names);
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION generate_screen_name_batch(INTEGER) IS
+  'Generates a batch of unique friendly screen names for user selection';
diff --git a/supabase/migrations/20251009160000_profile_batch_functions.sql b/supabase/migrations/20251009160000_profile_batch_functions.sql
new file mode 100644
index 0000000..6309960
--- /dev/null
+++ b/supabase/migrations/20251009160000_profile_batch_functions.sql
@@ -0,0 +1,59 @@
+-- ============================================================================
+-- PROFILE SCREEN NAME BATCH GENERATION AND VALIDATION
+-- Adds batch generation and validation functions for user profile screen names
+-- ============================================================================
+
+-- Function to generate a batch of unique screen names
+CREATE OR REPLACE FUNCTION generate_screen_name_batch(count INTEGER DEFAULT 10)
+RETURNS TABLE(screen_name TEXT) AS $$
+DECLARE
+  max_attempts INT := count * 5; -- Allow up to 5x attempts
+  attempts INT := 0;
+  generated_name TEXT;
+  names TEXT[] := '{}';
+BEGIN
+  -- Generate unique screen names
+  WHILE array_length(names, 1) < count AND attempts < max_attempts LOOP
+    attempts := attempts + 1;
+    generated_name := generate_friendly_screenname();
+
+    -- Check if name is unique (not in existing profiles and not in our batch)
+    IF NOT EXISTS (
+      SELECT 1 FROM user_profiles WHERE user_profiles.screen_name = generated_name
+    ) AND NOT (generated_name = ANY(names)) THEN
+      names := array_append(names, generated_name);
+    END IF;
+  END LOOP;
+
+  -- Return the generated names
+  RETURN QUERY SELECT unnest(names);
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION generate_screen_name_batch(INTEGER) IS
+  'Generates a batch of unique friendly screen names for user selection';
+
+-- Function to validate that a screen name is available
+CREATE OR REPLACE FUNCTION validate_screen_name_available(name TEXT)
+RETURNS BOOLEAN AS $$
+BEGIN
+  RETURN NOT EXISTS (
+    SELECT 1 FROM user_profiles WHERE screen_name = name
+  );
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION validate_screen_name_available(TEXT) IS
+  'Checks if a screen name is available (not already taken)';
+
+-- Add RLS policies for profile updates
+CREATE POLICY IF NOT EXISTS "Users can read own profile"
+  ON user_profiles
+  FOR SELECT
+  USING (auth.uid() = id);
+
+CREATE POLICY IF NOT EXISTS "Users can update own profile"
+  ON user_profiles
+  FOR UPDATE
+  USING (auth.uid() = id)
+  WITH CHECK (auth.uid() = id);
diff --git a/supabase/migrations/20251009160100_validate_screen_name_available.sql b/supabase/migrations/20251009160100_validate_screen_name_available.sql
new file mode 100644
index 0000000..cfbd5f2
--- /dev/null
+++ b/supabase/migrations/20251009160100_validate_screen_name_available.sql
@@ -0,0 +1,15 @@
+-- Migration: 20251009160100_validate_screen_name_available.sql
+-- Description: Create function to validate screen name availability
+-- Created: 2025-10-09
+
+CREATE OR REPLACE FUNCTION validate_screen_name_available(name TEXT)
+RETURNS BOOLEAN AS $$
+BEGIN
+  RETURN NOT EXISTS (
+    SELECT 1 FROM user_profiles WHERE screen_name = name
+  );
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION validate_screen_name_available(TEXT) IS
+  'Checks if a screen name is available (not already taken)';
diff --git a/supabase/migrations/20251009160200_profile_update_policy.sql b/supabase/migrations/20251009160200_profile_update_policy.sql
new file mode 100644
index 0000000..6c5c3ae
--- /dev/null
+++ b/supabase/migrations/20251009160200_profile_update_policy.sql
@@ -0,0 +1,26 @@
+-- Migration: 20251009160200_profile_update_policy.sql
+-- Description: Add RLS policies for profile updates
+-- Created: 2025-10-09
+
+-- Drop existing policies if they exist to avoid conflicts
+DROP POLICY IF EXISTS "Users can update own profile" ON user_profiles;
+DROP POLICY IF EXISTS "Users can read own profile" ON user_profiles;
+
+-- Allow users to update their own profile
+CREATE POLICY "Users can update own profile"
+  ON user_profiles
+  FOR UPDATE
+  USING (auth.uid() = id)
+  WITH CHECK (auth.uid() = id);
+
+COMMENT ON POLICY "Users can update own profile" ON user_profiles IS
+  'Allows users to update only their own profile';
+
+-- Allow users to read their own profile
+CREATE POLICY "Users can read own profile"
+  ON user_profiles
+  FOR SELECT
+  USING (auth.uid() = id);
+
+COMMENT ON POLICY "Users can read own profile" ON user_profiles IS
+  'Allows users to read their own profile (in addition to public visibility)';


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(profile): add user profile page with screen name selection

