<!-- Generated by SpecStory -->

# Authentication UI Components for React App (2025-10-08 16:21:20Z)

<!-- Claude Code Session e95faaca-110f-4a3c-9804-6b7825def361 (2025-10-08_16-21-20Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/docs/1.0/cloud-storage/implementation/workplan.md b/docs/1.0/cloud-storage/implementation/workplan.md
new file mode 100644
index 0000000..97f8e1c
--- /dev/null
+++ b/docs/1.0/cloud-storage/implementation/workplan.md
@@ -0,0 +1,2429 @@
+# Cloud Storage & Sharing Implementation Workplan
+
+**Version:** 1.0
+**Date:** 2025-10-08
+**Status:** Planning
+**Prerequisites:** Authentication COMPLETE (Google OAuth via Supabase)
+
+## Table of Contents
+
+1. [Overview](#1-overview)
+2. [Architecture](#2-architecture)
+3. [Database Schema](#3-database-schema)
+4. [Storage Design](#4-storage-design)
+5. [API Design](#5-api-design)
+6. [Security Model](#6-security-model)
+7. [TypeScript Types](#7-typescript-types)
+8. [Implementation Steps](#8-implementation-steps)
+9. [Timeline Estimate](#9-timeline-estimate)
+10. [Testing Strategy](#10-testing-strategy)
+11. [Acceptance Criteria](#11-acceptance-criteria)
+12. [Appendices](#appendices)
+
+---
+
+## 1. Overview
+
+### 1.1 Feature Summary
+
+This feature enables users to:
+- Save custom MIDI controller modes to the cloud
+- Load their modes from any device (cross-device sync)
+- Share modes publicly to a global catalog
+- Browse and download community-created modes
+- Fork and remix existing modes
+- Engage with modes (likes, ratings, comments)
+
+### 1.2 Technical Approach
+
+**Backend:** Supabase (PostgreSQL + RLS + Storage)
+**Frontend:** React + TanStack Query + existing AuthContext
+**Deployment:** Netlify (frontend) + Supabase (backend)
+
+### 1.3 Key Design Decisions
+
+1. **Direct Supabase Integration:** No custom backend needed - use Supabase client directly with RLS policies
+2. **Netlify Functions:** Only for complex operations (webhooks, analytics, external API calls)
+3. **Mode Storage:** PostgreSQL JSONB for mode data (flexible, queryable)
+4. **File Storage:** Supabase Storage for thumbnails/attachments (future)
+5. **Search:** PostgreSQL full-text search + GIN indexes
+6. **Real-time:** Supabase real-time subscriptions for live updates (future)
+
+---
+
+## 2. Architecture
+
+### 2.1 System Architecture
+
+```
+┌─────────────────────────────────────────────────────────────────┐
+│                         Client (React SPA)                      │
+│  ┌─────────────────────────────────────────────────────────┐   │
+│  │  Pages:  Catalog | Library | Editor | Mode Detail       │   │
+│  └─────────────────────────────────────────────────────────┘   │
+│  ┌─────────────────────────────────────────────────────────┐   │
+│  │  Hooks:  useCloudModes | useUserModes | useLikeMode     │   │
+│  └─────────────────────────────────────────────────────────┘   │
+│  ┌─────────────────────────────────────────────────────────┐   │
+│  │  Services:  CloudModeService | SyncManager              │   │
+│  └─────────────────────────────────────────────────────────┘   │
+│  ┌─────────────────────────────────────────────────────────┐   │
+│  │  Context:  AuthContext (existing)                        │   │
+│  └─────────────────────────────────────────────────────────┘   │
+└─────────────────────────────────────────────────────────────────┘
+                              │
+                              │ HTTPS (Supabase Client)
+                              ▼
+┌─────────────────────────────────────────────────────────────────┐
+│                    Supabase Backend                             │
+│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐      │
+│  │  PostgreSQL   │  │  Supabase     │  │  Supabase     │      │
+│  │  + RLS        │  │  Auth         │  │  Storage      │      │
+│  │               │  │  (OAuth)      │  │  (future)     │      │
+│  └───────────────┘  └───────────────┘  └───────────────┘      │
+│                                                                  │
+│  Tables: modes, mode_likes, mode_ratings, mode_versions        │
+│  RLS: User ownership + Public catalog policies                 │
+└─────────────────────────────────────────────────────────────────┘
+                              │
+                              │ (Optional - future)
+                              ▼
+┌─────────────────────────────────────────────────────────────────┐
+│                    Netlify Functions (optional)                  │
+│  - Analytics processing                                          │
+│  - Webhook handlers                                              │
+│  - Complex data transformations                                  │
+└─────────────────────────────────────────────────────────────────┘
+```
+
+### 2.2 Data Flow
+
+#### Create/Update Mode
+
+```
+User Editor → CloudModeService.uploadMode()
+           → Supabase client (direct)
+           → PostgreSQL INSERT/UPDATE
+           → RLS policy validates auth.uid() = author_id
+           → Return CloudMode
+           → React Query cache update
+           → UI refresh
+```
+
+#### Browse Public Catalog
+
+```
+User Catalog → usePublicModes()
+            → CloudModeService.browseModes({ isPublic: true })
+            → Supabase client (direct query)
+            → PostgreSQL SELECT with RLS (public modes only)
+            → Return CloudMode[]
+            → React Query cache
+            → Render mode cards
+```
+
+#### Like/Rate Mode
+
+```
+User clicks Like → useLikeMode.mutate(modeId)
+                 → CloudModeService.likeMode(modeId)
+                 → Supabase INSERT into mode_likes
+                 → Supabase UPDATE modes.likes += 1
+                 → RLS validates user authenticated
+                 → Optimistic UI update
+                 → Background sync
+```
+
+### 2.3 Offline/Sync Strategy
+
+**Phase 1 (MVP):** Online-only
+- All operations require internet connection
+- Show loading states and error messages
+- Local state via React Query cache (5-minute stale time)
+
+**Phase 2 (Future):** Offline-first with sync
+- Local IndexedDB storage for modes
+- Queue operations when offline
+- Sync on reconnect with conflict resolution
+- Background sync service worker
+
+---
+
+## 3. Database Schema
+
+### 3.1 PostgreSQL Tables
+
+```sql
+-- Users table (already exists from auth)
+-- Extended via Supabase Auth + user_metadata
+
+-- Modes table (core storage)
+CREATE TABLE modes (
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
+
+  -- Mode metadata
+  name VARCHAR(255) NOT NULL,
+  description TEXT,
+  version VARCHAR(20) NOT NULL DEFAULT '1.0.0',
+
+  -- Mode data (JSONB for flexibility)
+  controls JSONB NOT NULL DEFAULT '{}'::jsonb,
+
+  -- Visibility
+  is_public BOOLEAN NOT NULL DEFAULT false,
+  is_official BOOLEAN NOT NULL DEFAULT false,
+  is_featured BOOLEAN NOT NULL DEFAULT false,
+
+  -- Engagement metrics (denormalized for performance)
+  downloads INTEGER NOT NULL DEFAULT 0,
+  likes INTEGER NOT NULL DEFAULT 0,
+  views INTEGER NOT NULL DEFAULT 0,
+  fork_count INTEGER NOT NULL DEFAULT 0,
+  rating DECIMAL(3,2) DEFAULT 0 CHECK (rating >= 0 AND rating <= 5),
+  rating_count INTEGER NOT NULL DEFAULT 0,
+
+  -- Discovery
+  tags TEXT[] DEFAULT '{}',
+  category VARCHAR(100),
+  thumbnail TEXT, -- Base64 or URL (future: Supabase Storage)
+
+  -- Relationships
+  parent_mode_id UUID REFERENCES modes(id) ON DELETE SET NULL,
+
+  -- Timestamps
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  modified_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  published_at TIMESTAMPTZ,
+
+  -- Indexes
+  CONSTRAINT valid_rating CHECK (rating >= 0 AND rating <= 5),
+  CONSTRAINT valid_version CHECK (version ~ '^\d+\.\d+\.\d+$')
+);
+
+-- Indexes for performance
+CREATE INDEX idx_modes_author ON modes(author_id);
+CREATE INDEX idx_modes_public ON modes(is_public) WHERE is_public = true;
+CREATE INDEX idx_modes_featured ON modes(is_featured) WHERE is_featured = true;
+CREATE INDEX idx_modes_category ON modes(category);
+CREATE INDEX idx_modes_tags ON modes USING GIN(tags);
+CREATE INDEX idx_modes_created ON modes(created_at DESC);
+CREATE INDEX idx_modes_downloads ON modes(downloads DESC);
+CREATE INDEX idx_modes_likes ON modes(likes DESC);
+CREATE INDEX idx_modes_rating ON modes(rating DESC);
+
+-- Full-text search index
+CREATE INDEX idx_modes_search ON modes USING GIN(
+  to_tsvector('english', name || ' ' || COALESCE(description, ''))
+);
+
+-- Mode likes (many-to-many)
+CREATE TABLE mode_likes (
+  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
+  mode_id UUID NOT NULL REFERENCES modes(id) ON DELETE CASCADE,
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+  PRIMARY KEY (user_id, mode_id)
+);
+
+CREATE INDEX idx_mode_likes_mode ON mode_likes(mode_id);
+CREATE INDEX idx_mode_likes_user ON mode_likes(user_id);
+
+-- Mode ratings (one per user per mode)
+CREATE TABLE mode_ratings (
+  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
+  mode_id UUID NOT NULL REFERENCES modes(id) ON DELETE CASCADE,
+  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
+  review TEXT,
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+  PRIMARY KEY (user_id, mode_id)
+);
+
+CREATE INDEX idx_mode_ratings_mode ON mode_ratings(mode_id);
+
+-- Mode versions (version history)
+CREATE TABLE mode_versions (
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  mode_id UUID NOT NULL REFERENCES modes(id) ON DELETE CASCADE,
+  version VARCHAR(20) NOT NULL,
+  changes TEXT,
+  controls JSONB NOT NULL,
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+  UNIQUE(mode_id, version)
+);
+
+CREATE INDEX idx_mode_versions_mode ON mode_versions(mode_id, created_at DESC);
+
+-- Categories (predefined)
+CREATE TABLE categories (
+  id VARCHAR(100) PRIMARY KEY,
+  name VARCHAR(100) NOT NULL,
+  description TEXT,
+  icon VARCHAR(50),
+  display_order INTEGER NOT NULL DEFAULT 0,
+
+  UNIQUE(name)
+);
+
+-- Insert default categories
+INSERT INTO categories (id, name, description, display_order) VALUES
+  ('daw-control', 'DAW Control', 'Digital Audio Workstation control surfaces', 1),
+  ('live-performance', 'Live Performance', 'Setups for live shows and DJing', 2),
+  ('mixing-mastering', 'Mixing & Mastering', 'Studio mixing and mastering workflows', 3),
+  ('instrument-control', 'Instrument Control', 'Hardware synth and instrument mappings', 4),
+  ('genre-specific', 'Genre-Specific', 'Genre-optimized configurations', 5),
+  ('educational', 'Educational', 'Learning and tutorial modes', 6);
+
+-- Triggers for updated_at
+CREATE OR REPLACE FUNCTION update_modified_at()
+RETURNS TRIGGER AS $$
+BEGIN
+  NEW.modified_at = NOW();
+  RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE TRIGGER modes_modified_at
+  BEFORE UPDATE ON modes
+  FOR EACH ROW
+  EXECUTE FUNCTION update_modified_at();
+
+CREATE TRIGGER mode_ratings_updated_at
+  BEFORE UPDATE ON mode_ratings
+  FOR EACH ROW
+  EXECUTE FUNCTION update_modified_at();
+
+-- Function to update mode rating aggregate
+CREATE OR REPLACE FUNCTION update_mode_rating()
+RETURNS TRIGGER AS $$
+BEGIN
+  UPDATE modes
+  SET
+    rating = (SELECT AVG(rating)::DECIMAL(3,2) FROM mode_ratings WHERE mode_id = NEW.mode_id),
+    rating_count = (SELECT COUNT(*) FROM mode_ratings WHERE mode_id = NEW.mode_id)
+  WHERE id = NEW.mode_id;
+  RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE TRIGGER mode_ratings_update_aggregate
+  AFTER INSERT OR UPDATE OR DELETE ON mode_ratings
+  FOR EACH ROW
+  EXECUTE FUNCTION update_mode_rating();
+```
+
+### 3.2 Row-Level Security Policies
+
+```sql
+-- Enable RLS on all tables
+ALTER TABLE modes ENABLE ROW LEVEL SECURITY;
+ALTER TABLE mode_likes ENABLE ROW LEVEL SECURITY;
+ALTER TABLE mode_ratings ENABLE ROW LEVEL SECURITY;
+ALTER TABLE mode_versions ENABLE ROW LEVEL SECURITY;
+
+-- Modes policies
+-- Anyone can view public modes
+CREATE POLICY "Public modes are viewable by everyone"
+  ON modes FOR SELECT
+  USING (is_public = true);
+
+-- Users can view their own modes (public or private)
+CREATE POLICY "Users can view own modes"
+  ON modes FOR SELECT
+  USING (auth.uid() = author_id);
+
+-- Users can create modes (author_id must match auth.uid())
+CREATE POLICY "Users can create modes"
+  ON modes FOR INSERT
+  WITH CHECK (auth.uid() = author_id);
+
+-- Users can update their own modes
+CREATE POLICY "Users can update own modes"
+  ON modes FOR UPDATE
+  USING (auth.uid() = author_id)
+  WITH CHECK (auth.uid() = author_id);
+
+-- Users can delete their own modes
+CREATE POLICY "Users can delete own modes"
+  ON modes FOR DELETE
+  USING (auth.uid() = author_id);
+
+-- Admins can do everything (optional - requires custom JWT claims)
+CREATE POLICY "Admins have full access to modes"
+  ON modes
+  USING (
+    (auth.jwt() ->> 'user_role')::text = 'admin'
+  );
+
+-- Mode likes policies
+-- Anyone can view likes on public modes
+CREATE POLICY "Public mode likes are viewable"
+  ON mode_likes FOR SELECT
+  USING (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_likes.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+-- Users can view their own likes
+CREATE POLICY "Users can view own likes"
+  ON mode_likes FOR SELECT
+  USING (auth.uid() = user_id);
+
+-- Authenticated users can like modes
+CREATE POLICY "Authenticated users can like modes"
+  ON mode_likes FOR INSERT
+  WITH CHECK (
+    auth.uid() = user_id
+    AND EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_likes.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+-- Users can unlike modes they liked
+CREATE POLICY "Users can unlike modes"
+  ON mode_likes FOR DELETE
+  USING (auth.uid() = user_id);
+
+-- Mode ratings policies
+-- Anyone can view ratings on public modes
+CREATE POLICY "Public mode ratings are viewable"
+  ON mode_ratings FOR SELECT
+  USING (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_ratings.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+-- Users can view their own ratings
+CREATE POLICY "Users can view own ratings"
+  ON mode_ratings FOR SELECT
+  USING (auth.uid() = user_id);
+
+-- Authenticated users can rate modes
+CREATE POLICY "Authenticated users can rate modes"
+  ON mode_ratings FOR INSERT
+  WITH CHECK (
+    auth.uid() = user_id
+    AND EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_ratings.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+-- Users can update their own ratings
+CREATE POLICY "Users can update own ratings"
+  ON mode_ratings FOR UPDATE
+  USING (auth.uid() = user_id)
+  WITH CHECK (auth.uid() = user_id);
+
+-- Users can delete their own ratings
+CREATE POLICY "Users can delete own ratings"
+  ON mode_ratings FOR DELETE
+  USING (auth.uid() = user_id);
+
+-- Mode versions policies
+-- Users can view versions of modes they can access
+CREATE POLICY "Users can view accessible mode versions"
+  ON mode_versions FOR SELECT
+  USING (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_versions.mode_id
+      AND (modes.is_public = true OR modes.author_id = auth.uid())
+    )
+  );
+
+-- Only mode authors can create versions
+CREATE POLICY "Authors can create mode versions"
+  ON mode_versions FOR INSERT
+  WITH CHECK (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_versions.mode_id
+      AND modes.author_id = auth.uid()
+    )
+  );
+
+-- Categories are public (read-only)
+-- No RLS needed - all users can read, only admins can modify via Supabase dashboard
+```
+
+---
+
+## 4. Storage Design
+
+### 4.1 Mode Data Storage
+
+**Primary Storage:** PostgreSQL JSONB column
+- Flexible schema for mode controls
+- Queryable with PostgreSQL JSON operators
+- Versioned via `mode_versions` table
+- No size limit concerns (typical mode < 50KB)
+
+**Example JSONB structure:**
+```json
+{
+  "control_1": {
+    "id": "control_1",
+    "type": "knob",
+    "ccNumber": 21,
+    "midiChannel": 1,
+    "minValue": 0,
+    "maxValue": 127,
+    "label": "Volume"
+  },
+  "control_2": {
+    "id": "control_2",
+    "type": "fader",
+    "ccNumber": 22,
+    "midiChannel": 1,
+    "minValue": 0,
+    "maxValue": 127,
+    "label": "Pan"
+  }
+}
+```
+
+### 4.2 File Storage (Future - Phase 2)
+
+**Supabase Storage Buckets:**
+- `mode-thumbnails`: Mode preview images (1MB limit per file)
+- `mode-attachments`: Documentation, PDFs, etc. (10MB limit per file)
+
+**Storage Policies:**
+```sql
+-- Public read access to thumbnails of public modes
+CREATE POLICY "Public mode thumbnails are accessible"
+  ON storage.objects FOR SELECT
+  USING (bucket_id = 'mode-thumbnails' AND storage.foldername(name)[1] IN (
+    SELECT id::text FROM modes WHERE is_public = true
+  ));
+
+-- Users can upload their own mode thumbnails
+CREATE POLICY "Users can upload mode thumbnails"
+  ON storage.objects FOR INSERT
+  WITH CHECK (
+    bucket_id = 'mode-thumbnails'
+    AND auth.uid()::text = storage.foldername(name)[1]
+  );
+```
+
+### 4.3 Caching Strategy
+
+**React Query Cache:**
+- Public modes: 5 minute stale time
+- User modes: 1 minute stale time
+- Mode details: 5 minute stale time
+- Categories: 1 hour stale time (rarely change)
+
+**Database Query Cache:**
+- PostgreSQL query planner handles caching automatically
+- Materialized views for expensive aggregations (future)
+
+---
+
+## 5. API Design
+
+### 5.1 Supabase Client Queries
+
+All operations use Supabase client directly - no custom REST API needed.
+
+```typescript
+// Browse public modes with filters
+const { data, error } = await supabase
+  .from('modes')
+  .select(`
+    *,
+    author:author_id (
+      id,
+      email,
+      user_metadata
+    ),
+    user_liked:mode_likes!left (
+      user_id
+    )
+  `)
+  .eq('is_public', true)
+  .order('created_at', { ascending: false })
+  .limit(20);
+
+// Get user's modes
+const { data, error } = await supabase
+  .from('modes')
+  .select('*')
+  .eq('author_id', userId);
+
+// Create mode
+const { data, error } = await supabase
+  .from('modes')
+  .insert({
+    author_id: userId,
+    name: 'My Mode',
+    description: 'Description',
+    version: '1.0.0',
+    controls: { /* controls data */ },
+    is_public: false
+  })
+  .select()
+  .single();
+
+// Update mode
+const { data, error } = await supabase
+  .from('modes')
+  .update({
+    name: 'Updated Name',
+    description: 'Updated Description',
+    controls: { /* updated controls */ }
+  })
+  .eq('id', modeId)
+  .select()
+  .single();
+
+// Delete mode
+const { error } = await supabase
+  .from('modes')
+  .delete()
+  .eq('id', modeId);
+
+// Like mode
+const { error } = await supabase
+  .from('mode_likes')
+  .insert({ user_id: userId, mode_id: modeId });
+
+// Unlike mode
+const { error } = await supabase
+  .from('mode_likes')
+  .delete()
+  .match({ user_id: userId, mode_id: modeId });
+
+// Rate mode
+const { error } = await supabase
+  .from('mode_ratings')
+  .upsert({
+    user_id: userId,
+    mode_id: modeId,
+    rating: 5,
+    review: 'Great mode!'
+  });
+
+// Search modes
+const { data, error } = await supabase
+  .from('modes')
+  .select('*')
+  .textSearch('fts', searchQuery, {
+    type: 'websearch',
+    config: 'english'
+  })
+  .eq('is_public', true);
+
+// Fork mode
+const { data: originalMode, error: fetchError } = await supabase
+  .from('modes')
+  .select('*')
+  .eq('id', modeId)
+  .single();
+
+if (fetchError) throw fetchError;
+
+const { data: forkedMode, error: insertError } = await supabase
+  .from('modes')
+  .insert({
+    author_id: userId,
+    name: `${originalMode.name} (Fork)`,
+    description: originalMode.description,
+    version: '1.0.0',
+    controls: originalMode.controls,
+    parent_mode_id: originalMode.id,
+    is_public: false
+  })
+  .select()
+  .single();
+```
+
+### 5.2 Netlify Functions (Optional - Future)
+
+Only needed for complex operations that can't be done client-side.
+
+**Example: Analytics Webhook**
+```typescript
+// netlify/functions/mode-analytics.ts
+import { Handler } from '@netlify/functions';
+import { createClient } from '@supabase/supabase-js';
+
+export const handler: Handler = async (event) => {
+  const supabase = createClient(
+    process.env.SUPABASE_URL!,
+    process.env.SUPABASE_SERVICE_ROLE_KEY! // Server-side only
+  );
+
+  // Track mode download with analytics service
+  const { modeId } = JSON.parse(event.body || '{}');
+
+  // Increment download count
+  await supabase
+    .from('modes')
+    .update({ downloads: supabase.sql`downloads + 1` })
+    .eq('id', modeId);
+
+  // Send to external analytics (e.g., PostHog)
+  await fetch('https://analytics.example.com/track', {
+    method: 'POST',
+    headers: { 'Authorization': `Bearer ${process.env.ANALYTICS_KEY}` },
+    body: JSON.stringify({ event: 'mode_download', modeId })
+  });
+
+  return {
+    statusCode: 200,
+    body: JSON.stringify({ success: true })
+  };
+};
+```
+
+---
+
+## 6. Security Model
+
+### 6.1 Authentication
+
+**Already Implemented:**
+- Google OAuth via Supabase Auth
+- JWT tokens with automatic refresh
+- Session persistence across devices
+
+**No Changes Needed:**
+- AuthContext provides user session
+- All database queries automatically include JWT token
+- RLS policies use `auth.uid()` to validate ownership
+
+### 6.2 Authorization
+
+**Row-Level Security (RLS) Enforces:**
+- Users can only view/edit/delete their own private modes
+- Anyone can view public modes
+- Only authenticated users can create modes
+- Only authenticated users can like/rate modes
+- Users cannot like/rate their own modes (future enhancement)
+
+### 6.3 Input Validation
+
+**Client-Side Validation:**
+```typescript
+import { z } from 'zod';
+
+const ControlMappingSchema = z.object({
+  id: z.string(),
+  type: z.enum(['knob', 'fader', 'button']),
+  ccNumber: z.number().int().min(0).max(127),
+  midiChannel: z.number().int().min(1).max(16),
+  minValue: z.number().int().min(0).max(127),
+  maxValue: z.number().int().min(0).max(127),
+  label: z.string().max(50).optional(),
+});
+
+const CloudModeSchema = z.object({
+  name: z.string()
+    .min(1, 'Name is required')
+    .max(255, 'Name too long')
+    .regex(/^[a-zA-Z0-9\s\-_]+$/, 'Name contains invalid characters'),
+  description: z.string().max(1000, 'Description too long'),
+  version: z.string().regex(/^\d+\.\d+\.\d+$/, 'Invalid version (use semver)'),
+  controls: z.record(z.string(), ControlMappingSchema),
+  tags: z.array(z.string().max(30)).max(10),
+  category: z.string().max(100).optional(),
+  isPublic: z.boolean(),
+});
+```
+
+**Database Validation:**
+- PostgreSQL constraints (CHECK, UNIQUE, NOT NULL)
+- Version format validation: `^\d+\.\d+\.\d+$`
+- Rating range: 1-5
+- Tag array size limit
+
+### 6.4 Rate Limiting
+
+**Supabase Built-in Rate Limiting:**
+- Anonymous: 200 requests/hour
+- Authenticated: 10,000 requests/hour
+- Adjustable via Supabase dashboard
+
+**Future: Custom Rate Limiting**
+```typescript
+// Netlify Function with rate limiting
+import rateLimit from 'lambda-rate-limiter';
+
+const limiter = rateLimit({
+  interval: 60 * 1000, // 1 minute
+  uniqueTokenPerInterval: 500
+});
+
+export const handler: Handler = async (event) => {
+  try {
+    await limiter.check(10, event.headers['x-forwarded-for']); // 10 requests per minute
+  } catch {
+    return { statusCode: 429, body: 'Rate limit exceeded' };
+  }
+
+  // Handle request
+};
+```
+
+---
+
+## 7. TypeScript Types
+
+### 7.1 Core Types
+
+```typescript
+// src/types/cloud-mode.ts
+
+import { CustomMode } from '@/types/mode';
+
+export interface CloudMode extends CustomMode {
+  // Unique identification
+  id: string;
+
+  // Ownership
+  authorId: string;
+  author?: {
+    id: string;
+    email: string;
+    displayName: string;
+    avatarUrl?: string;
+  };
+
+  // Visibility
+  isPublic: boolean;
+  isOfficial: boolean;
+  isFeatured: boolean;
+
+  // Engagement (denormalized)
+  downloads: number;
+  likes: number;
+  views: number;
+  rating: number;
+  ratingCount: number;
+  forkCount: number;
+
+  // Discovery
+  tags: string[];
+  category?: string;
+  thumbnail?: string;
+
+  // Relationships
+  parentModeId?: string;
+  parentMode?: CloudMode;
+
+  // Timestamps
+  publishedAt?: string;
+  updatedAt: string;
+
+  // Client-side computed
+  userLiked?: boolean;
+  userRating?: number;
+}
+
+export interface ModeVersion {
+  id: string;
+  modeId: string;
+  version: string;
+  changes: string;
+  controls: Record<string, ControlMapping>;
+  createdAt: string;
+}
+
+export interface ModeMetadata {
+  name: string;
+  description: string;
+  tags: string[];
+  category?: string;
+  isPublic: boolean;
+  thumbnail?: string;
+}
+
+export interface Category {
+  id: string;
+  name: string;
+  description: string;
+  icon?: string;
+  displayOrder: number;
+}
+
+export interface ModeFilters {
+  category?: string;
+  tags?: string[];
+  authorId?: string;
+  isPublic?: boolean;
+  isFeatured?: boolean;
+  sort?: 'recent' | 'downloads' | 'likes' | 'rating';
+  search?: string;
+  page?: number;
+  limit?: number;
+}
+
+export interface PaginatedResponse<T> {
+  data: T[];
+  pagination: {
+    page: number;
+    limit: number;
+    total: number;
+    totalPages: number;
+    hasNext: boolean;
+    hasPrev: boolean;
+  };
+}
+
+export interface ModeEngagement {
+  liked: boolean;
+  likesCount: number;
+  userRating?: number;
+  averageRating: number;
+  ratingCount: number;
+}
+```
+
+### 7.2 Supabase Types
+
+```typescript
+// src/types/supabase-database.ts
+// Generated via: supabase gen types typescript --project-id YOUR_PROJECT_ID
+
+export interface Database {
+  public: {
+    Tables: {
+      modes: {
+        Row: {
+          id: string;
+          author_id: string;
+          name: string;
+          description: string | null;
+          version: string;
+          controls: Record<string, any>;
+          is_public: boolean;
+          is_official: boolean;
+          is_featured: boolean;
+          downloads: number;
+          likes: number;
+          views: number;
+          fork_count: number;
+          rating: number | null;
+          rating_count: number;
+          tags: string[];
+          category: string | null;
+          thumbnail: string | null;
+          parent_mode_id: string | null;
+          created_at: string;
+          modified_at: string;
+          published_at: string | null;
+        };
+        Insert: {
+          id?: string;
+          author_id: string;
+          name: string;
+          description?: string | null;
+          version?: string;
+          controls: Record<string, any>;
+          is_public?: boolean;
+          is_official?: boolean;
+          is_featured?: boolean;
+          downloads?: number;
+          likes?: number;
+          views?: number;
+          fork_count?: number;
+          rating?: number | null;
+          rating_count?: number;
+          tags?: string[];
+          category?: string | null;
+          thumbnail?: string | null;
+          parent_mode_id?: string | null;
+          created_at?: string;
+          modified_at?: string;
+          published_at?: string | null;
+        };
+        Update: {
+          id?: string;
+          author_id?: string;
+          name?: string;
+          description?: string | null;
+          version?: string;
+          controls?: Record<string, any>;
+          is_public?: boolean;
+          is_official?: boolean;
+          is_featured?: boolean;
+          downloads?: number;
+          likes?: number;
+          views?: number;
+          fork_count?: number;
+          rating?: number | null;
+          rating_count?: number;
+          tags?: string[];
+          category?: string | null;
+          thumbnail?: string | null;
+          parent_mode_id?: string | null;
+          created_at?: string;
+          modified_at?: string;
+          published_at?: string | null;
+        };
+      };
+      mode_likes: {
+        Row: {
+          user_id: string;
+          mode_id: string;
+          created_at: string;
+        };
+        Insert: {
+          user_id: string;
+          mode_id: string;
+          created_at?: string;
+        };
+        Update: {
+          user_id?: string;
+          mode_id?: string;
+          created_at?: string;
+        };
+      };
+      mode_ratings: {
+        Row: {
+          user_id: string;
+          mode_id: string;
+          rating: number;
+          review: string | null;
+          created_at: string;
+          updated_at: string;
+        };
+        Insert: {
+          user_id: string;
+          mode_id: string;
+          rating: number;
+          review?: string | null;
+          created_at?: string;
+          updated_at?: string;
+        };
+        Update: {
+          user_id?: string;
+          mode_id?: string;
+          rating?: number;
+          review?: string | null;
+          created_at?: string;
+          updated_at?: string;
+        };
+      };
+      mode_versions: {
+        Row: {
+          id: string;
+          mode_id: string;
+          version: string;
+          changes: string | null;
+          controls: Record<string, any>;
+          created_at: string;
+        };
+        Insert: {
+          id?: string;
+          mode_id: string;
+          version: string;
+          changes?: string | null;
+          controls: Record<string, any>;
+          created_at?: string;
+        };
+        Update: {
+          id?: string;
+          mode_id?: string;
+          version?: string;
+          changes?: string | null;
+          controls?: Record<string, any>;
+          created_at?: string;
+        };
+      };
+      categories: {
+        Row: {
+          id: string;
+          name: string;
+          description: string | null;
+          icon: string | null;
+          display_order: number;
+        };
+        Insert: {
+          id: string;
+          name: string;
+          description?: string | null;
+          icon?: string | null;
+          display_order?: number;
+        };
+        Update: {
+          id?: string;
+          name?: string;
+          description?: string | null;
+          icon?: string | null;
+          display_order?: number;
+        };
+      };
+    };
+  };
+}
+```
+
+---
+
+## 8. Implementation Steps
+
+### Phase 1: Database Setup (4-6 hours)
+
+#### 8.1 Create Database Schema
+- **File:** `supabase/migrations/001_modes_schema.sql`
+- Create modes table with indexes
+- Create mode_likes, mode_ratings tables
+- Create mode_versions table
+- Create categories table with seed data
+- Add triggers for updated_at and rating aggregation
+
+**Verification:**
+```bash
+# After running migration
+ls -la supabase/migrations/001_modes_schema.sql
+head -20 supabase/migrations/001_modes_schema.sql
+```
+
+#### 8.2 Configure RLS Policies
+- **File:** `supabase/migrations/002_rls_policies.sql`
+- Enable RLS on all tables
+- Create policies for modes (view, create, update, delete)
+- Create policies for likes and ratings
+- Create policies for version history
+
+**Verification:**
+```bash
+ls -la supabase/migrations/002_rls_policies.sql
+wc -l supabase/migrations/002_rls_policies.sql
+```
+
+#### 8.3 Generate TypeScript Types
+- **Command:** `supabase gen types typescript --project-id YOUR_PROJECT_ID > src/types/supabase-database.ts`
+- Verify types compile with existing code
+
+**Verification:**
+```bash
+ls -la src/types/supabase-database.ts
+head -30 src/types/supabase-database.ts
+pnpm tsc --noEmit
+```
+
+---
+
+### Phase 2: Service Layer (6-8 hours)
+
+#### 8.4 Create CloudModeService
+- **File:** `src/lib/services/cloud-mode-service.ts`
+- Implement CRUD operations using Supabase client
+- Implement search and filtering
+- Implement engagement operations (like, rate, fork)
+- Error handling and type safety
+
+**Implementation:**
+```typescript
+// src/lib/services/cloud-mode-service.ts
+
+import { supabase } from '@/lib/supabase';
+import { CloudMode, ModeFilters, ModeMetadata, PaginatedResponse } from '@/types/cloud-mode';
+import { CustomMode } from '@/types/mode';
+import { Database } from '@/types/supabase-database';
+
+type ModeRow = Database['public']['Tables']['modes']['Row'];
+type ModeInsert = Database['public']['Tables']['modes']['Insert'];
+type ModeUpdate = Database['public']['Tables']['modes']['Update'];
+
+export class CloudModeService {
+  /**
+   * Convert database row to CloudMode
+   */
+  private toCloudMode(row: ModeRow, userId?: string): CloudMode {
+    return {
+      id: row.id,
+      authorId: row.author_id,
+      name: row.name,
+      description: row.description || '',
+      version: row.version,
+      controls: row.controls as Record<string, any>,
+      isPublic: row.is_public,
+      isOfficial: row.is_official,
+      isFeatured: row.is_featured,
+      downloads: row.downloads,
+      likes: row.likes,
+      views: row.views,
+      rating: row.rating || 0,
+      ratingCount: row.rating_count,
+      forkCount: row.fork_count,
+      tags: row.tags,
+      category: row.category || undefined,
+      thumbnail: row.thumbnail || undefined,
+      parentModeId: row.parent_mode_id || undefined,
+      createdAt: row.created_at,
+      modifiedAt: row.modified_at,
+      publishedAt: row.published_at || undefined,
+      updatedAt: row.modified_at,
+    };
+  }
+
+  /**
+   * Browse public modes with filters
+   */
+  async browseModes(filters: ModeFilters = {}): Promise<PaginatedResponse<CloudMode>> {
+    const {
+      category,
+      tags,
+      isPublic = true,
+      isFeatured,
+      sort = 'recent',
+      search,
+      page = 1,
+      limit = 20,
+    } = filters;
+
+    let query = supabase
+      .from('modes')
+      .select('*', { count: 'exact' })
+      .eq('is_public', isPublic);
+
+    if (category) {
+      query = query.eq('category', category);
+    }
+
+    if (tags && tags.length > 0) {
+      query = query.contains('tags', tags);
+    }
+
+    if (isFeatured !== undefined) {
+      query = query.eq('is_featured', isFeatured);
+    }
+
+    if (search) {
+      query = query.textSearch('fts', search, {
+        type: 'websearch',
+        config: 'english'
+      });
+    }
+
+    // Sorting
+    switch (sort) {
+      case 'downloads':
+        query = query.order('downloads', { ascending: false });
+        break;
+      case 'likes':
+        query = query.order('likes', { ascending: false });
+        break;
+      case 'rating':
+        query = query.order('rating', { ascending: false, nullsLast: true });
+        break;
+      case 'recent':
+      default:
+        query = query.order('created_at', { ascending: false });
+    }
+
+    // Pagination
+    const from = (page - 1) * limit;
+    const to = from + limit - 1;
+    query = query.range(from, to);
+
+    const { data, error, count } = await query;
+
+    if (error) {
+      throw new Error(`Failed to fetch modes: ${error.message}`);
+    }
+
+    const total = count || 0;
+    const totalPages = Math.ceil(total / limit);
+
+    return {
+      data: (data || []).map(row => this.toCloudMode(row)),
+      pagination: {
+        page,
+        limit,
+        total,
+        totalPages,
+        hasNext: page < totalPages,
+        hasPrev: page > 1,
+      },
+    };
+  }
+
+  /**
+   * Get mode by ID
+   */
+  async getModeById(id: string, userId?: string): Promise<CloudMode> {
+    const { data, error } = await supabase
+      .from('modes')
+      .select('*')
+      .eq('id', id)
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to fetch mode: ${error.message}`);
+    }
+
+    return this.toCloudMode(data, userId);
+  }
+
+  /**
+   * Get user's modes
+   */
+  async getUserModes(userId: string): Promise<CloudMode[]> {
+    const { data, error } = await supabase
+      .from('modes')
+      .select('*')
+      .eq('author_id', userId)
+      .order('modified_at', { ascending: false });
+
+    if (error) {
+      throw new Error(`Failed to fetch user modes: ${error.message}`);
+    }
+
+    return (data || []).map(row => this.toCloudMode(row, userId));
+  }
+
+  /**
+   * Create new mode
+   */
+  async createMode(userId: string, mode: CustomMode, metadata: ModeMetadata): Promise<CloudMode> {
+    const insert: ModeInsert = {
+      author_id: userId,
+      name: metadata.name,
+      description: metadata.description,
+      version: mode.version,
+      controls: mode.controls as any,
+      is_public: metadata.isPublic,
+      tags: metadata.tags,
+      category: metadata.category,
+      thumbnail: metadata.thumbnail,
+    };
+
+    const { data, error } = await supabase
+      .from('modes')
+      .insert(insert)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to create mode: ${error.message}`);
+    }
+
+    return this.toCloudMode(data, userId);
+  }
+
+  /**
+   * Update existing mode
+   */
+  async updateMode(modeId: string, updates: Partial<CloudMode>): Promise<CloudMode> {
+    const update: ModeUpdate = {};
+
+    if (updates.name !== undefined) update.name = updates.name;
+    if (updates.description !== undefined) update.description = updates.description;
+    if (updates.version !== undefined) update.version = updates.version;
+    if (updates.controls !== undefined) update.controls = updates.controls as any;
+    if (updates.isPublic !== undefined) update.is_public = updates.isPublic;
+    if (updates.tags !== undefined) update.tags = updates.tags;
+    if (updates.category !== undefined) update.category = updates.category;
+    if (updates.thumbnail !== undefined) update.thumbnail = updates.thumbnail;
+
+    const { data, error } = await supabase
+      .from('modes')
+      .update(update)
+      .eq('id', modeId)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to update mode: ${error.message}`);
+    }
+
+    return this.toCloudMode(data);
+  }
+
+  /**
+   * Delete mode
+   */
+  async deleteMode(modeId: string): Promise<void> {
+    const { error } = await supabase
+      .from('modes')
+      .delete()
+      .eq('id', modeId);
+
+    if (error) {
+      throw new Error(`Failed to delete mode: ${error.message}`);
+    }
+  }
+
+  /**
+   * Like mode
+   */
+  async likeMode(userId: string, modeId: string): Promise<{ liked: boolean; likesCount: number }> {
+    // Check if already liked
+    const { data: existingLike } = await supabase
+      .from('mode_likes')
+      .select('*')
+      .match({ user_id: userId, mode_id: modeId })
+      .single();
+
+    if (existingLike) {
+      // Unlike
+      const { error: unlikeError } = await supabase
+        .from('mode_likes')
+        .delete()
+        .match({ user_id: userId, mode_id: modeId });
+
+      if (unlikeError) {
+        throw new Error(`Failed to unlike mode: ${unlikeError.message}`);
+      }
+
+      // Decrement likes count
+      const { error: updateError } = await supabase.rpc('decrement_likes', { mode_id: modeId });
+
+      if (updateError) {
+        throw new Error(`Failed to update likes count: ${updateError.message}`);
+      }
+
+      const { data: mode } = await supabase
+        .from('modes')
+        .select('likes')
+        .eq('id', modeId)
+        .single();
+
+      return { liked: false, likesCount: mode?.likes || 0 };
+    } else {
+      // Like
+      const { error: likeError } = await supabase
+        .from('mode_likes')
+        .insert({ user_id: userId, mode_id: modeId });
+
+      if (likeError) {
+        throw new Error(`Failed to like mode: ${likeError.message}`);
+      }
+
+      // Increment likes count
+      const { error: updateError } = await supabase.rpc('increment_likes', { mode_id: modeId });
+
+      if (updateError) {
+        throw new Error(`Failed to update likes count: ${updateError.message}`);
+      }
+
+      const { data: mode } = await supabase
+        .from('modes')
+        .select('likes')
+        .eq('id', modeId)
+        .single();
+
+      return { liked: true, likesCount: mode?.likes || 0 };
+    }
+  }
+
+  /**
+   * Rate mode
+   */
+  async rateMode(
+    userId: string,
+    modeId: string,
+    rating: number,
+    review?: string
+  ): Promise<{ averageRating: number; ratingCount: number }> {
+    const { error } = await supabase
+      .from('mode_ratings')
+      .upsert({
+        user_id: userId,
+        mode_id: modeId,
+        rating,
+        review,
+      });
+
+    if (error) {
+      throw new Error(`Failed to rate mode: ${error.message}`);
+    }
+
+    // Rating aggregate is updated by database trigger
+    const { data: mode } = await supabase
+      .from('modes')
+      .select('rating, rating_count')
+      .eq('id', modeId)
+      .single();
+
+    return {
+      averageRating: mode?.rating || 0,
+      ratingCount: mode?.rating_count || 0,
+    };
+  }
+
+  /**
+   * Fork mode
+   */
+  async forkMode(
+    userId: string,
+    modeId: string,
+    overrides?: { name?: string; description?: string }
+  ): Promise<CloudMode> {
+    // Get original mode
+    const { data: originalMode, error: fetchError } = await supabase
+      .from('modes')
+      .select('*')
+      .eq('id', modeId)
+      .single();
+
+    if (fetchError) {
+      throw new Error(`Failed to fetch original mode: ${fetchError.message}`);
+    }
+
+    // Create fork
+    const insert: ModeInsert = {
+      author_id: userId,
+      name: overrides?.name || `${originalMode.name} (Fork)`,
+      description: overrides?.description || originalMode.description,
+      version: '1.0.0',
+      controls: originalMode.controls,
+      is_public: false,
+      tags: originalMode.tags,
+      category: originalMode.category,
+      parent_mode_id: originalMode.id,
+    };
+
+    const { data: forkedMode, error: insertError } = await supabase
+      .from('modes')
+      .insert(insert)
+      .select()
+      .single();
+
+    if (insertError) {
+      throw new Error(`Failed to fork mode: ${insertError.message}`);
+    }
+
+    // Increment fork count on original
+    await supabase.rpc('increment_fork_count', { mode_id: modeId });
+
+    return this.toCloudMode(forkedMode, userId);
+  }
+
+  /**
+   * Get categories
+   */
+  async getCategories(): Promise<Category[]> {
+    const { data, error } = await supabase
+      .from('categories')
+      .select('*')
+      .order('display_order');
+
+    if (error) {
+      throw new Error(`Failed to fetch categories: ${error.message}`);
+    }
+
+    return data || [];
+  }
+}
+
+export const cloudModeService = new CloudModeService();
+```
+
+**Verification:**
+```bash
+ls -la src/lib/services/cloud-mode-service.ts
+wc -l src/lib/services/cloud-mode-service.ts
+head -50 src/lib/services/cloud-mode-service.ts
+```
+
+#### 8.5 Create Database Functions (RPC)
+- **File:** `supabase/migrations/003_rpc_functions.sql`
+- Create functions for atomic operations (increment likes, decrement likes, increment fork count)
+
+**Implementation:**
+```sql
+-- Function to increment likes atomically
+CREATE OR REPLACE FUNCTION increment_likes(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET likes = likes + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+-- Function to decrement likes atomically
+CREATE OR REPLACE FUNCTION decrement_likes(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET likes = GREATEST(likes - 1, 0)
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+-- Function to increment fork count atomically
+CREATE OR REPLACE FUNCTION increment_fork_count(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET fork_count = fork_count + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+-- Function to increment views atomically
+CREATE OR REPLACE FUNCTION increment_views(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET views = views + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+-- Function to increment downloads atomically
+CREATE OR REPLACE FUNCTION increment_downloads(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET downloads = downloads + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+```
+
+**Verification:**
+```bash
+ls -la supabase/migrations/003_rpc_functions.sql
+cat supabase/migrations/003_rpc_functions.sql
+```
+
+---
+
+### Phase 3: React Query Hooks (4-6 hours)
+
+#### 8.6 Create React Query Hooks
+- **File:** `src/hooks/useCloudModes.ts`
+- Implement hooks for all cloud operations
+- Optimistic updates for likes
+- Cache invalidation strategy
+- Error handling
+
+**Implementation:**
+```typescript
+// src/hooks/useCloudModes.ts
+
+import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
+import { useAuth } from '@/contexts/AuthContext';
+import { cloudModeService } from '@/lib/services/cloud-mode-service';
+import {
+  CloudMode,
+  ModeFilters,
+  ModeMetadata,
+  PaginatedResponse,
+} from '@/types/cloud-mode';
+import { CustomMode } from '@/types/mode';
+
+// Query keys
+export const cloudModeKeys = {
+  all: ['cloud-modes'] as const,
+  lists: () => [...cloudModeKeys.all, 'list'] as const,
+  list: (filters: ModeFilters) => [...cloudModeKeys.lists(), filters] as const,
+  details: () => [...cloudModeKeys.all, 'detail'] as const,
+  detail: (id: string) => [...cloudModeKeys.details(), id] as const,
+  userModes: (userId: string) => [...cloudModeKeys.all, 'user', userId] as const,
+  categories: () => [...cloudModeKeys.all, 'categories'] as const,
+};
+
+/**
+ * Browse public modes with filters
+ */
+export function usePublicModes(filters: ModeFilters = {}) {
+  return useQuery({
+    queryKey: cloudModeKeys.list({ ...filters, isPublic: true }),
+    queryFn: () => cloudModeService.browseModes({ ...filters, isPublic: true }),
+    staleTime: 5 * 60 * 1000, // 5 minutes
+  });
+}
+
+/**
+ * Get mode by ID
+ */
+export function useModeById(id: string) {
+  const { user } = useAuth();
+
+  return useQuery({
+    queryKey: cloudModeKeys.detail(id),
+    queryFn: () => cloudModeService.getModeById(id, user?.id),
+    enabled: !!id,
+    staleTime: 5 * 60 * 1000,
+  });
+}
+
+/**
+ * Get user's modes (requires authentication)
+ */
+export function useUserModes() {
+  const { user, isAuthenticated } = useAuth();
+
+  return useQuery({
+    queryKey: cloudModeKeys.userModes(user?.id || ''),
+    queryFn: () => {
+      if (!user) throw new Error('User not authenticated');
+      return cloudModeService.getUserModes(user.id);
+    },
+    enabled: isAuthenticated && !!user,
+    staleTime: 1 * 60 * 1000, // 1 minute
+  });
+}
+
+/**
+ * Create new mode
+ */
+export function useCreateMode() {
+  const queryClient = useQueryClient();
+  const { user } = useAuth();
+
+  return useMutation({
+    mutationFn: (data: { mode: CustomMode; metadata: ModeMetadata }) => {
+      if (!user) throw new Error('User not authenticated');
+      return cloudModeService.createMode(user.id, data.mode, data.metadata);
+    },
+    onSuccess: () => {
+      if (user) {
+        queryClient.invalidateQueries({ queryKey: cloudModeKeys.userModes(user.id) });
+      }
+    },
+  });
+}
+
+/**
+ * Update mode
+ */
+export function useUpdateMode() {
+  const queryClient = useQueryClient();
+  const { user } = useAuth();
+
+  return useMutation({
+    mutationFn: (data: { modeId: string; updates: Partial<CloudMode> }) =>
+      cloudModeService.updateMode(data.modeId, data.updates),
+    onSuccess: (updatedMode) => {
+      queryClient.setQueryData(cloudModeKeys.detail(updatedMode.id), updatedMode);
+      if (user) {
+        queryClient.invalidateQueries({ queryKey: cloudModeKeys.userModes(user.id) });
+      }
+    },
+  });
+}
+
+/**
+ * Delete mode
+ */
+export function useDeleteMode() {
+  const queryClient = useQueryClient();
+  const { user } = useAuth();
+
+  return useMutation({
+    mutationFn: (modeId: string) => cloudModeService.deleteMode(modeId),
+    onSuccess: (_, modeId) => {
+      queryClient.removeQueries({ queryKey: cloudModeKeys.detail(modeId) });
+      if (user) {
+        queryClient.invalidateQueries({ queryKey: cloudModeKeys.userModes(user.id) });
+      }
+    },
+  });
+}
+
+/**
+ * Like/unlike mode (with optimistic update)
+ */
+export function useLikeMode() {
+  const queryClient = useQueryClient();
+  const { user } = useAuth();
+
+  return useMutation({
+    mutationFn: (modeId: string) => {
+      if (!user) throw new Error('User not authenticated');
+      return cloudModeService.likeMode(user.id, modeId);
+    },
+    onMutate: async (modeId) => {
+      // Cancel outgoing refetches
+      await queryClient.cancelQueries({ queryKey: cloudModeKeys.detail(modeId) });
+
+      // Snapshot previous value
+      const previousMode = queryClient.getQueryData<CloudMode>(cloudModeKeys.detail(modeId));
+
+      // Optimistically update
+      if (previousMode) {
+        const optimisticMode: CloudMode = {
+          ...previousMode,
+          likes: previousMode.userLiked ? previousMode.likes - 1 : previousMode.likes + 1,
+          userLiked: !previousMode.userLiked,
+        };
+        queryClient.setQueryData(cloudModeKeys.detail(modeId), optimisticMode);
+      }
+
+      return { previousMode };
+    },
+    onError: (err, modeId, context) => {
+      // Rollback on error
+      if (context?.previousMode) {
+        queryClient.setQueryData(cloudModeKeys.detail(modeId), context.previousMode);
+      }
+    },
+    onSettled: (data, error, modeId) => {
+      // Refetch to sync with server
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.detail(modeId) });
+    },
+  });
+}
+
+/**
+ * Rate mode
+ */
+export function useRateMode() {
+  const queryClient = useQueryClient();
+  const { user } = useAuth();
+
+  return useMutation({
+    mutationFn: (data: { modeId: string; rating: number; review?: string }) => {
+      if (!user) throw new Error('User not authenticated');
+      return cloudModeService.rateMode(user.id, data.modeId, data.rating, data.review);
+    },
+    onSuccess: (_, variables) => {
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.detail(variables.modeId) });
+    },
+  });
+}
+
+/**
+ * Fork mode
+ */
+export function useForkMode() {
+  const queryClient = useQueryClient();
+  const { user } = useAuth();
+
+  return useMutation({
+    mutationFn: (data: {
+      modeId: string;
+      overrides?: { name?: string; description?: string };
+    }) => {
+      if (!user) throw new Error('User not authenticated');
+      return cloudModeService.forkMode(user.id, data.modeId, data.overrides);
+    },
+    onSuccess: (forkedMode) => {
+      if (user) {
+        queryClient.invalidateQueries({ queryKey: cloudModeKeys.userModes(user.id) });
+      }
+      // Invalidate original mode to update fork count
+      if (forkedMode.parentModeId) {
+        queryClient.invalidateQueries({
+          queryKey: cloudModeKeys.detail(forkedMode.parentModeId),
+        });
+      }
+    },
+  });
+}
+
+/**
+ * Get categories
+ */
+export function useCategories() {
+  return useQuery({
+    queryKey: cloudModeKeys.categories(),
+    queryFn: () => cloudModeService.getCategories(),
+    staleTime: 60 * 60 * 1000, // 1 hour
+  });
+}
+```
+
+**Verification:**
+```bash
+ls -la src/hooks/useCloudModes.ts
+wc -l src/hooks/useCloudModes.ts
+head -50 src/hooks/useCloudModes.ts
+```
+
+---
+
+### Phase 4: UI Components (8-10 hours)
+
+#### 8.7 Update Catalog Page
+- **File:** `src/pages/Catalog.tsx`
+- Replace mock data with real cloud modes
+- Implement filters (category, tags, sort)
+- Implement search
+- Pagination
+- Loading states
+
+**Verification:**
+```bash
+ls -la src/pages/Catalog.tsx
+wc -l src/pages/Catalog.tsx
+```
+
+#### 8.8 Update Library Page
+- **File:** `src/pages/Library.tsx`
+- Show user's modes from cloud
+- Add upload button
+- Edit/delete actions
+- Publish/unpublish toggle
+
+**Verification:**
+```bash
+ls -la src/pages/Library.tsx
+wc -l src/pages/Library.tsx
+```
+
+#### 8.9 Create Mode Detail Page
+- **File:** `src/pages/ModeDetail.tsx`
+- Show full mode details
+- Like button
+- Rating component
+- Fork button
+- Download button
+- Comments section (future)
+
+**Verification:**
+```bash
+ls -la src/pages/ModeDetail.tsx
+wc -l src/pages/ModeDetail.tsx
+```
+
+#### 8.10 Create Mode Card Component
+- **File:** `src/components/mode/ModeCard.tsx`
+- Reusable card for catalog and library
+- Show thumbnail, name, author, engagement metrics
+- Hover effects
+- Action buttons
+
+**Verification:**
+```bash
+ls -la src/components/mode/ModeCard.tsx
+wc -l src/components/mode/ModeCard.tsx
+```
+
+#### 8.11 Create Mode Upload Dialog
+- **File:** `src/components/mode/ModeUploadDialog.tsx`
+- Form for mode metadata (name, description, tags, category)
+- Validation with Zod
+- Upload progress
+- Error handling
+
+**Verification:**
+```bash
+ls -la src/components/mode/ModeUploadDialog.tsx
+wc -l src/components/mode/ModeUploadDialog.tsx
+```
+
+---
+
+### Phase 5: Integration & Testing (6-8 hours)
+
+#### 8.12 Update Router
+- **File:** `src/App.tsx`
+- Add route for mode detail page: `/modes/:id`
+- Ensure routes are protected appropriately
+
+**Verification:**
+```bash
+ls -la src/App.tsx
+grep -n "modes/" src/App.tsx
+```
+
+#### 8.13 E2E Tests
+- **File:** `tests/e2e/cloud-modes.spec.ts`
+- Test browsing public catalog
+- Test creating mode
+- Test liking mode
+- Test forking mode
+- Test deleting mode
+
+**Verification:**
+```bash
+ls -la tests/e2e/cloud-modes.spec.ts
+wc -l tests/e2e/cloud-modes.spec.ts
+```
+
+#### 8.14 Unit Tests
+- **File:** `src/lib/services/__tests__/cloud-mode-service.test.ts`
+- Test all CloudModeService methods
+- Mock Supabase client
+- Test error handling
+
+**Verification:**
+```bash
+ls -la src/lib/services/__tests__/cloud-mode-service.test.ts
+wc -l src/lib/services/__tests__/cloud-mode-service.test.ts
+```
+
+---
+
+## 9. Timeline Estimate
+
+### Total: 28-38 hours
+
+**Phase 1: Database Setup (4-6 hours)**
+- Create schema: 2-3h
+- Configure RLS policies: 1-2h
+- Generate TypeScript types: 0.5h
+- Create RPC functions: 0.5-1h
+
+**Phase 2: Service Layer (6-8 hours)**
+- CloudModeService implementation: 4-5h
+- Error handling and types: 1-2h
+- Testing service layer: 1h
+
+**Phase 3: React Query Hooks (4-6 hours)**
+- Implement all hooks: 3-4h
+- Optimistic updates: 1h
+- Error handling: 0.5-1h
+
+**Phase 4: UI Components (8-10 hours)**
+- Update Catalog page: 2h
+- Update Library page: 2h
+- Mode detail page: 2-3h
+- Mode card component: 1h
+- Upload dialog: 1-2h
+
+**Phase 5: Integration & Testing (6-8 hours)**
+- Router updates: 0.5h
+- E2E tests: 3-4h
+- Unit tests: 2-3h
+- Bug fixes and polish: 0.5-1h
+
+### Weekly Breakdown
+
+**Week 1: Backend (10-14 hours)**
+- Day 1-2: Database schema and RLS (4-6h)
+- Day 3-4: Service layer (6-8h)
+
+**Week 2: Frontend (12-16 hours)**
+- Day 5-6: React Query hooks (4-6h)
+- Day 7-9: UI components (8-10h)
+
+**Week 3: Testing & Polish (6-8 hours)**
+- Day 10-11: Integration and E2E tests (4-5h)
+- Day 12: Unit tests and bug fixes (2-3h)
+
+---
+
+## 10. Testing Strategy
+
+### 10.1 Unit Tests
+
+```typescript
+// src/lib/services/__tests__/cloud-mode-service.test.ts
+
+import { describe, it, expect, vi, beforeEach } from 'vitest';
+import { CloudModeService } from '@/lib/services/cloud-mode-service';
+import { supabase } from '@/lib/supabase';
+
+vi.mock('@/lib/supabase');
+
+describe('CloudModeService', () => {
+  let service: CloudModeService;
+
+  beforeEach(() => {
+    service = new CloudModeService();
+    vi.clearAllMocks();
+  });
+
+  describe('browseModes', () => {
+    it('should fetch public modes with default filters', async () => {
+      const mockData = [
+        {
+          id: '1',
+          author_id: 'user1',
+          name: 'Test Mode',
+          description: 'Test',
+          version: '1.0.0',
+          controls: {},
+          is_public: true,
+          // ... other fields
+        },
+      ];
+
+      vi.mocked(supabase.from).mockReturnValue({
+        select: vi.fn().mockReturnThis(),
+        eq: vi.fn().mockReturnThis(),
+        order: vi.fn().mockReturnThis(),
+        range: vi.fn().mockResolvedValue({ data: mockData, error: null, count: 1 }),
+      } as any);
+
+      const result = await service.browseModes();
+
+      expect(result.data).toHaveLength(1);
+      expect(result.data[0].name).toBe('Test Mode');
+    });
+
+    it('should filter by category', async () => {
+      // Test implementation
+    });
+
+    it('should handle errors', async () => {
+      vi.mocked(supabase.from).mockReturnValue({
+        select: vi.fn().mockReturnThis(),
+        eq: vi.fn().mockReturnThis(),
+        order: vi.fn().mockReturnThis(),
+        range: vi.fn().mockResolvedValue({ data: null, error: { message: 'DB error' }, count: 0 }),
+      } as any);
+
+      await expect(service.browseModes()).rejects.toThrow('Failed to fetch modes');
+    });
+  });
+
+  describe('createMode', () => {
+    it('should create mode with correct data', async () => {
+      // Test implementation
+    });
+
+    it('should validate mode data', async () => {
+      // Test implementation
+    });
+  });
+
+  describe('likeMode', () => {
+    it('should toggle like status', async () => {
+      // Test implementation
+    });
+
+    it('should update likes count', async () => {
+      // Test implementation
+    });
+  });
+});
+```
+
+### 10.2 Integration Tests
+
+```typescript
+// tests/e2e/cloud-modes.spec.ts
+
+import { test, expect } from '@playwright/test';
+
+test.describe('Cloud Modes', () => {
+  test.beforeEach(async ({ page }) => {
+    // Navigate to catalog
+    await page.goto('/catalog');
+  });
+
+  test('should browse public catalog without authentication', async ({ page }) => {
+    // Wait for modes to load
+    await page.waitForSelector('[data-testid="mode-card"]');
+
+    // Should see mode cards
+    const modeCards = await page.locator('[data-testid="mode-card"]').count();
+    expect(modeCards).toBeGreaterThan(0);
+
+    // Should see mode details
+    await expect(page.locator('[data-testid="mode-card"]').first()).toContainText('mode');
+  });
+
+  test('should filter by category', async ({ page }) => {
+    // Click category filter
+    await page.click('[data-testid="category-filter"]');
+    await page.click('text=DAW Control');
+
+    // URL should update
+    expect(page.url()).toContain('category=daw-control');
+
+    // Results should be filtered
+    await page.waitForSelector('[data-testid="mode-card"]');
+  });
+
+  test('should search modes', async ({ page }) => {
+    // Enter search term
+    await page.fill('[data-testid="search-input"]', 'ableton');
+    await page.press('[data-testid="search-input"]', 'Enter');
+
+    // Results should be filtered
+    await page.waitForSelector('[data-testid="mode-card"]');
+    await expect(page.locator('[data-testid="mode-card"]').first()).toContainText('ableton', { ignoreCase: true });
+  });
+
+  test('should require authentication to create mode', async ({ page }) => {
+    // Navigate to library
+    await page.goto('/library');
+
+    // Should redirect to login
+    await expect(page).toHaveURL('/login');
+  });
+
+  test('authenticated user can create mode', async ({ page, context }) => {
+    // Sign in first (assumes auth is working)
+    await page.goto('/login');
+    await page.click('text=Continue with Google');
+    // OAuth flow would happen here
+    // For testing, mock authentication state
+
+    // Navigate to library
+    await page.goto('/library');
+
+    // Click create mode
+    await page.click('[data-testid="create-mode-button"]');
+
+    // Fill form
+    await page.fill('[data-testid="mode-name-input"]', 'Test Mode');
+    await page.fill('[data-testid="mode-description-input"]', 'Test Description');
+    await page.click('[data-testid="mode-category-select"]');
+    await page.click('text=DAW Control');
+
+    // Submit
+    await page.click('[data-testid="submit-mode-button"]');
+
+    // Should see success message
+    await expect(page.locator('text=Mode created successfully')).toBeVisible();
+
+    // Should appear in library
+    await expect(page.locator('text=Test Mode')).toBeVisible();
+  });
+
+  test('authenticated user can like mode', async ({ page }) => {
+    // Assume authentication
+    await page.goto('/catalog');
+
+    // Click first mode
+    await page.click('[data-testid="mode-card"]');
+
+    // Wait for detail page
+    await page.waitForSelector('[data-testid="like-button"]');
+
+    // Get initial like count
+    const initialLikes = await page.locator('[data-testid="likes-count"]').textContent();
+
+    // Click like button
+    await page.click('[data-testid="like-button"]');
+
+    // Likes should increment
+    await expect(page.locator('[data-testid="likes-count"]')).not.toHaveText(initialLikes || '0');
+  });
+
+  test('authenticated user can fork mode', async ({ page }) => {
+    // Assume authentication
+    await page.goto('/modes/some-mode-id');
+
+    // Click fork button
+    await page.click('[data-testid="fork-button"]');
+
+    // Fill fork dialog
+    await page.fill('[data-testid="fork-name-input"]', 'Forked Mode');
+    await page.click('[data-testid="confirm-fork-button"]');
+
+    // Should redirect to library
+    await expect(page).toHaveURL('/library');
+
+    // Should see forked mode
+    await expect(page.locator('text=Forked Mode')).toBeVisible();
+  });
+});
+```
+
+### 10.3 Coverage Requirements
+
+- CloudModeService: 90%+
+- React Query hooks: 85%+
+- UI components: 80%+
+- E2E critical paths: 100%
+
+---
+
+## 11. Acceptance Criteria
+
+### Feature Completion
+
+- [ ] Database schema created and RLS policies configured
+- [ ] TypeScript types generated and integrated
+- [ ] CloudModeService implements all CRUD operations
+- [ ] React Query hooks for all cloud operations
+- [ ] Catalog page shows public modes with filters
+- [ ] Library page shows user's modes with CRUD actions
+- [ ] Mode detail page with engagement features (like, rate, fork)
+- [ ] Upload dialog for creating new modes
+- [ ] Search functionality
+- [ ] Pagination for mode lists
+- [ ] Optimistic UI updates for likes
+- [ ] Error handling and loading states
+- [ ] Responsive design (mobile, tablet, desktop)
+
+### Testing
+
+- [ ] 85%+ test coverage
+- [ ] All E2E tests pass
+- [ ] All unit tests pass
+- [ ] Manual testing checklist complete
+
+### Security
+
+- [ ] RLS policies enforce user ownership
+- [ ] Input validation on all forms
+- [ ] No SQL injection vulnerabilities
+- [ ] No XSS vulnerabilities
+- [ ] Rate limiting active
+
+### Performance
+
+- [ ] Catalog loads in < 2s (first load)
+- [ ] Mode detail loads in < 1s
+- [ ] Search results in < 1s
+- [ ] Like/unlike responds in < 500ms (optimistic)
+- [ ] Pagination smooth and instant
+
+### Documentation
+
+- [ ] API documentation (JSDoc comments)
+- [ ] README updated with cloud features
+- [ ] User guide for uploading modes
+- [ ] Developer guide for extending features
+
+---
+
+## Appendices
+
+### Appendix A: File Structure
+
+```
+xl3-web/
+├── src/
+│   ├── types/
+│   │   ├── cloud-mode.ts                    # CloudMode types
+│   │   └── supabase-database.ts             # Generated Supabase types
+│   │
+│   ├── lib/
+│   │   └── services/
+│   │       ├── cloud-mode-service.ts        # Main service
+│   │       └── __tests__/
+│   │           └── cloud-mode-service.test.ts
+│   │
+│   ├── hooks/
+│   │   └── useCloudModes.ts                 # React Query hooks
+│   │
+│   ├── components/
+│   │   └── mode/
+│   │       ├── ModeCard.tsx                 # Mode card component
+│   │       ├── ModeUploadDialog.tsx         # Upload dialog
+│   │       ├── ModeFilters.tsx              # Filter sidebar
+│   │       ├── LikeButton.tsx               # Like button
+│   │       ├── RatingStars.tsx              # Rating component
+│   │       └── ForkButton.tsx               # Fork button
+│   │
+│   └── pages/
+│       ├── Catalog.tsx                      # Updated catalog
+│       ├── Library.tsx                      # Updated library
+│       └── ModeDetail.tsx                   # New detail page
+│
+├── supabase/
+│   └── migrations/
+│       ├── 001_modes_schema.sql             # Database schema
+│       ├── 002_rls_policies.sql             # RLS policies
+│       └── 003_rpc_functions.sql            # Database functions
+│
+└── tests/
+    └── e2e/
+        └── cloud-modes.spec.ts              # E2E tests
+```
+
+### Appendix B: Environment Variables
+
+```bash
+# .env.example
+
+# Supabase (already configured from auth)
+VITE_SUPABASE_URL=https://your-project.supabase.co
+VITE_SUPABASE_ANON_KEY=your-anon-key
+
+# Optional: Future analytics
+VITE_ANALYTICS_KEY=your-analytics-key
+```
+
+### Appendix C: Database Queries Reference
+
+```typescript
+// Common Supabase queries
+
+// Get public modes with author info
+const { data } = await supabase
+  .from('modes')
+  .select(`
+    *,
+    author:author_id (
+      id,
+      email,
+      user_metadata
+    )
+  `)
+  .eq('is_public', true);
+
+// Check if user liked a mode
+const { data } = await supabase
+  .from('mode_likes')
+  .select('*')
+  .match({ user_id: userId, mode_id: modeId })
+  .single();
+
+// Get mode with engagement metrics
+const { data } = await supabase
+  .from('modes')
+  .select(`
+    *,
+    user_liked:mode_likes!left (user_id),
+    user_rating:mode_ratings!left (rating)
+  `)
+  .eq('id', modeId)
+  .eq('mode_likes.user_id', userId)
+  .eq('mode_ratings.user_id', userId)
+  .single();
+
+// Full-text search
+const { data } = await supabase
+  .from('modes')
+  .select('*')
+  .textSearch('fts', 'ableton live', {
+    type: 'websearch',
+    config: 'english'
+  });
+
+// Filter by tags (array contains)
+const { data } = await supabase
+  .from('modes')
+  .select('*')
+  .contains('tags', ['ableton', 'mixing']);
+```
+
+### Appendix D: Common Issues & Solutions
+
+#### Issue: RLS policy denies access
+
+**Solution:**
+- Check user is authenticated: `supabase.auth.getUser()`
+- Verify `author_id` matches `auth.uid()`
+- Check mode is public if viewing as non-owner
+- Review RLS policies in Supabase dashboard
+
+#### Issue: Slow queries
+
+**Solution:**
+- Add indexes for frequently queried columns
+- Use `select('*')` sparingly - only fetch needed columns
+- Implement pagination
+- Use React Query caching effectively
+
+#### Issue: Optimistic update shows wrong state
+
+**Solution:**
+- Ensure `onMutate` creates accurate optimistic state
+- Implement `onError` to rollback
+- Use `onSettled` to refetch from server
+- Check React Query devtools for cache state
+
+#### Issue: User can't create mode
+
+**Solution:**
+- Verify user is authenticated
+- Check RLS policy allows INSERT with `auth.uid() = author_id`
+- Validate mode data matches schema
+- Check Supabase logs for error details
+
+---
+
+**End of Workplan**
diff --git a/src/components/cloud-storage/README.md b/src/components/cloud-storage/README.md
new file mode 100644
index 0000000..452ea5c
--- /dev/null
+++ b/src/components/cloud-storage/README.md
@@ -0,0 +1,169 @@
+# Cloud Storage Components
+
+Components for cloud-based mode storage, browsing, and management.
+
+## Components
+
+### SaveModeDialog
+
+A comprehensive dialog component for saving MIDI controller mode configurations to the cloud.
+
+**File**: `SaveModeDialog.tsx` (431 lines)
+
+#### Features
+
+- Form-based metadata entry with validation
+- Support for name, description, category, tags, and visibility settings
+- Real-time form validation using Zod schemas
+- Loading states during save operations
+- Success/error toast notifications
+- Responsive design for mobile and desktop
+- Accessibility-compliant (WCAG 2.1)
+
+#### Props
+
+```typescript
+interface SaveModeDialogProps {
+  mode: CustomMode;           // The mode to save
+  open: boolean;              // Dialog open state
+  onOpenChange: (open: boolean) => void;  // State change callback
+  onSuccess?: (modeId: string) => void;   // Success callback
+}
+```
+
+#### Usage Example
+
+```tsx
+import { useState } from 'react';
+import { SaveModeDialog } from '@/components/cloud-storage';
+import { CustomMode } from '@/types/mode';
+
+function EditorPage() {
+  const [currentMode, setCurrentMode] = useState<CustomMode>(/* ... */);
+  const [isDialogOpen, setIsDialogOpen] = useState(false);
+
+  const handleSaveSuccess = (modeId: string) => {
+    console.log('Mode saved with ID:', modeId);
+    // Navigate to mode detail page, show confirmation, etc.
+  };
+
+  return (
+    <>
+      <button onClick={() => setIsDialogOpen(true)}>
+        Save to Cloud
+      </button>
+
+      <SaveModeDialog
+        mode={currentMode}
+        open={isDialogOpen}
+        onOpenChange={setIsDialogOpen}
+        onSuccess={handleSaveSuccess}
+      />
+    </>
+  );
+}
+```
+
+#### Form Fields
+
+1. **Name** (required)
+   - Max 255 characters
+   - Alphanumeric with spaces, hyphens, underscores, parentheses
+   - Validation: regex pattern matching
+
+2. **Description** (optional)
+   - Max 1000 characters
+   - Textarea with resize capability
+   - Helps users understand mode purpose
+
+3. **Category** (optional)
+   - Select dropdown with predefined categories:
+     - DAW Control
+     - Live Performance
+     - Mixing & Mastering
+     - Instrument Control
+     - Genre-Specific
+     - Educational
+   - Each option includes description tooltip
+
+4. **Tags** (optional)
+   - Comma-separated input
+   - Max 10 tags
+   - Max 30 characters per tag
+   - Automatically parsed and validated
+
+5. **Is Public** (checkbox)
+   - Default: false (private)
+   - Public modes are visible in community library
+   - Private modes are only visible to the author
+
+#### Integration
+
+The component integrates with:
+
+- `useSaveMode()` hook from `@/hooks/use-cloud-modes`
+- `CustomMode` type from `@/types/mode`
+- `CloudModeMetadata` type from `@/types/cloud-mode`
+- Shadcn/ui components (Dialog, Form, Input, etc.)
+- Sonner toast notifications
+
+#### Error Handling
+
+- Form validation errors displayed inline per field
+- Network/API errors shown via toast notifications
+- Unsaved changes warning when closing dialog
+- Loading state prevents multiple submissions
+
+#### Accessibility
+
+- Proper ARIA labels and descriptions
+- Keyboard navigation support
+- Focus management within dialog
+- Screen reader compatible
+- Color contrast compliant
+
+#### Responsive Design
+
+- Mobile-first approach
+- Scrollable content area on small screens
+- Max height: 90vh with overflow handling
+- Touch-friendly input elements
+
+#### Dependencies
+
+```json
+{
+  "react-hook-form": "^7.x",
+  "@hookform/resolvers": "^3.x",
+  "zod": "^3.x",
+  "lucide-react": "icons",
+  "sonner": "toast notifications"
+}
+```
+
+## File Structure
+
+```
+src/components/cloud-storage/
+├── index.ts                # Barrel exports
+├── SaveModeDialog.tsx      # Save mode dialog component
+└── README.md               # This file
+```
+
+## Future Components
+
+- `BrowseModesDialog.tsx` - Browse and search cloud modes
+- `ModeDetailView.tsx` - Detailed mode information display
+- `ModeCard.tsx` - Mode card for list/grid views
+- `ForkModeDialog.tsx` - Fork existing modes
+- `DeleteModeDialog.tsx` - Delete mode confirmation
+
+## Development Guidelines
+
+- Follow @/ import pattern for all internal imports
+- Use TypeScript strict mode
+- Implement proper error handling (no fallbacks)
+- Keep components under 500 lines
+- Write comprehensive tests
+- Use Zod for validation schemas
+- Follow shadcn/ui patterns
diff --git a/src/components/cloud-storage/SaveModeDialog.tsx b/src/components/cloud-storage/SaveModeDialog.tsx
new file mode 100644
index 0000000..9b5ec6e
--- /dev/null
+++ b/src/components/cloud-storage/SaveModeDialog.tsx
@@ -0,0 +1,431 @@
+/**
+ * Save Mode Dialog Component
+ *
+ * A dialog component for saving the current mode configuration to the cloud.
+ * Provides a comprehensive form for metadata entry including name, description,
+ * category, tags, and visibility settings.
+ *
+ * @module components/cloud-storage/SaveModeDialog
+ */
+
+import * as React from 'react';
+import { useForm } from 'react-hook-form';
+import { zodResolver } from '@hookform/resolvers/zod';
+import { z } from 'zod';
+import { Loader2, Save } from 'lucide-react';
+
+import { CustomMode } from '@/types/mode';
+import { CloudModeMetadata, ModeCategory } from '@/types/cloud-mode';
+import { useSaveMode } from '@/hooks/use-cloud-modes';
+import {
+  Dialog,
+  DialogContent,
+  DialogDescription,
+  DialogFooter,
+  DialogHeader,
+  DialogTitle,
+} from '@/components/ui/dialog';
+import {
+  Form,
+  FormControl,
+  FormDescription,
+  FormField,
+  FormItem,
+  FormLabel,
+  FormMessage,
+} from '@/components/ui/form';
+import {
+  Select,
+  SelectContent,
+  SelectItem,
+  SelectTrigger,
+  SelectValue,
+} from '@/components/ui/select';
+import { Input } from '@/components/ui/input';
+import { Textarea } from '@/components/ui/textarea';
+import { Checkbox } from '@/components/ui/checkbox';
+import { Button } from '@/components/ui/button';
+import { toast } from '@/components/ui/sonner';
+
+// ============================================================================
+// TYPES & SCHEMAS
+// ============================================================================
+
+/**
+ * Form schema using Zod for validation
+ * Matches CloudModeMetadata structure with added UI state
+ */
+const saveModeFormSchema = z.object({
+  name: z
+    .string()
+    .min(1, 'Name is required')
+    .max(255, 'Name must be 255 characters or less')
+    .regex(/^[a-zA-Z0-9\s\-_().]+$/, 'Name contains invalid characters'),
+  description: z
+    .string()
+    .max(1000, 'Description must be 1000 characters or less')
+    .default(''),
+  category: z.enum([
+    'daw-control',
+    'live-performance',
+    'mixing-mastering',
+    'instrument-control',
+    'genre-specific',
+    'educational',
+  ]).optional(),
+  tags: z
+    .string()
+    .max(300, 'Tags input is too long')
+    .transform((val) =>
+      val
+        .split(',')
+        .map((tag) => tag.trim())
+        .filter((tag) => tag.length > 0)
+    )
+    .refine((tags) => tags.length <= 10, {
+      message: 'Maximum 10 tags allowed',
+    })
+    .refine((tags) => tags.every((tag) => tag.length <= 30), {
+      message: 'Each tag must be 30 characters or less',
+    })
+    .default(''),
+  isPublic: z.boolean().default(false),
+});
+
+type SaveModeFormValues = z.infer<typeof saveModeFormSchema>;
+
+/**
+ * Category display metadata for the select dropdown
+ */
+const CATEGORY_OPTIONS: Array<{ value: ModeCategory; label: string; description: string }> = [
+  {
+    value: 'daw-control',
+    label: 'DAW Control',
+    description: 'Digital Audio Workstation control configurations',
+  },
+  {
+    value: 'live-performance',
+    label: 'Live Performance',
+    description: 'Real-time performance and stage setups',
+  },
+  {
+    value: 'mixing-mastering',
+    label: 'Mixing & Mastering',
+    description: 'Studio mixing and mastering configurations',
+  },
+  {
+    value: 'instrument-control',
+    label: 'Instrument Control',
+    description: 'Virtual instrument and plugin control',
+  },
+  {
+    value: 'genre-specific',
+    label: 'Genre-Specific',
+    description: 'Configurations optimized for specific music genres',
+  },
+  {
+    value: 'educational',
+    label: 'Educational',
+    description: 'Teaching and learning configurations',
+  },
+];
+
+// ============================================================================
+// COMPONENT PROPS
+// ============================================================================
+
+export interface SaveModeDialogProps {
+  /** The mode to be saved to the cloud */
+  mode: CustomMode;
+
+  /** Whether the dialog is currently open */
+  open: boolean;
+
+  /** Callback when the dialog open state changes */
+  onOpenChange: (open: boolean) => void;
+
+  /** Optional callback after successful save */
+  onSuccess?: (modeId: string) => void;
+}
+
+// ============================================================================
+// COMPONENT
+// ============================================================================
+
+/**
+ * SaveModeDialog Component
+ *
+ * Provides a form-based dialog for saving a CustomMode to the cloud with
+ * comprehensive metadata including name, description, category, tags, and
+ * visibility settings.
+ *
+ * @example
+ * ```tsx
+ * <SaveModeDialog
+ *   mode={currentMode}
+ *   open={isDialogOpen}
+ *   onOpenChange={setIsDialogOpen}
+ *   onSuccess={(id) => console.log('Saved:', id)}
+ * />
+ * ```
+ */
+export function SaveModeDialog({
+  mode,
+  open,
+  onOpenChange,
+  onSuccess,
+}: SaveModeDialogProps): React.ReactElement {
+  const { saveMode, isLoading } = useSaveMode();
+
+  // Initialize form with default values from the mode
+  const form = useForm<SaveModeFormValues>({
+    resolver: zodResolver(saveModeFormSchema),
+    defaultValues: {
+      name: mode.name || '',
+      description: mode.description || '',
+      category: undefined,
+      tags: '',
+      isPublic: false,
+    },
+  });
+
+  // Reset form when dialog opens with new mode
+  React.useEffect(() => {
+    if (open) {
+      form.reset({
+        name: mode.name || '',
+        description: mode.description || '',
+        category: undefined,
+        tags: '',
+        isPublic: false,
+      });
+    }
+  }, [open, mode, form]);
+
+  /**
+   * Handle form submission
+   */
+  const onSubmit = async (values: SaveModeFormValues): Promise<void> => {
+    try {
+      // Transform form values into CloudModeMetadata
+      const metadata: CloudModeMetadata = {
+        name: values.name,
+        description: values.description,
+        tags: typeof values.tags === 'string' ? [] : values.tags,
+        category: values.category,
+        isPublic: values.isPublic,
+      };
+
+      // Save mode to cloud
+      const result = await saveMode({ mode, metadata });
+
+      // Show success notification
+      toast.success('Mode Saved Successfully', {
+        description: `${values.name} has been saved to the cloud.`,
+      });
+
+      // Close dialog
+      onOpenChange(false);
+
+      // Trigger success callback
+      if (onSuccess && result?.id) {
+        onSuccess(result.id);
+      }
+    } catch (error) {
+      // Error handling - show user-friendly message
+      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
+
+      toast.error('Failed to Save Mode', {
+        description: errorMessage,
+      });
+
+      console.error('Save mode error:', error);
+    }
+  };
+
+  /**
+   * Handle dialog close with unsaved changes warning
+   */
+  const handleOpenChange = (newOpen: boolean): void => {
+    // If closing and form is dirty, could add confirmation here
+    if (!newOpen && form.formState.isDirty && !isLoading) {
+      const confirmed = confirm('You have unsaved changes. Are you sure you want to close?');
+      if (!confirmed) {
+        return;
+      }
+    }
+
+    onOpenChange(newOpen);
+  };
+
+  return (
+    <Dialog open={open} onOpenChange={handleOpenChange}>
+      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
+        <DialogHeader>
+          <DialogTitle>Save Mode to Cloud</DialogTitle>
+          <DialogDescription>
+            Share your mode configuration with the community or save it privately for your own use.
+          </DialogDescription>
+        </DialogHeader>
+
+        <Form {...form}>
+          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
+            {/* Name Field */}
+            <FormField
+              control={form.control}
+              name="name"
+              render={({ field }) => (
+                <FormItem>
+                  <FormLabel>Name *</FormLabel>
+                  <FormControl>
+                    <Input
+                      placeholder="My Awesome Mode"
+                      {...field}
+                      disabled={isLoading}
+                    />
+                  </FormControl>
+                  <FormDescription>
+                    A clear, descriptive name for your mode configuration.
+                  </FormDescription>
+                  <FormMessage />
+                </FormItem>
+              )}
+            />
+
+            {/* Description Field */}
+            <FormField
+              control={form.control}
+              name="description"
+              render={({ field }) => (
+                <FormItem>
+                  <FormLabel>Description</FormLabel>
+                  <FormControl>
+                    <Textarea
+                      placeholder="Describe what makes this mode special and how it should be used..."
+                      className="min-h-[100px] resize-y"
+                      {...field}
+                      disabled={isLoading}
+                    />
+                  </FormControl>
+                  <FormDescription>
+                    Help others understand the purpose and benefits of your mode.
+                  </FormDescription>
+                  <FormMessage />
+                </FormItem>
+              )}
+            />
+
+            {/* Category Field */}
+            <FormField
+              control={form.control}
+              name="category"
+              render={({ field }) => (
+                <FormItem>
+                  <FormLabel>Category</FormLabel>
+                  <Select
+                    onValueChange={field.onChange}
+                    defaultValue={field.value}
+                    disabled={isLoading}
+                  >
+                    <FormControl>
+                      <SelectTrigger>
+                        <SelectValue placeholder="Select a category" />
+                      </SelectTrigger>
+                    </FormControl>
+                    <SelectContent>
+                      {CATEGORY_OPTIONS.map((category) => (
+                        <SelectItem key={category.value} value={category.value}>
+                          <div className="flex flex-col">
+                            <span className="font-medium">{category.label}</span>
+                            <span className="text-xs text-muted-foreground">
+                              {category.description}
+                            </span>
+                          </div>
+                        </SelectItem>
+                      ))}
+                    </SelectContent>
+                  </Select>
+                  <FormDescription>
+                    Choose the category that best fits your mode.
+                  </FormDescription>
+                  <FormMessage />
+                </FormItem>
+              )}
+            />
+
+            {/* Tags Field */}
+            <FormField
+              control={form.control}
+              name="tags"
+              render={({ field }) => (
+                <FormItem>
+                  <FormLabel>Tags</FormLabel>
+                  <FormControl>
+                    <Input
+                      placeholder="ableton, mixing, creative (comma-separated)"
+                      {...field}
+                      disabled={isLoading}
+                    />
+                  </FormControl>
+                  <FormDescription>
+                    Add up to 10 comma-separated tags to help others discover your mode.
+                  </FormDescription>
+                  <FormMessage />
+                </FormItem>
+              )}
+            />
+
+            {/* Public Visibility Checkbox */}
+            <FormField
+              control={form.control}
+              name="isPublic"
+              render={({ field }) => (
+                <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-4">
+                  <FormControl>
+                    <Checkbox
+                      checked={field.value}
+                      onCheckedChange={field.onChange}
+                      disabled={isLoading}
+                    />
+                  </FormControl>
+                  <div className="space-y-1 leading-none">
+                    <FormLabel>Make this mode public</FormLabel>
+                    <FormDescription>
+                      Public modes are visible to all users and can be downloaded from the community library.
+                      Private modes are only visible to you.
+                    </FormDescription>
+                  </div>
+                </FormItem>
+              )}
+            />
+
+            {/* Dialog Footer with Actions */}
+            <DialogFooter>
+              <Button
+                type="button"
+                variant="outline"
+                onClick={() => handleOpenChange(false)}
+                disabled={isLoading}
+              >
+                Cancel
+              </Button>
+              <Button type="submit" disabled={isLoading}>
+                {isLoading ? (
+                  <>
+                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                    Saving...
+                  </>
+                ) : (
+                  <>
+                    <Save className="mr-2 h-4 w-4" />
+                    Save to Cloud
+                  </>
+                )}
+              </Button>
+            </DialogFooter>
+          </form>
+        </Form>
+      </DialogContent>
+    </Dialog>
+  );
+}
diff --git a/src/components/cloud-storage/index.ts b/src/components/cloud-storage/index.ts
new file mode 100644
index 0000000..097e6cf
--- /dev/null
+++ b/src/components/cloud-storage/index.ts
@@ -0,0 +1,10 @@
+/**
+ * Cloud Storage Components
+ *
+ * Components for cloud-based mode storage, browsing, and management.
+ *
+ * @module components/cloud-storage
+ */
+
+export { SaveModeDialog } from './SaveModeDialog';
+export type { SaveModeDialogProps } from './SaveModeDialog';
diff --git a/src/hooks/use-cloud-modes.ts b/src/hooks/use-cloud-modes.ts
new file mode 100644
index 0000000..ba7fb4b
--- /dev/null
+++ b/src/hooks/use-cloud-modes.ts
@@ -0,0 +1,590 @@
+/**
+ * React Query hooks for cloud mode operations
+ *
+ * This module provides React Query hooks for all CloudModeService operations,
+ * including queries for fetching modes and mutations for modifying them.
+ * Implements optimistic updates, cache invalidation, and proper error handling.
+ *
+ * @module hooks/use-cloud-modes
+ */
+
+import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
+import { supabase } from '@/lib/supabase';
+import { createCloudModeService } from '@/services/cloud-mode-service';
+import type {
+  CloudMode,
+  ModeFilters,
+  PaginatedResponse,
+} from '@/services/cloud-mode-service';
+import type { CustomMode } from '@/types/mode';
+
+// ============================================================================
+// SERVICE SINGLETON
+// ============================================================================
+
+/**
+ * Singleton CloudModeService instance
+ * Uses the global Supabase client
+ */
+const cloudModeService = createCloudModeService(supabase);
+
+// ============================================================================
+// QUERY KEYS
+// ============================================================================
+
+/**
+ * Centralized query key factory for cloud modes
+ *
+ * Provides consistent query keys for React Query cache management.
+ * Use these keys for all queries and cache invalidation.
+ */
+export const cloudModeKeys = {
+  /** Base key for all cloud mode queries */
+  all: ['cloud-modes'] as const,
+
+  /** Base key for all mode lists */
+  lists: () => [...cloudModeKeys.all, 'list'] as const,
+
+  /** Key for a specific list with filters */
+  list: (filters: ModeFilters) => [...cloudModeKeys.lists(), filters] as const,
+
+  /** Key for user's private modes */
+  myModes: () => [...cloudModeKeys.all, 'my-modes'] as const,
+
+  /** Key for public modes catalog */
+  publicModes: (filters: ModeFilters) =>
+    [...cloudModeKeys.all, 'public', filters] as const,
+
+  /** Base key for all mode details */
+  details: () => [...cloudModeKeys.all, 'detail'] as const,
+
+  /** Key for a specific mode by ID */
+  detail: (id: string) => [...cloudModeKeys.details(), id] as const,
+};
+
+// ============================================================================
+// QUERY HOOKS
+// ============================================================================
+
+/**
+ * Get all modes for the current user (private library)
+ *
+ * Fetches modes authored by the current user, including both public and private modes.
+ * Requires authentication.
+ *
+ * @returns React Query result with user's modes
+ *
+ * @example
+ * ```tsx
+ * function MyLibrary() {
+ *   const { data: modes, isLoading, error } = useMyModes();
+ *
+ *   if (isLoading) return <Spinner />;
+ *   if (error) return <Error message={error.message} />;
+ *
+ *   return <ModeList modes={modes} />;
+ * }
+ * ```
+ */
+export function useMyModes() {
+  return useQuery({
+    queryKey: cloudModeKeys.myModes(),
+    queryFn: () => cloudModeService.getMyModes(),
+    staleTime: 1 * 60 * 1000, // 1 minute
+    retry: 1, // Only retry once for auth errors
+  });
+}
+
+/**
+ * Get public modes with filters and pagination
+ *
+ * Fetches publicly visible modes from the catalog with optional filtering,
+ * sorting, and pagination. Does not require authentication.
+ *
+ * @param filters - Filter, sort, and pagination options
+ * @returns React Query result with paginated public modes
+ *
+ * @example
+ * ```tsx
+ * function Catalog() {
+ *   const [page, setPage] = useState(1);
+ *   const { data, isLoading } = usePublicModes({
+ *     page,
+ *     limit: 20,
+ *     sort: 'recent',
+ *     category: 'daw-control',
+ *   });
+ *
+ *   return (
+ *     <>
+ *       <ModeGrid modes={data?.data} />
+ *       <Pagination
+ *         current={page}
+ *         total={data?.pagination.totalPages}
+ *         onChange={setPage}
+ *       />
+ *     </>
+ *   );
+ * }
+ * ```
+ */
+export function usePublicModes(filters: ModeFilters = {}) {
+  return useQuery({
+    queryKey: cloudModeKeys.publicModes(filters),
+    queryFn: () => cloudModeService.getPublicModes(filters),
+    staleTime: 5 * 60 * 1000, // 5 minutes
+    placeholderData: (previousData) => previousData, // Keep old data while fetching
+  });
+}
+
+/**
+ * Get a specific mode by ID
+ *
+ * Fetches full details for a single mode. RLS policies determine if the user
+ * can access the mode (public modes or user's own private modes).
+ *
+ * @param id - Mode ID to fetch
+ * @returns React Query result with mode details
+ *
+ * @example
+ * ```tsx
+ * function ModeDetail({ modeId }: { modeId: string }) {
+ *   const { data: mode, isLoading } = useModeById(modeId);
+ *
+ *   if (isLoading) return <Skeleton />;
+ *   if (!mode) return <NotFound />;
+ *
+ *   return <ModeDetailView mode={mode} />;
+ * }
+ * ```
+ */
+export function useModeById(id: string) {
+  return useQuery({
+    queryKey: cloudModeKeys.detail(id),
+    queryFn: () => cloudModeService.getModeById(id),
+    enabled: !!id, // Only run query if ID is provided
+    staleTime: 5 * 60 * 1000, // 5 minutes
+  });
+}
+
+// ============================================================================
+// MUTATION HOOKS
+// ============================================================================
+
+/**
+ * Save a new mode to the cloud
+ *
+ * Creates a new mode in the database. The mode is initially private.
+ * Requires authentication.
+ *
+ * @returns React Query mutation for creating modes
+ *
+ * @example
+ * ```tsx
+ * function SaveButton({ mode }: { mode: CustomMode }) {
+ *   const saveMode = useSaveMode();
+ *
+ *   const handleSave = () => {
+ *     saveMode.mutate(mode, {
+ *       onSuccess: (savedMode) => {
+ *         toast.success(`Mode "${savedMode.name}" saved!`);
+ *         navigate(`/modes/${savedMode.id}`);
+ *       },
+ *       onError: (error) => {
+ *         toast.error(`Failed to save: ${error.message}`);
+ *       },
+ *     });
+ *   };
+ *
+ *   return (
+ *     <button onClick={handleSave} disabled={saveMode.isPending}>
+ *       {saveMode.isPending ? 'Saving...' : 'Save to Cloud'}
+ *     </button>
+ *   );
+ * }
+ * ```
+ */
+export function useSaveMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: (mode: CustomMode) => cloudModeService.saveMode(mode),
+    onSuccess: (savedMode) => {
+      // Invalidate my modes list to show the new mode
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.myModes() });
+
+      // Add to cache for detail view
+      queryClient.setQueryData(cloudModeKeys.detail(savedMode.id), savedMode);
+    },
+  });
+}
+
+/**
+ * Update an existing mode
+ *
+ * Updates mode metadata and/or controls. Only the author can update their modes.
+ * RLS policies enforce this restriction.
+ *
+ * @returns React Query mutation for updating modes
+ *
+ * @example
+ * ```tsx
+ * function EditModeForm({ mode }: { mode: CloudMode }) {
+ *   const updateMode = useUpdateMode();
+ *
+ *   const handleSubmit = (updates: Partial<CloudMode>) => {
+ *     updateMode.mutate(
+ *       { modeId: mode.id, updates },
+ *       {
+ *         onSuccess: () => {
+ *           toast.success('Mode updated!');
+ *         },
+ *       }
+ *     );
+ *   };
+ *
+ *   return <EditForm mode={mode} onSubmit={handleSubmit} />;
+ * }
+ * ```
+ */
+export function useUpdateMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: ({ modeId, updates }: { modeId: string; updates: Partial<CloudMode> }) =>
+      cloudModeService.updateMode(modeId, updates),
+    onSuccess: (updatedMode) => {
+      // Update cache for detail view
+      queryClient.setQueryData(cloudModeKeys.detail(updatedMode.id), updatedMode);
+
+      // Invalidate lists to reflect changes
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.myModes() });
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.lists() });
+    },
+  });
+}
+
+/**
+ * Delete a mode
+ *
+ * Permanently deletes a mode from the database. Only the author can delete their modes.
+ * RLS policies enforce this restriction.
+ *
+ * @returns React Query mutation for deleting modes
+ *
+ * @example
+ * ```tsx
+ * function DeleteButton({ modeId }: { modeId: string }) {
+ *   const deleteMode = useDeleteMode();
+ *
+ *   const handleDelete = () => {
+ *     if (confirm('Are you sure? This cannot be undone.')) {
+ *       deleteMode.mutate(modeId, {
+ *         onSuccess: () => {
+ *           toast.success('Mode deleted');
+ *           navigate('/library');
+ *         },
+ *       });
+ *     }
+ *   };
+ *
+ *   return (
+ *     <button onClick={handleDelete} disabled={deleteMode.isPending}>
+ *       Delete
+ *     </button>
+ *   );
+ * }
+ * ```
+ */
+export function useDeleteMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: (modeId: string) => cloudModeService.deleteMode(modeId),
+    onSuccess: (_, modeId) => {
+      // Remove from cache
+      queryClient.removeQueries({ queryKey: cloudModeKeys.detail(modeId) });
+
+      // Invalidate lists
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.myModes() });
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.lists() });
+    },
+  });
+}
+
+/**
+ * Publish a mode (make it public)
+ *
+ * Makes a private mode visible in the public catalog. Only the author can publish their modes.
+ * Sets the publishedAt timestamp.
+ *
+ * @returns React Query mutation for publishing modes
+ *
+ * @example
+ * ```tsx
+ * function PublishButton({ mode }: { mode: CloudMode }) {
+ *   const publishMode = usePublishMode();
+ *
+ *   const handlePublish = () => {
+ *     publishMode.mutate(mode.id, {
+ *       onSuccess: () => {
+ *         toast.success('Mode is now public!');
+ *       },
+ *     });
+ *   };
+ *
+ *   if (mode.isPublic) {
+ *     return <Badge>Public</Badge>;
+ *   }
+ *
+ *   return (
+ *     <button onClick={handlePublish} disabled={publishMode.isPending}>
+ *       Publish
+ *     </button>
+ *   );
+ * }
+ * ```
+ */
+export function usePublishMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: (modeId: string) => cloudModeService.publishMode(modeId),
+    onSuccess: (publishedMode) => {
+      // Update cache
+      queryClient.setQueryData(cloudModeKeys.detail(publishedMode.id), publishedMode);
+
+      // Invalidate lists to show in public catalog
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.myModes() });
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.publicModes({}) });
+    },
+  });
+}
+
+/**
+ * Unpublish a mode (make it private)
+ *
+ * Removes a mode from the public catalog. Only the author can unpublish their modes.
+ * Clears the publishedAt timestamp.
+ *
+ * @returns React Query mutation for unpublishing modes
+ *
+ * @example
+ * ```tsx
+ * function UnpublishButton({ mode }: { mode: CloudMode }) {
+ *   const unpublishMode = useUnpublishMode();
+ *
+ *   const handleUnpublish = () => {
+ *     unpublishMode.mutate(mode.id, {
+ *       onSuccess: () => {
+ *         toast.success('Mode is now private');
+ *       },
+ *     });
+ *   };
+ *
+ *   return (
+ *     <button onClick={handleUnpublish} disabled={unpublishMode.isPending}>
+ *       Make Private
+ *     </button>
+ *   );
+ * }
+ * ```
+ */
+export function useUnpublishMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: (modeId: string) => cloudModeService.unpublishMode(modeId),
+    onSuccess: (unpublishedMode) => {
+      // Update cache
+      queryClient.setQueryData(cloudModeKeys.detail(unpublishedMode.id), unpublishedMode);
+
+      // Invalidate lists to remove from public catalog
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.myModes() });
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.publicModes({}) });
+    },
+  });
+}
+
+/**
+ * Like or unlike a mode (toggle)
+ *
+ * Toggles the like status for the current user. Uses optimistic updates for instant
+ * feedback. Requires authentication.
+ *
+ * @returns React Query mutation for liking/unliking modes
+ *
+ * @example
+ * ```tsx
+ * function LikeButton({ mode }: { mode: CloudMode }) {
+ *   const toggleLike = useLikeMode();
+ *
+ *   const handleClick = () => {
+ *     toggleLike.mutate({
+ *       modeId: mode.id,
+ *       currentlyLiked: mode.userLiked || false,
+ *     });
+ *   };
+ *
+ *   return (
+ *     <button onClick={handleClick} disabled={toggleLike.isPending}>
+ *       <Heart fill={mode.userLiked ? 'red' : 'none'} />
+ *       {mode.likes}
+ *     </button>
+ *   );
+ * }
+ * ```
+ */
+export function useLikeMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: async ({
+      modeId,
+      currentlyLiked,
+    }: {
+      modeId: string;
+      currentlyLiked: boolean;
+    }) => {
+      if (currentlyLiked) {
+        await cloudModeService.unlikeMode(modeId);
+      } else {
+        await cloudModeService.likeMode(modeId);
+      }
+    },
+    onMutate: async ({ modeId, currentlyLiked }) => {
+      // Cancel outgoing refetches
+      await queryClient.cancelQueries({ queryKey: cloudModeKeys.detail(modeId) });
+
+      // Snapshot previous value
+      const previousMode = queryClient.getQueryData<CloudMode>(
+        cloudModeKeys.detail(modeId)
+      );
+
+      // Optimistically update
+      if (previousMode) {
+        const optimisticMode: CloudMode = {
+          ...previousMode,
+          likes: currentlyLiked ? previousMode.likes - 1 : previousMode.likes + 1,
+          userLiked: !currentlyLiked,
+        };
+        queryClient.setQueryData(cloudModeKeys.detail(modeId), optimisticMode);
+      }
+
+      return { previousMode };
+    },
+    onError: (err, { modeId }, context) => {
+      // Rollback on error
+      if (context?.previousMode) {
+        queryClient.setQueryData(cloudModeKeys.detail(modeId), context.previousMode);
+      }
+    },
+    onSettled: (data, error, { modeId }) => {
+      // Refetch to sync with server
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.detail(modeId) });
+    },
+  });
+}
+
+/**
+ * Rate a mode with optional review
+ *
+ * Submits or updates a rating (1-5 stars) for a mode with optional review text.
+ * Users can only rate once per mode (upsert behavior). Requires authentication.
+ *
+ * @returns React Query mutation for rating modes
+ *
+ * @example
+ * ```tsx
+ * function RatingForm({ modeId }: { modeId: string }) {
+ *   const rateMode = useRateMode();
+ *   const [rating, setRating] = useState(5);
+ *   const [review, setReview] = useState('');
+ *
+ *   const handleSubmit = () => {
+ *     rateMode.mutate(
+ *       { modeId, rating, review },
+ *       {
+ *         onSuccess: () => {
+ *           toast.success('Thanks for your rating!');
+ *         },
+ *       }
+ *     );
+ *   };
+ *
+ *   return (
+ *     <form onSubmit={handleSubmit}>
+ *       <StarRating value={rating} onChange={setRating} />
+ *       <textarea value={review} onChange={(e) => setReview(e.target.value)} />
+ *       <button type="submit" disabled={rateMode.isPending}>
+ *         Submit Rating
+ *       </button>
+ *     </form>
+ *   );
+ * }
+ * ```
+ */
+export function useRateMode() {
+  const queryClient = useQueryClient();
+
+  return useMutation({
+    mutationFn: ({
+      modeId,
+      rating,
+      review,
+    }: {
+      modeId: string;
+      rating: number;
+      review?: string;
+    }) => cloudModeService.rateMode(modeId, rating, review),
+    onSuccess: (_, { modeId }) => {
+      // Invalidate mode detail to refetch updated rating
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.detail(modeId) });
+
+      // Invalidate lists if sort is by rating
+      queryClient.invalidateQueries({ queryKey: cloudModeKeys.publicModes({}) });
+    },
+  });
+}
+
+// ============================================================================
+// UTILITY HOOKS
+// ============================================================================
+
+/**
+ * Check if a mode is liked by the current user
+ *
+ * Convenience hook to determine like status without fetching full mode details.
+ *
+ * @param mode - Cloud mode to check
+ * @returns True if user has liked the mode
+ */
+export function useIsLiked(mode: CloudMode | null | undefined): boolean {
+  return mode?.userLiked || false;
+}
+
+/**
+ * Get the current user's rating for a mode
+ *
+ * Convenience hook to get user's rating without additional queries.
+ *
+ * @param mode - Cloud mode to check
+ * @returns User's rating (1-5) or undefined if not rated
+ */
+export function useUserRating(mode: CloudMode | null | undefined): number | undefined {
+  return mode?.userRating;
+}
+
+/**
+ * Check if the current user is the author of a mode
+ *
+ * Useful for conditionally showing edit/delete actions.
+ *
+ * @param mode - Cloud mode to check
+ * @returns True if current user is the author
+ */
+export function useIsAuthor(mode: CloudMode | null | undefined): boolean {
+  const { data: myModes } = useMyModes();
+  if (!mode || !myModes) return false;
+  return myModes.some((m) => m.id === mode.id);
+}
diff --git a/src/lib/supabase/migrations/001_create_modes_table.sql b/src/lib/supabase/migrations/001_create_modes_table.sql
new file mode 100644
index 0000000..5afd8b8
--- /dev/null
+++ b/src/lib/supabase/migrations/001_create_modes_table.sql
@@ -0,0 +1,171 @@
+-- Migration: 001_create_modes_table.sql
+-- Description: Create core modes table with user ownership and engagement metrics
+-- Created: 2025-10-08
+
+-- Modes table (core storage for custom controller modes)
+CREATE TABLE IF NOT EXISTS modes (
+  -- Primary identification
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
+
+  -- Mode metadata
+  name VARCHAR(255) NOT NULL,
+  description TEXT,
+  version VARCHAR(20) NOT NULL DEFAULT '1.0.0',
+
+  -- Mode data (JSONB for flexibility and queryability)
+  controls JSONB NOT NULL DEFAULT '{}'::jsonb,
+
+  -- Visibility flags
+  is_public BOOLEAN NOT NULL DEFAULT false,
+  is_official BOOLEAN NOT NULL DEFAULT false,
+  is_featured BOOLEAN NOT NULL DEFAULT false,
+
+  -- Engagement metrics (denormalized for performance)
+  downloads INTEGER NOT NULL DEFAULT 0,
+  likes INTEGER NOT NULL DEFAULT 0,
+  views INTEGER NOT NULL DEFAULT 0,
+  fork_count INTEGER NOT NULL DEFAULT 0,
+  rating DECIMAL(3,2) DEFAULT 0,
+  rating_count INTEGER NOT NULL DEFAULT 0,
+
+  -- Discovery metadata
+  tags TEXT[] DEFAULT '{}',
+  category VARCHAR(100),
+  thumbnail TEXT, -- Base64 or URL (future: Supabase Storage)
+
+  -- Relationships
+  parent_mode_id UUID REFERENCES modes(id) ON DELETE SET NULL,
+
+  -- Timestamps
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  modified_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  published_at TIMESTAMPTZ,
+
+  -- Constraints
+  CONSTRAINT valid_rating CHECK (rating >= 0 AND rating <= 5),
+  CONSTRAINT valid_version CHECK (version ~ '^\d+\.\d+\.\d+$')
+);
+
+-- Add comment for documentation
+COMMENT ON TABLE modes IS 'Stores custom MIDI controller modes created by users';
+COMMENT ON COLUMN modes.controls IS 'JSONB object containing control mappings (knobs, faders, buttons)';
+COMMENT ON COLUMN modes.is_public IS 'Whether mode is visible in public catalog';
+COMMENT ON COLUMN modes.is_official IS 'Marks official/verified modes';
+COMMENT ON COLUMN modes.is_featured IS 'Featured modes shown prominently in UI';
+COMMENT ON COLUMN modes.parent_mode_id IS 'Reference to original mode if this is a fork';
+
+-- Mode versions table (version history tracking)
+CREATE TABLE IF NOT EXISTS mode_versions (
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  mode_id UUID NOT NULL REFERENCES modes(id) ON DELETE CASCADE,
+  version VARCHAR(20) NOT NULL,
+  changes TEXT,
+  controls JSONB NOT NULL,
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+  UNIQUE(mode_id, version)
+);
+
+COMMENT ON TABLE mode_versions IS 'Tracks version history of mode changes';
+
+-- Categories table (predefined mode categories)
+CREATE TABLE IF NOT EXISTS categories (
+  id VARCHAR(100) PRIMARY KEY,
+  name VARCHAR(100) NOT NULL,
+  description TEXT,
+  icon VARCHAR(50),
+  display_order INTEGER NOT NULL DEFAULT 0,
+
+  UNIQUE(name)
+);
+
+COMMENT ON TABLE categories IS 'Predefined categories for organizing modes';
+
+-- Insert default categories
+INSERT INTO categories (id, name, description, display_order) VALUES
+  ('daw-control', 'DAW Control', 'Digital Audio Workstation control surfaces', 1),
+  ('live-performance', 'Live Performance', 'Setups for live shows and DJing', 2),
+  ('mixing-mastering', 'Mixing & Mastering', 'Studio mixing and mastering workflows', 3),
+  ('instrument-control', 'Instrument Control', 'Hardware synth and instrument mappings', 4),
+  ('genre-specific', 'Genre-Specific', 'Genre-optimized configurations', 5),
+  ('educational', 'Educational', 'Learning and tutorial modes', 6)
+ON CONFLICT (id) DO NOTHING;
+
+-- Trigger function to update modified_at timestamp
+CREATE OR REPLACE FUNCTION update_modified_at()
+RETURNS TRIGGER AS $$
+BEGIN
+  NEW.modified_at = NOW();
+  RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION update_modified_at() IS 'Automatically updates modified_at timestamp on row update';
+
+-- Apply trigger to modes table
+CREATE TRIGGER modes_modified_at
+  BEFORE UPDATE ON modes
+  FOR EACH ROW
+  EXECUTE FUNCTION update_modified_at();
+
+-- Database functions for atomic operations
+-- Function to increment likes atomically
+CREATE OR REPLACE FUNCTION increment_likes(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET likes = likes + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION increment_likes(UUID) IS 'Atomically increments like count for a mode';
+
+-- Function to decrement likes atomically
+CREATE OR REPLACE FUNCTION decrement_likes(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET likes = GREATEST(likes - 1, 0)
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION decrement_likes(UUID) IS 'Atomically decrements like count for a mode (minimum 0)';
+
+-- Function to increment fork count atomically
+CREATE OR REPLACE FUNCTION increment_fork_count(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET fork_count = fork_count + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION increment_fork_count(UUID) IS 'Atomically increments fork count when mode is forked';
+
+-- Function to increment views atomically
+CREATE OR REPLACE FUNCTION increment_views(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET views = views + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION increment_views(UUID) IS 'Atomically increments view count for a mode';
+
+-- Function to increment downloads atomically
+CREATE OR REPLACE FUNCTION increment_downloads(mode_id UUID)
+RETURNS void AS $$
+BEGIN
+  UPDATE modes
+  SET downloads = downloads + 1
+  WHERE id = mode_id;
+END;
+$$ LANGUAGE plpgsql SECURITY DEFINER;
+
+COMMENT ON FUNCTION increment_downloads(UUID) IS 'Atomically increments download count for a mode';
diff --git a/src/lib/supabase/migrations/002_create_engagement_tables.sql b/src/lib/supabase/migrations/002_create_engagement_tables.sql
new file mode 100644
index 0000000..2f6926c
--- /dev/null
+++ b/src/lib/supabase/migrations/002_create_engagement_tables.sql
@@ -0,0 +1,69 @@
+-- Migration: 002_create_engagement_tables.sql
+-- Description: Create engagement tables for likes, ratings, and related functionality
+-- Created: 2025-10-08
+
+-- Mode likes table (many-to-many relationship)
+CREATE TABLE IF NOT EXISTS mode_likes (
+  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
+  mode_id UUID NOT NULL REFERENCES modes(id) ON DELETE CASCADE,
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+  PRIMARY KEY (user_id, mode_id)
+);
+
+COMMENT ON TABLE mode_likes IS 'Tracks which users have liked which modes';
+COMMENT ON COLUMN mode_likes.user_id IS 'User who liked the mode';
+COMMENT ON COLUMN mode_likes.mode_id IS 'Mode that was liked';
+
+-- Mode ratings table (one rating per user per mode)
+CREATE TABLE IF NOT EXISTS mode_ratings (
+  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
+  mode_id UUID NOT NULL REFERENCES modes(id) ON DELETE CASCADE,
+  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
+  review TEXT,
+  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+  PRIMARY KEY (user_id, mode_id)
+);
+
+COMMENT ON TABLE mode_ratings IS 'Stores user ratings and reviews for modes';
+COMMENT ON COLUMN mode_ratings.rating IS 'Rating from 1-5 stars';
+COMMENT ON COLUMN mode_ratings.review IS 'Optional text review';
+
+-- Trigger for updated_at on mode_ratings
+CREATE TRIGGER mode_ratings_updated_at
+  BEFORE UPDATE ON mode_ratings
+  FOR EACH ROW
+  EXECUTE FUNCTION update_modified_at();
+
+-- Function to update mode rating aggregate (maintains denormalized data)
+CREATE OR REPLACE FUNCTION update_mode_rating()
+RETURNS TRIGGER AS $$
+BEGIN
+  -- Handle both INSERT/UPDATE and DELETE operations
+  IF TG_OP = 'DELETE' THEN
+    UPDATE modes
+    SET
+      rating = COALESCE((SELECT AVG(rating)::DECIMAL(3,2) FROM mode_ratings WHERE mode_id = OLD.mode_id), 0),
+      rating_count = (SELECT COUNT(*) FROM mode_ratings WHERE mode_id = OLD.mode_id)
+    WHERE id = OLD.mode_id;
+    RETURN OLD;
+  ELSE
+    UPDATE modes
+    SET
+      rating = COALESCE((SELECT AVG(rating)::DECIMAL(3,2) FROM mode_ratings WHERE mode_id = NEW.mode_id), 0),
+      rating_count = (SELECT COUNT(*) FROM mode_ratings WHERE mode_id = NEW.mode_id)
+    WHERE id = NEW.mode_id;
+    RETURN NEW;
+  END IF;
+END;
+$$ LANGUAGE plpgsql;
+
+COMMENT ON FUNCTION update_mode_rating() IS 'Automatically updates aggregate rating and count on modes table';
+
+-- Trigger to update mode rating aggregate after any change to mode_ratings
+CREATE TRIGGER mode_ratings_update_aggregate
+  AFTER INSERT OR UPDATE OR DELETE ON mode_ratings
+  FOR EACH ROW
+  EXECUTE FUNCTION update_mode_rating();
diff --git a/src/lib/supabase/migrations/003_add_rls_policies.sql b/src/lib/supabase/migrations/003_add_rls_policies.sql
new file mode 100644
index 0000000..c8b3bc8
--- /dev/null
+++ b/src/lib/supabase/migrations/003_add_rls_policies.sql
@@ -0,0 +1,210 @@
+-- Migration: 003_add_rls_policies.sql
+-- Description: Row Level Security policies for modes, likes, ratings, and versions
+-- Created: 2025-10-08
+
+-- Enable RLS on all tables
+ALTER TABLE modes ENABLE ROW LEVEL SECURITY;
+ALTER TABLE mode_likes ENABLE ROW LEVEL SECURITY;
+ALTER TABLE mode_ratings ENABLE ROW LEVEL SECURITY;
+ALTER TABLE mode_versions ENABLE ROW LEVEL SECURITY;
+
+-- ============================================================================
+-- MODES TABLE POLICIES
+-- ============================================================================
+
+-- Policy: Anyone can view public modes
+CREATE POLICY "Public modes are viewable by everyone"
+  ON modes FOR SELECT
+  USING (is_public = true);
+
+COMMENT ON POLICY "Public modes are viewable by everyone" ON modes IS
+  'Allows unauthenticated and authenticated users to view modes marked as public';
+
+-- Policy: Users can view their own modes (public or private)
+CREATE POLICY "Users can view own modes"
+  ON modes FOR SELECT
+  USING (auth.uid() = author_id);
+
+COMMENT ON POLICY "Users can view own modes" ON modes IS
+  'Allows users to view all their own modes regardless of public status';
+
+-- Policy: Users can create modes (author_id must match auth.uid())
+CREATE POLICY "Users can create modes"
+  ON modes FOR INSERT
+  WITH CHECK (auth.uid() = author_id);
+
+COMMENT ON POLICY "Users can create modes" ON modes IS
+  'Ensures users can only create modes with themselves as the author';
+
+-- Policy: Users can update their own modes
+CREATE POLICY "Users can update own modes"
+  ON modes FOR UPDATE
+  USING (auth.uid() = author_id)
+  WITH CHECK (auth.uid() = author_id);
+
+COMMENT ON POLICY "Users can update own modes" ON modes IS
+  'Allows users to update only their own modes and prevents changing author_id';
+
+-- Policy: Users can delete their own modes
+CREATE POLICY "Users can delete own modes"
+  ON modes FOR DELETE
+  USING (auth.uid() = author_id);
+
+COMMENT ON POLICY "Users can delete own modes" ON modes IS
+  'Allows users to delete only their own modes';
+
+-- Policy: Admins have full access (requires custom JWT claims)
+CREATE POLICY "Admins have full access to modes"
+  ON modes
+  USING (
+    (auth.jwt() ->> 'user_role')::text = 'admin'
+  );
+
+COMMENT ON POLICY "Admins have full access to modes" ON modes IS
+  'Grants full CRUD access to users with admin role in JWT claims';
+
+-- ============================================================================
+-- MODE_LIKES TABLE POLICIES
+-- ============================================================================
+
+-- Policy: Anyone can view likes on public modes
+CREATE POLICY "Public mode likes are viewable"
+  ON mode_likes FOR SELECT
+  USING (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_likes.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+COMMENT ON POLICY "Public mode likes are viewable" ON mode_likes IS
+  'Allows viewing likes for public modes only';
+
+-- Policy: Users can view their own likes
+CREATE POLICY "Users can view own likes"
+  ON mode_likes FOR SELECT
+  USING (auth.uid() = user_id);
+
+COMMENT ON POLICY "Users can view own likes" ON mode_likes IS
+  'Allows users to see which modes they have liked';
+
+-- Policy: Authenticated users can like public modes
+CREATE POLICY "Authenticated users can like modes"
+  ON mode_likes FOR INSERT
+  WITH CHECK (
+    auth.uid() = user_id
+    AND EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_likes.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+COMMENT ON POLICY "Authenticated users can like modes" ON mode_likes IS
+  'Allows authenticated users to like public modes only';
+
+-- Policy: Users can unlike modes they liked
+CREATE POLICY "Users can unlike modes"
+  ON mode_likes FOR DELETE
+  USING (auth.uid() = user_id);
+
+COMMENT ON POLICY "Users can unlike modes" ON mode_likes IS
+  'Allows users to remove their own likes';
+
+-- ============================================================================
+-- MODE_RATINGS TABLE POLICIES
+-- ============================================================================
+
+-- Policy: Anyone can view ratings on public modes
+CREATE POLICY "Public mode ratings are viewable"
+  ON mode_ratings FOR SELECT
+  USING (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_ratings.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+COMMENT ON POLICY "Public mode ratings are viewable" ON mode_ratings IS
+  'Allows viewing ratings and reviews for public modes';
+
+-- Policy: Users can view their own ratings
+CREATE POLICY "Users can view own ratings"
+  ON mode_ratings FOR SELECT
+  USING (auth.uid() = user_id);
+
+COMMENT ON POLICY "Users can view own ratings" ON mode_ratings IS
+  'Allows users to see their own ratings and reviews';
+
+-- Policy: Authenticated users can rate public modes
+CREATE POLICY "Authenticated users can rate modes"
+  ON mode_ratings FOR INSERT
+  WITH CHECK (
+    auth.uid() = user_id
+    AND EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_ratings.mode_id
+      AND modes.is_public = true
+    )
+  );
+
+COMMENT ON POLICY "Authenticated users can rate modes" ON mode_ratings IS
+  'Allows authenticated users to rate and review public modes';
+
+-- Policy: Users can update their own ratings
+CREATE POLICY "Users can update own ratings"
+  ON mode_ratings FOR UPDATE
+  USING (auth.uid() = user_id)
+  WITH CHECK (auth.uid() = user_id);
+
+COMMENT ON POLICY "Users can update own ratings" ON mode_ratings IS
+  'Allows users to modify their existing ratings and reviews';
+
+-- Policy: Users can delete their own ratings
+CREATE POLICY "Users can delete own ratings"
+  ON mode_ratings FOR DELETE
+  USING (auth.uid() = user_id);
+
+COMMENT ON POLICY "Users can delete own ratings" ON mode_ratings IS
+  'Allows users to remove their ratings and reviews';
+
+-- ============================================================================
+-- MODE_VERSIONS TABLE POLICIES
+-- ============================================================================
+
+-- Policy: Users can view versions of modes they can access
+CREATE POLICY "Users can view accessible mode versions"
+  ON mode_versions FOR SELECT
+  USING (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_versions.mode_id
+      AND (modes.is_public = true OR modes.author_id = auth.uid())
+    )
+  );
+
+COMMENT ON POLICY "Users can view accessible mode versions" ON mode_versions IS
+  'Allows viewing version history for public modes or user''s own modes';
+
+-- Policy: Only mode authors can create versions
+CREATE POLICY "Authors can create mode versions"
+  ON mode_versions FOR INSERT
+  WITH CHECK (
+    EXISTS (
+      SELECT 1 FROM modes
+      WHERE modes.id = mode_versions.mode_id
+      AND modes.author_id = auth.uid()
+    )
+  );
+
+COMMENT ON POLICY "Authors can create mode versions" ON mode_versions IS
+  'Allows only mode authors to create version history entries';
+
+-- ============================================================================
+-- CATEGORIES TABLE
+-- ============================================================================
+-- Categories are public (read-only for all users)
+-- No RLS needed - all users can read, only admins can modify via Supabase dashboard
+-- Not enabling RLS on categories table as it's meant to be fully public
diff --git a/src/lib/supabase/migrations/004_add_indexes.sql b/src/lib/supabase/migrations/004_add_indexes.sql
new file mode 100644
index 0000000..f1366f3
--- /dev/null
+++ b/src/lib/supabase/migrations/004_add_indexes.sql
@@ -0,0 +1,187 @@
+-- Migration: 004_add_indexes.sql
+-- Description: Performance indexes for common query patterns
+-- Created: 2025-10-08
+
+-- ============================================================================
+-- MODES TABLE INDEXES
+-- ============================================================================
+
+-- Index: Lookup modes by author (user's library)
+CREATE INDEX IF NOT EXISTS idx_modes_author
+  ON modes(author_id);
+
+COMMENT ON INDEX idx_modes_author IS
+  'Optimizes queries for user''s own modes (library page)';
+
+-- Index: Filter public modes (catalog browsing)
+CREATE INDEX IF NOT EXISTS idx_modes_public
+  ON modes(is_public)
+  WHERE is_public = true;
+
+COMMENT ON INDEX idx_modes_public IS
+  'Partial index for efficient public mode filtering';
+
+-- Index: Featured modes (homepage, promotions)
+CREATE INDEX IF NOT EXISTS idx_modes_featured
+  ON modes(is_featured)
+  WHERE is_featured = true;
+
+COMMENT ON INDEX idx_modes_featured IS
+  'Partial index for featured modes display';
+
+-- Index: Filter by category
+CREATE INDEX IF NOT EXISTS idx_modes_category
+  ON modes(category);
+
+COMMENT ON INDEX idx_modes_category IS
+  'Optimizes category filtering in catalog';
+
+-- Index: Filter by tags (array contains queries)
+CREATE INDEX IF NOT EXISTS idx_modes_tags
+  ON modes USING GIN(tags);
+
+COMMENT ON INDEX idx_modes_tags IS
+  'GIN index for efficient tag-based filtering and search';
+
+-- Index: Sort by creation date (most recent first)
+CREATE INDEX IF NOT EXISTS idx_modes_created
+  ON modes(created_at DESC);
+
+COMMENT ON INDEX idx_modes_created IS
+  'Optimizes sorting by newest modes';
+
+-- Index: Sort by downloads (most popular)
+CREATE INDEX IF NOT EXISTS idx_modes_downloads
+  ON modes(downloads DESC);
+
+COMMENT ON INDEX idx_modes_downloads IS
+  'Optimizes sorting by download count';
+
+-- Index: Sort by likes (community favorites)
+CREATE INDEX IF NOT EXISTS idx_modes_likes
+  ON modes(likes DESC);
+
+COMMENT ON INDEX idx_modes_likes IS
+  'Optimizes sorting by like count';
+
+-- Index: Sort by rating (highest rated)
+CREATE INDEX IF NOT EXISTS idx_modes_rating
+  ON modes(rating DESC NULLS LAST);
+
+COMMENT ON INDEX idx_modes_rating IS
+  'Optimizes sorting by rating, placing unrated modes last';
+
+-- Index: Full-text search on name and description
+CREATE INDEX IF NOT EXISTS idx_modes_search
+  ON modes USING GIN(
+    to_tsvector('english', name || ' ' || COALESCE(description, ''))
+  );
+
+COMMENT ON INDEX idx_modes_search IS
+  'Full-text search index for mode name and description';
+
+-- Composite index: Public modes sorted by creation date
+CREATE INDEX IF NOT EXISTS idx_modes_public_created
+  ON modes(is_public, created_at DESC)
+  WHERE is_public = true;
+
+COMMENT ON INDEX idx_modes_public_created IS
+  'Optimizes catalog browsing with default sort';
+
+-- Composite index: Public modes by category and creation date
+CREATE INDEX IF NOT EXISTS idx_modes_public_category_created
+  ON modes(is_public, category, created_at DESC)
+  WHERE is_public = true;
+
+COMMENT ON INDEX idx_modes_public_category_created IS
+  'Optimizes filtered catalog browsing by category';
+
+-- ============================================================================
+-- MODE_LIKES TABLE INDEXES
+-- ============================================================================
+
+-- Index: Lookup likes by mode (for displaying like counts)
+CREATE INDEX IF NOT EXISTS idx_mode_likes_mode
+  ON mode_likes(mode_id);
+
+COMMENT ON INDEX idx_mode_likes_mode IS
+  'Optimizes counting likes for a specific mode';
+
+-- Index: Lookup likes by user (user's liked modes)
+CREATE INDEX IF NOT EXISTS idx_mode_likes_user
+  ON mode_likes(user_id);
+
+COMMENT ON INDEX idx_mode_likes_user IS
+  'Optimizes queries for modes liked by a specific user';
+
+-- Composite index: Check if user liked a specific mode
+CREATE INDEX IF NOT EXISTS idx_mode_likes_user_mode
+  ON mode_likes(user_id, mode_id);
+
+COMMENT ON INDEX idx_mode_likes_user_mode IS
+  'Optimizes checking if a specific user liked a specific mode';
+
+-- ============================================================================
+-- MODE_RATINGS TABLE INDEXES
+-- ============================================================================
+
+-- Index: Lookup ratings by mode (for calculating averages)
+CREATE INDEX IF NOT EXISTS idx_mode_ratings_mode
+  ON mode_ratings(mode_id);
+
+COMMENT ON INDEX idx_mode_ratings_mode IS
+  'Optimizes aggregating ratings for a specific mode';
+
+-- Index: Lookup ratings by user (user's rating history)
+CREATE INDEX IF NOT EXISTS idx_mode_ratings_user
+  ON mode_ratings(user_id);
+
+COMMENT ON INDEX idx_mode_ratings_user IS
+  'Optimizes queries for ratings by a specific user';
+
+-- Composite index: Recent ratings (for activity feeds)
+CREATE INDEX IF NOT EXISTS idx_mode_ratings_created
+  ON mode_ratings(mode_id, created_at DESC);
+
+COMMENT ON INDEX idx_mode_ratings_created IS
+  'Optimizes displaying recent ratings for a mode';
+
+-- ============================================================================
+-- MODE_VERSIONS TABLE INDEXES
+-- ============================================================================
+
+-- Index: Lookup versions by mode (version history)
+CREATE INDEX IF NOT EXISTS idx_mode_versions_mode
+  ON mode_versions(mode_id, created_at DESC);
+
+COMMENT ON INDEX idx_mode_versions_mode IS
+  'Optimizes retrieving version history for a mode';
+
+-- Index: Lookup specific version
+CREATE INDEX IF NOT EXISTS idx_mode_versions_mode_version
+  ON mode_versions(mode_id, version);
+
+COMMENT ON INDEX idx_mode_versions_mode_version IS
+  'Optimizes retrieving a specific version of a mode';
+
+-- ============================================================================
+-- CATEGORIES TABLE INDEXES
+-- ============================================================================
+
+-- Index: Order categories by display order
+CREATE INDEX IF NOT EXISTS idx_categories_display_order
+  ON categories(display_order);
+
+COMMENT ON INDEX idx_categories_display_order IS
+  'Optimizes ordering categories for display';
+
+-- ============================================================================
+-- ANALYZE TABLES FOR QUERY PLANNER
+-- ============================================================================
+
+-- Update statistics for query planner optimization
+ANALYZE modes;
+ANALYZE mode_likes;
+ANALYZE mode_ratings;
+ANALYZE mode_versions;
+ANALYZE categories;
diff --git a/src/services/cloud-mode-service.ts b/src/services/cloud-mode-service.ts
new file mode 100644
index 0000000..ca168aa
--- /dev/null
+++ b/src/services/cloud-mode-service.ts
@@ -0,0 +1,658 @@
+/**
+ * CloudModeService - Interface-first service for cloud mode operations
+ *
+ * This service handles all CRUD operations and engagement features for cloud-stored
+ * MIDI controller modes. Uses dependency injection for the Supabase client.
+ *
+ * @module services/cloud-mode-service
+ */
+
+import { SupabaseClient } from '@supabase/supabase-js';
+import type { CustomMode } from '@/types/mode';
+
+// ============================================================================
+// Type Definitions
+// ============================================================================
+
+/**
+ * Pagination options for browsing modes
+ */
+export interface PaginationOptions {
+  page?: number;
+  limit?: number;
+  sort?: 'recent' | 'downloads' | 'likes' | 'rating';
+}
+
+/**
+ * Filter options for browsing modes
+ */
+export interface ModeFilters extends PaginationOptions {
+  category?: string;
+  tags?: string[];
+  authorId?: string;
+  isPublic?: boolean;
+  isFeatured?: boolean;
+  search?: string;
+}
+
+/**
+ * Cloud-stored mode with full metadata
+ */
+export interface CloudMode extends CustomMode {
+  // Unique identification
+  id: string;
+
+  // Ownership
+  authorId: string;
+  author?: {
+    id: string;
+    email: string;
+    displayName: string;
+    avatarUrl?: string;
+  };
+
+  // Visibility
+  isPublic: boolean;
+  isOfficial: boolean;
+  isFeatured: boolean;
+
+  // Engagement (denormalized)
+  downloads: number;
+  likes: number;
+  views: number;
+  rating: number;
+  ratingCount: number;
+  forkCount: number;
+
+  // Discovery
+  tags: string[];
+  category?: string;
+  thumbnail?: string;
+
+  // Relationships
+  parentModeId?: string;
+  parentMode?: CloudMode;
+
+  // Timestamps
+  publishedAt?: string;
+  updatedAt: string;
+
+  // Client-side computed
+  userLiked?: boolean;
+  userRating?: number;
+}
+
+/**
+ * Paginated response wrapper
+ */
+export interface PaginatedResponse<T> {
+  data: T[];
+  pagination: {
+    page: number;
+    limit: number;
+    total: number;
+    totalPages: number;
+    hasNext: boolean;
+    hasPrev: boolean;
+  };
+}
+
+/**
+ * Database row type (snake_case from PostgreSQL)
+ */
+interface ModeRow {
+  id: string;
+  author_id: string;
+  name: string;
+  description: string | null;
+  version: string;
+  controls: Record<string, unknown>;
+  is_public: boolean;
+  is_official: boolean;
+  is_featured: boolean;
+  downloads: number;
+  likes: number;
+  views: number;
+  fork_count: number;
+  rating: number | null;
+  rating_count: number;
+  tags: string[];
+  category: string | null;
+  thumbnail: string | null;
+  parent_mode_id: string | null;
+  created_at: string;
+  modified_at: string;
+  published_at: string | null;
+}
+
+/**
+ * Database insert type
+ */
+interface ModeInsert {
+  id?: string;
+  author_id: string;
+  name: string;
+  description?: string | null;
+  version?: string;
+  controls: Record<string, unknown>;
+  is_public?: boolean;
+  is_official?: boolean;
+  is_featured?: boolean;
+  tags?: string[];
+  category?: string | null;
+  thumbnail?: string | null;
+  parent_mode_id?: string | null;
+}
+
+/**
+ * Database update type
+ */
+interface ModeUpdate {
+  name?: string;
+  description?: string | null;
+  version?: string;
+  controls?: Record<string, unknown>;
+  is_public?: boolean;
+  tags?: string[];
+  category?: string | null;
+  thumbnail?: string | null;
+}
+
+// ============================================================================
+// Service Interface
+// ============================================================================
+
+/**
+ * Interface for cloud mode operations
+ */
+export interface ICloudModeService {
+  /**
+   * Save a custom mode to the cloud
+   */
+  saveMode(mode: CustomMode): Promise<CloudMode>;
+
+  /**
+   * Get all modes for the current user
+   */
+  getMyModes(): Promise<CloudMode[]>;
+
+  /**
+   * Get a specific mode by ID
+   */
+  getModeById(id: string): Promise<CloudMode | null>;
+
+  /**
+   * Update an existing mode
+   */
+  updateMode(id: string, updates: Partial<CloudMode>): Promise<CloudMode>;
+
+  /**
+   * Delete a mode
+   */
+  deleteMode(id: string): Promise<void>;
+
+  /**
+   * Publish a mode (make it public)
+   */
+  publishMode(id: string): Promise<CloudMode>;
+
+  /**
+   * Unpublish a mode (make it private)
+   */
+  unpublishMode(id: string): Promise<CloudMode>;
+
+  /**
+   * Get public modes with pagination and filters
+   */
+  getPublicModes(options: PaginationOptions): Promise<PaginatedResponse<CloudMode>>;
+
+  /**
+   * Like a mode (toggle)
+   */
+  likeMode(modeId: string): Promise<void>;
+
+  /**
+   * Unlike a mode (toggle)
+   */
+  unlikeMode(modeId: string): Promise<void>;
+
+  /**
+   * Rate a mode with optional review
+   */
+  rateMode(modeId: string, rating: number, review?: string): Promise<void>;
+}
+
+// ============================================================================
+// Service Implementation
+// ============================================================================
+
+/**
+ * CloudModeService implementation using Supabase
+ */
+export class CloudModeService implements ICloudModeService {
+  /**
+   * Supabase client injected via constructor
+   */
+  private readonly supabase: SupabaseClient;
+
+  /**
+   * Create a new CloudModeService
+   *
+   * @param supabase - Supabase client instance
+   */
+  constructor(supabase: SupabaseClient) {
+    this.supabase = supabase;
+  }
+
+  /**
+   * Convert database row to CloudMode
+   *
+   * @param row - Database row from Supabase
+   * @returns CloudMode object
+   */
+  private toCloudMode(row: ModeRow): CloudMode {
+    return {
+      id: row.id,
+      authorId: row.author_id,
+      name: row.name,
+      description: row.description || '',
+      version: row.version,
+      controls: row.controls as Record<string, unknown>,
+      isPublic: row.is_public,
+      isOfficial: row.is_official,
+      isFeatured: row.is_featured,
+      downloads: row.downloads,
+      likes: row.likes,
+      views: row.views,
+      rating: row.rating || 0,
+      ratingCount: row.rating_count,
+      forkCount: row.fork_count,
+      tags: row.tags,
+      category: row.category || undefined,
+      thumbnail: row.thumbnail || undefined,
+      parentModeId: row.parent_mode_id || undefined,
+      createdAt: row.created_at,
+      modifiedAt: row.modified_at,
+      publishedAt: row.published_at || undefined,
+      updatedAt: row.modified_at,
+    };
+  }
+
+  /**
+   * Get current user ID from session
+   *
+   * @returns User ID
+   * @throws Error if user is not authenticated
+   */
+  private async getCurrentUserId(): Promise<string> {
+    const {
+      data: { user },
+      error,
+    } = await this.supabase.auth.getUser();
+
+    if (error || !user) {
+      throw new Error('User not authenticated. Please sign in to continue.');
+    }
+
+    return user.id;
+  }
+
+  /**
+   * Save a custom mode to the cloud
+   *
+   * @param mode - Custom mode to save
+   * @returns Saved cloud mode
+   */
+  async saveMode(mode: CustomMode): Promise<CloudMode> {
+    const userId = await this.getCurrentUserId();
+
+    const insert: ModeInsert = {
+      author_id: userId,
+      name: mode.name,
+      description: mode.description,
+      version: mode.version,
+      controls: mode.controls,
+      is_public: false, // Default to private
+      tags: [],
+    };
+
+    const { data, error } = await this.supabase
+      .from('modes')
+      .insert(insert)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to save mode: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('Failed to save mode: No data returned from database');
+    }
+
+    return this.toCloudMode(data as ModeRow);
+  }
+
+  /**
+   * Get all modes for the current user
+   *
+   * @returns Array of user's cloud modes
+   */
+  async getMyModes(): Promise<CloudMode[]> {
+    const userId = await this.getCurrentUserId();
+
+    const { data, error } = await this.supabase
+      .from('modes')
+      .select('*')
+      .eq('author_id', userId)
+      .order('modified_at', { ascending: false });
+
+    if (error) {
+      throw new Error(`Failed to fetch user modes: ${error.message}`);
+    }
+
+    return (data || []).map((row) => this.toCloudMode(row as ModeRow));
+  }
+
+  /**
+   * Get a specific mode by ID
+   *
+   * @param id - Mode ID
+   * @returns Cloud mode or null if not found
+   */
+  async getModeById(id: string): Promise<CloudMode | null> {
+    const { data, error } = await this.supabase
+      .from('modes')
+      .select('*')
+      .eq('id', id)
+      .single();
+
+    if (error) {
+      if (error.code === 'PGRST116') {
+        // Not found
+        return null;
+      }
+      throw new Error(`Failed to fetch mode: ${error.message}`);
+    }
+
+    if (!data) {
+      return null;
+    }
+
+    return this.toCloudMode(data as ModeRow);
+  }
+
+  /**
+   * Update an existing mode
+   *
+   * @param id - Mode ID
+   * @param updates - Partial updates to apply
+   * @returns Updated cloud mode
+   */
+  async updateMode(id: string, updates: Partial<CloudMode>): Promise<CloudMode> {
+    const update: ModeUpdate = {};
+
+    if (updates.name !== undefined) update.name = updates.name;
+    if (updates.description !== undefined) update.description = updates.description;
+    if (updates.version !== undefined) update.version = updates.version;
+    if (updates.controls !== undefined) update.controls = updates.controls;
+    if (updates.isPublic !== undefined) update.is_public = updates.isPublic;
+    if (updates.tags !== undefined) update.tags = updates.tags;
+    if (updates.category !== undefined) update.category = updates.category;
+    if (updates.thumbnail !== undefined) update.thumbnail = updates.thumbnail;
+
+    const { data, error } = await this.supabase
+      .from('modes')
+      .update(update)
+      .eq('id', id)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to update mode: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('Failed to update mode: No data returned from database');
+    }
+
+    return this.toCloudMode(data as ModeRow);
+  }
+
+  /**
+   * Delete a mode
+   *
+   * @param id - Mode ID
+   */
+  async deleteMode(id: string): Promise<void> {
+    const { error } = await this.supabase.from('modes').delete().eq('id', id);
+
+    if (error) {
+      throw new Error(`Failed to delete mode: ${error.message}`);
+    }
+  }
+
+  /**
+   * Publish a mode (make it public)
+   *
+   * @param id - Mode ID
+   * @returns Updated cloud mode
+   */
+  async publishMode(id: string): Promise<CloudMode> {
+    const { data, error } = await this.supabase
+      .from('modes')
+      .update({
+        is_public: true,
+        published_at: new Date().toISOString(),
+      })
+      .eq('id', id)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to publish mode: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('Failed to publish mode: No data returned from database');
+    }
+
+    return this.toCloudMode(data as ModeRow);
+  }
+
+  /**
+   * Unpublish a mode (make it private)
+   *
+   * @param id - Mode ID
+   * @returns Updated cloud mode
+   */
+  async unpublishMode(id: string): Promise<CloudMode> {
+    const { data, error } = await this.supabase
+      .from('modes')
+      .update({
+        is_public: false,
+        published_at: null,
+      })
+      .eq('id', id)
+      .select()
+      .single();
+
+    if (error) {
+      throw new Error(`Failed to unpublish mode: ${error.message}`);
+    }
+
+    if (!data) {
+      throw new Error('Failed to unpublish mode: No data returned from database');
+    }
+
+    return this.toCloudMode(data as ModeRow);
+  }
+
+  /**
+   * Get public modes with pagination and filters
+   *
+   * @param options - Pagination options
+   * @returns Paginated response with cloud modes
+   */
+  async getPublicModes(
+    options: PaginationOptions = {}
+  ): Promise<PaginatedResponse<CloudMode>> {
+    const { page = 1, limit = 20, sort = 'recent' } = options;
+
+    let query = this.supabase
+      .from('modes')
+      .select('*', { count: 'exact' })
+      .eq('is_public', true);
+
+    // Apply sorting
+    switch (sort) {
+      case 'downloads':
+        query = query.order('downloads', { ascending: false });
+        break;
+      case 'likes':
+        query = query.order('likes', { ascending: false });
+        break;
+      case 'rating':
+        query = query.order('rating', { ascending: false, nullsLast: true });
+        break;
+      case 'recent':
+      default:
+        query = query.order('created_at', { ascending: false });
+    }
+
+    // Apply pagination
+    const from = (page - 1) * limit;
+    const to = from + limit - 1;
+    query = query.range(from, to);
+
+    const { data, error, count } = await query;
+
+    if (error) {
+      throw new Error(`Failed to fetch public modes: ${error.message}`);
+    }
+
+    const total = count || 0;
+    const totalPages = Math.ceil(total / limit);
+
+    return {
+      data: (data || []).map((row) => this.toCloudMode(row as ModeRow)),
+      pagination: {
+        page,
+        limit,
+        total,
+        totalPages,
+        hasNext: page < totalPages,
+        hasPrev: page > 1,
+      },
+    };
+  }
+
+  /**
+   * Like a mode (toggle)
+   *
+   * @param modeId - Mode ID
+   */
+  async likeMode(modeId: string): Promise<void> {
+    const userId = await this.getCurrentUserId();
+
+    // Check if already liked
+    const { data: existingLike } = await this.supabase
+      .from('mode_likes')
+      .select('*')
+      .match({ user_id: userId, mode_id: modeId })
+      .single();
+
+    if (existingLike) {
+      // Already liked, do nothing (unlikeMode should be called instead)
+      return;
+    }
+
+    // Insert like
+    const { error: likeError } = await this.supabase
+      .from('mode_likes')
+      .insert({ user_id: userId, mode_id: modeId });
+
+    if (likeError) {
+      throw new Error(`Failed to like mode: ${likeError.message}`);
+    }
+
+    // Increment likes count
+    const { error: updateError } = await this.supabase.rpc('increment_likes', {
+      mode_id: modeId,
+    });
+
+    if (updateError) {
+      throw new Error(`Failed to update likes count: ${updateError.message}`);
+    }
+  }
+
+  /**
+   * Unlike a mode (toggle)
+   *
+   * @param modeId - Mode ID
+   */
+  async unlikeMode(modeId: string): Promise<void> {
+    const userId = await this.getCurrentUserId();
+
+    // Delete like
+    const { error: unlikeError } = await this.supabase
+      .from('mode_likes')
+      .delete()
+      .match({ user_id: userId, mode_id: modeId });
+
+    if (unlikeError) {
+      throw new Error(`Failed to unlike mode: ${unlikeError.message}`);
+    }
+
+    // Decrement likes count
+    const { error: updateError } = await this.supabase.rpc('decrement_likes', {
+      mode_id: modeId,
+    });
+
+    if (updateError) {
+      throw new Error(`Failed to update likes count: ${updateError.message}`);
+    }
+  }
+
+  /**
+   * Rate a mode with optional review
+   *
+   * @param modeId - Mode ID
+   * @param rating - Rating value (1-5)
+   * @param review - Optional review text
+   */
+  async rateMode(modeId: string, rating: number, review?: string): Promise<void> {
+    const userId = await this.getCurrentUserId();
+
+    if (rating < 1 || rating > 5) {
+      throw new Error('Rating must be between 1 and 5');
+    }
+
+    const { error } = await this.supabase.from('mode_ratings').upsert({
+      user_id: userId,
+      mode_id: modeId,
+      rating,
+      review: review || null,
+    });
+
+    if (error) {
+      throw new Error(`Failed to rate mode: ${error.message}`);
+    }
+
+    // Rating aggregate is updated by database trigger
+  }
+}
+
+// ============================================================================
+// Factory Function
+// ============================================================================
+
+/**
+ * Create a CloudModeService instance
+ *
+ * @param supabase - Supabase client instance
+ * @returns CloudModeService instance
+ */
+export function createCloudModeService(supabase: SupabaseClient): ICloudModeService {
+  return new CloudModeService(supabase);
+}
diff --git a/src/types/cloud-mode.ts b/src/types/cloud-mode.ts
new file mode 100644
index 0000000..f07b0a4
--- /dev/null
+++ b/src/types/cloud-mode.ts
@@ -0,0 +1,619 @@
+/**
+ * Cloud Mode Storage Type Definitions
+ *
+ * This module provides TypeScript types for cloud-based mode storage, sharing,
+ * and engagement features. All types align with the Supabase database schema
+ * and extend the base CustomMode interface.
+ *
+ * @module types/cloud-mode
+ */
+
+import { z } from 'zod';
+import { CustomMode, ControlMapping } from '@/types/mode';
+
+// ============================================================================
+// ENUMS AND LITERAL TYPES
+// ============================================================================
+
+/**
+ * Predefined mode categories for organizing and filtering modes
+ */
+export type ModeCategory =
+  | 'daw-control'
+  | 'live-performance'
+  | 'mixing-mastering'
+  | 'instrument-control'
+  | 'genre-specific'
+  | 'educational';
+
+/**
+ * Mode visibility levels
+ */
+export type ModeVisibility = 'private' | 'public' | 'unlisted';
+
+/**
+ * Sorting options for mode lists
+ */
+export type ModeSortOption = 'recent' | 'downloads' | 'likes' | 'rating' | 'views';
+
+// ============================================================================
+// CORE CLOUD MODE INTERFACE
+// ============================================================================
+
+/**
+ * CloudMode extends CustomMode with cloud storage metadata and engagement metrics
+ *
+ * This interface represents a mode stored in the cloud with full metadata,
+ * ownership information, and engagement tracking. It is the primary type used
+ * throughout the application for cloud-stored modes.
+ */
+export interface CloudMode extends CustomMode {
+  // Unique identification
+  /** UUID assigned by database */
+  id: string;
+
+  // Ownership
+  /** UUID of the user who created this mode */
+  authorId: string;
+
+  /** Optional author details (populated via join) */
+  author?: CloudModeAuthor;
+
+  // Visibility flags
+  /** Whether mode is visible in public catalog */
+  isPublic: boolean;
+
+  /** Marks official/verified modes from trusted sources */
+  isOfficial: boolean;
+
+  /** Featured modes shown prominently in UI */
+  isFeatured: boolean;
+
+  // Engagement metrics (denormalized for performance)
+  /** Total number of times mode has been downloaded */
+  downloads: number;
+
+  /** Total number of likes from users */
+  likes: number;
+
+  /** Total number of times mode detail page was viewed */
+  views: number;
+
+  /** Average rating (0-5, decimal) */
+  rating: number;
+
+  /** Total number of ratings submitted */
+  ratingCount: number;
+
+  /** Number of times this mode has been forked */
+  forkCount: number;
+
+  // Discovery metadata
+  /** Search and filtering tags */
+  tags: string[];
+
+  /** Primary category for organization */
+  category?: ModeCategory;
+
+  /** Base64 image or URL to thumbnail (future: Supabase Storage) */
+  thumbnail?: string;
+
+  // Relationships
+  /** UUID of parent mode if this is a fork */
+  parentModeId?: string;
+
+  /** Optional parent mode details (populated via join) */
+  parentMode?: CloudMode;
+
+  // Timestamps
+  /** When mode was first published (null if never published) */
+  publishedAt?: string;
+
+  // Client-side computed properties (not in database)
+  /** Whether current user has liked this mode */
+  userLiked?: boolean;
+
+  /** Current user's rating (1-5) if they rated this mode */
+  userRating?: number;
+}
+
+/**
+ * Author information attached to cloud modes
+ */
+export interface CloudModeAuthor {
+  id: string;
+  email: string;
+  displayName?: string;
+  avatarUrl?: string;
+}
+
+// ============================================================================
+// DATABASE ROW TYPES
+// ============================================================================
+
+/**
+ * Database row type for modes table (snake_case to match PostgreSQL)
+ *
+ * Used for direct Supabase queries and type safety at the database boundary.
+ * Convert to CloudMode interface for application use.
+ */
+export interface ModesTableRow {
+  id: string;
+  author_id: string;
+  name: string;
+  description: string | null;
+  version: string;
+  controls: Record<string, ControlMapping>;
+  is_public: boolean;
+  is_official: boolean;
+  is_featured: boolean;
+  downloads: number;
+  likes: number;
+  views: number;
+  fork_count: number;
+  rating: number | null;
+  rating_count: number;
+  tags: string[];
+  category: string | null;
+  thumbnail: string | null;
+  parent_mode_id: string | null;
+  created_at: string;
+  modified_at: string;
+  published_at: string | null;
+}
+
+/**
+ * Insert type for modes table (fields required for INSERT)
+ */
+export interface ModesTableInsert {
+  id?: string;
+  author_id: string;
+  name: string;
+  description?: string | null;
+  version?: string;
+  controls: Record<string, ControlMapping>;
+  is_public?: boolean;
+  is_official?: boolean;
+  is_featured?: boolean;
+  downloads?: number;
+  likes?: number;
+  views?: number;
+  fork_count?: number;
+  rating?: number | null;
+  rating_count?: number;
+  tags?: string[];
+  category?: string | null;
+  thumbnail?: string | null;
+  parent_mode_id?: string | null;
+  created_at?: string;
+  modified_at?: string;
+  published_at?: string | null;
+}
+
+/**
+ * Update type for modes table (all fields optional)
+ */
+export interface ModesTableUpdate {
+  id?: string;
+  author_id?: string;
+  name?: string;
+  description?: string | null;
+  version?: string;
+  controls?: Record<string, ControlMapping>;
+  is_public?: boolean;
+  is_official?: boolean;
+  is_featured?: boolean;
+  downloads?: number;
+  likes?: number;
+  views?: number;
+  fork_count?: number;
+  rating?: number | null;
+  rating_count?: number;
+  tags?: string[];
+  category?: string | null;
+  thumbnail?: string | null;
+  parent_mode_id?: string | null;
+  created_at?: string;
+  modified_at?: string;
+  published_at?: string | null;
+}
+
+// ============================================================================
+// ENGAGEMENT TYPES
+// ============================================================================
+
+/**
+ * Database row for mode_likes table
+ */
+export interface ModeLike {
+  userId: string;
+  modeId: string;
+  createdAt: string;
+}
+
+/**
+ * Database row type for mode_likes table (snake_case)
+ */
+export interface ModeLikesTableRow {
+  user_id: string;
+  mode_id: string;
+  created_at: string;
+}
+
+/**
+ * Database row for mode_ratings table
+ */
+export interface ModeRating {
+  userId: string;
+  modeId: string;
+  rating: number; // 1-5
+  review?: string;
+  createdAt: string;
+  updatedAt: string;
+}
+
+/**
+ * Database row type for mode_ratings table (snake_case)
+ */
+export interface ModeRatingsTableRow {
+  user_id: string;
+  mode_id: string;
+  rating: number;
+  review: string | null;
+  created_at: string;
+  updated_at: string;
+}
+
+/**
+ * Aggregate engagement metrics for a mode
+ */
+export interface ModeEngagement {
+  /** Whether current user has liked this mode */
+  liked: boolean;
+
+  /** Total number of likes */
+  likesCount: number;
+
+  /** Current user's rating (1-5) if they rated */
+  userRating?: number;
+
+  /** Average rating across all users */
+  averageRating: number;
+
+  /** Total number of ratings */
+  ratingCount: number;
+}
+
+// ============================================================================
+// VERSION HISTORY TYPES
+// ============================================================================
+
+/**
+ * Mode version history entry
+ *
+ * Tracks changes to a mode over time, storing complete control configurations
+ * for each version.
+ */
+export interface ModeVersion {
+  id: string;
+  modeId: string;
+  version: string; // Semantic version (e.g., "1.2.3")
+  changes: string; // Changelog/release notes
+  controls: Record<string, ControlMapping>;
+  createdAt: string;
+}
+
+/**
+ * Database row type for mode_versions table (snake_case)
+ */
+export interface ModeVersionsTableRow {
+  id: string;
+  mode_id: string;
+  version: string;
+  changes: string | null;
+  controls: Record<string, ControlMapping>;
+  created_at: string;
+}
+
+// ============================================================================
+// CATEGORY TYPES
+// ============================================================================
+
+/**
+ * Mode category definition
+ */
+export interface Category {
+  id: ModeCategory;
+  name: string;
+  description: string;
+  icon?: string;
+  displayOrder: number;
+}
+
+/**
+ * Database row type for categories table (snake_case)
+ */
+export interface CategoriesTableRow {
+  id: string;
+  name: string;
+  description: string | null;
+  icon: string | null;
+  display_order: number;
+}
+
+// ============================================================================
+// METADATA AND FILTER TYPES
+// ============================================================================
+
+/**
+ * Metadata for creating or updating a cloud mode
+ *
+ * Contains non-control data needed to describe and categorize a mode.
+ */
+export interface CloudModeMetadata {
+  name: string;
+  description: string;
+  tags: string[];
+  category?: ModeCategory;
+  isPublic: boolean;
+  thumbnail?: string;
+}
+
+/**
+ * Filter and query options for browsing modes
+ *
+ * Used to build database queries with filtering, sorting, and pagination.
+ */
+export interface ModeFilters {
+  /** Filter by category */
+  category?: ModeCategory;
+
+  /** Filter by tags (modes must have ALL specified tags) */
+  tags?: string[];
+
+  /** Filter by author */
+  authorId?: string;
+
+  /** Filter by public/private status */
+  isPublic?: boolean;
+
+  /** Filter featured modes only */
+  isFeatured?: boolean;
+
+  /** Sort order */
+  sort?: ModeSortOption;
+
+  /** Full-text search query */
+  search?: string;
+
+  /** Pagination: page number (1-based) */
+  page?: number;
+
+  /** Pagination: items per page */
+  limit?: number;
+}
+
+/**
+ * Paginated response wrapper
+ *
+ * Standard format for paginated API responses with metadata.
+ */
+export interface PaginatedResponse<T> {
+  data: T[];
+  pagination: {
+    page: number;
+    limit: number;
+    total: number;
+    totalPages: number;
+    hasNext: boolean;
+    hasPrev: boolean;
+  };
+}
+
+// ============================================================================
+// API OPERATION TYPES
+// ============================================================================
+
+/**
+ * Parameters for creating a new cloud mode
+ */
+export interface CreateModeParams {
+  mode: CustomMode;
+  metadata: CloudModeMetadata;
+}
+
+/**
+ * Parameters for updating an existing mode
+ */
+export interface UpdateModeParams {
+  modeId: string;
+  updates: Partial<CloudMode>;
+}
+
+/**
+ * Parameters for forking a mode
+ */
+export interface ForkModeParams {
+  modeId: string;
+  overrides?: {
+    name?: string;
+    description?: string;
+  };
+}
+
+/**
+ * Parameters for rating a mode
+ */
+export interface RateModeParams {
+  modeId: string;
+  rating: number; // 1-5
+  review?: string;
+}
+
+/**
+ * Response from like/unlike operation
+ */
+export interface LikeResponse {
+  liked: boolean;
+  likesCount: number;
+}
+
+/**
+ * Response from rating operation
+ */
+export interface RatingResponse {
+  averageRating: number;
+  ratingCount: number;
+}
+
+// ============================================================================
+// VALIDATION SCHEMAS (ZOD)
+// ============================================================================
+
+/**
+ * Zod schema for ControlMapping validation
+ */
+export const ControlMappingSchema = z.object({
+  id: z.string(),
+  type: z.enum(['knob', 'fader', 'button']),
+  ccNumber: z.number().int().min(0).max(127),
+  midiChannel: z.number().int().min(1).max(16),
+  minValue: z.number().int().min(0).max(127),
+  maxValue: z.number().int().min(0).max(127),
+  label: z.string().max(50).optional(),
+});
+
+/**
+ * Zod schema for CloudModeMetadata validation
+ */
+export const CloudModeMetadataSchema = z.object({
+  name: z.string()
+    .min(1, 'Name is required')
+    .max(255, 'Name must be 255 characters or less')
+    .regex(/^[a-zA-Z0-9\s\-_().]+$/, 'Name contains invalid characters'),
+  description: z.string()
+    .max(1000, 'Description must be 1000 characters or less'),
+  tags: z.array(z.string().max(30, 'Tag must be 30 characters or less'))
+    .max(10, 'Maximum 10 tags allowed'),
+  category: z.enum([
+    'daw-control',
+    'live-performance',
+    'mixing-mastering',
+    'instrument-control',
+    'genre-specific',
+    'educational',
+  ]).optional(),
+  isPublic: z.boolean(),
+  thumbnail: z.string().optional(),
+});
+
+/**
+ * Zod schema for mode version string validation (semantic versioning)
+ */
+export const ModeVersionSchema = z.string()
+  .regex(/^\d+\.\d+\.\d+$/, 'Version must follow semantic versioning (e.g., 1.0.0)');
+
+/**
+ * Zod schema for rating validation
+ */
+export const RatingSchema = z.number()
+  .int('Rating must be an integer')
+  .min(1, 'Rating must be at least 1')
+  .max(5, 'Rating must be at most 5');
+
+/**
+ * Zod schema for review text validation
+ */
+export const ReviewSchema = z.string()
+  .max(2000, 'Review must be 2000 characters or less')
+  .optional();
+
+/**
+ * Zod schema for ModeFilters validation
+ */
+export const ModeFiltersSchema = z.object({
+  category: z.enum([
+    'daw-control',
+    'live-performance',
+    'mixing-mastering',
+    'instrument-control',
+    'genre-specific',
+    'educational',
+  ]).optional(),
+  tags: z.array(z.string()).optional(),
+  authorId: z.string().uuid().optional(),
+  isPublic: z.boolean().optional(),
+  isFeatured: z.boolean().optional(),
+  sort: z.enum(['recent', 'downloads', 'likes', 'rating', 'views']).optional(),
+  search: z.string().max(200).optional(),
+  page: z.number().int().positive().optional(),
+  limit: z.number().int().positive().max(100).optional(),
+});
+
+// ============================================================================
+// TYPE GUARDS
+// ============================================================================
+
+/**
+ * Type guard to check if a mode is a CloudMode
+ */
+export function isCloudMode(mode: CustomMode | CloudMode): mode is CloudMode {
+  return 'id' in mode && 'authorId' in mode;
+}
+
+/**
+ * Type guard to check if a mode is public
+ */
+export function isPublicMode(mode: CloudMode): boolean {
+  return mode.isPublic === true;
+}
+
+/**
+ * Type guard to check if a mode is featured
+ */
+export function isFeaturedMode(mode: CloudMode): boolean {
+  return mode.isFeatured === true;
+}
+
+/**
+ * Type guard to check if a mode is forked
+ */
+export function isForkedMode(mode: CloudMode): boolean {
+  return mode.parentModeId !== undefined && mode.parentModeId !== null;
+}
+
+// ============================================================================
+// UTILITY TYPES
+// ============================================================================
+
+/**
+ * Extract only the fields that can be updated by users
+ */
+export type UpdatableCloudModeFields = Pick<
+  CloudMode,
+  'name' | 'description' | 'version' | 'controls' | 'isPublic' | 'tags' | 'category' | 'thumbnail'
+>;
+
+/**
+ * Omit computed/derived fields from CloudMode
+ */
+export type CloudModeWithoutComputed = Omit<CloudMode, 'userLiked' | 'userRating' | 'author' | 'parentMode'>;
+
+/**
+ * Mode summary for list views (minimal fields for performance)
+ */
+export interface CloudModeSummary {
+  id: string;
+  name: string;
+  description: string;
+  authorId: string;
+  category?: ModeCategory;
+  tags: string[];
+  thumbnail?: string;
+  downloads: number;
+  likes: number;
+  rating: number;
+  ratingCount: number;
+  createdAt: string;
+  modifiedAt: string;
+}


---

_**Agent (claude-sonnet-4-5-20250929)**_

```
docs(cloud): add cloud storage implementation workplan and components
```

