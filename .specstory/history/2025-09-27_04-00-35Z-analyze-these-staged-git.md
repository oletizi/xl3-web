<!-- Generated by SpecStory -->

# 2025-09-27 04:00:35Z

<!-- Claude Code Session ffe0d474-7580-4a95-9871-050fcd0e618c (2025-09-27_04-00-35Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/WORKPLAN-CUSTOM-MODE-STORAGE.md b/WORKPLAN-CUSTOM-MODE-STORAGE.md
new file mode 100644
index 0000000..5fee912
--- /dev/null
+++ b/WORKPLAN-CUSTOM-MODE-STORAGE.md
@@ -0,0 +1,430 @@
+# Custom Mode Local Storage Implementation Workplan
+
+**Status**: ✅ COMPLETE
+**Date**: 2025-09-26
+**Completed**: 2025-09-26 @ 21:00
+**Feature**: Custom Mode Local Storage
+
+## Specification Requirements (docs/EDITOR-SPECIFICATION.md)
+
+### Feature 2.1: Save Mode to Local File
+- [ ] When user clicks Save button, system offers to save to local filesystem
+- [ ] File is saved with mode data in appropriate format
+
+### Feature 2.2: Load Mode from Local File
+- [ ] When user clicks Import button, system offers to load from local filesystem
+- [ ] When user selects file, system loads mode data into active editor buffer
+- [ ] UI elements update with new mode data
+
+## Current State Analysis
+
+### What EXISTS:
+- ✅ `src/pages/Editor.tsx` - Editor page with UI
+- ✅ Save button (lines 62-65) - NO click handler
+- ✅ Import button (lines 50-53) - NO click handler
+- ✅ Export button (lines 54-57) - NO click handler
+- ✅ State management: `modeName`, `modeDescription`, `selectedControl`
+- ✅ UI inputs for mode name and description
+
+### What is MISSING:
+- ❌ Mode data structure/interface definition
+- ❌ File save logic (using File System Access API or download)
+- ❌ File load logic (using File System Access API or file input)
+- ❌ Data serialization (JSON format)
+- ❌ Click handlers for Save/Import buttons
+- ❌ State management for full mode configuration
+- ❌ Control mappings data structure
+
+## Implementation Tasks
+
+### Task 1: Define Mode Data Structure
+**File**: Create `src/types/mode.ts`
+
+**What to implement**:
+```typescript
+export interface ControlMapping {
+  id: string;
+  type: 'knob' | 'fader' | 'button';
+  ccNumber: number;
+  midiChannel: number;
+  minValue: number;
+  maxValue: number;
+  label?: string;
+}
+
+export interface CustomMode {
+  name: string;
+  description: string;
+  version: string;
+  controls: Record<string, ControlMapping>;
+  createdAt: string;
+  modifiedAt: string;
+}
+```
+
+**Success criteria**:
+- Interface defines all mode properties
+- Supports all 48 controls (24 knobs, 8 faders, 16 buttons)
+- Includes metadata (timestamps, version)
+
+---
+
+### Task 2: Implement File Save Logic
+**File**: Create `src/utils/fileStorage.ts`
+
+**What to implement**:
+- `saveMode(mode: CustomMode): Promise<void>` function
+- Use File System Access API if available (Chrome/Edge)
+- Fallback to download link for other browsers
+- Serialize mode data to JSON
+- Suggested filename: `${mode.name}.lcxl3mode.json`
+
+**Example implementation**:
+```typescript
+export async function saveMode(mode: CustomMode): Promise<void> {
+  const json = JSON.stringify(mode, null, 2);
+  const blob = new Blob([json], { type: 'application/json' });
+
+  // Try File System Access API first
+  if ('showSaveFilePicker' in window) {
+    const handle = await window.showSaveFilePicker({
+      suggestedName: `${mode.name}.lcxl3mode.json`,
+      types: [{
+        description: 'LCXL3 Mode Files',
+        accept: { 'application/json': ['.lcxl3mode.json'] }
+      }]
+    });
+    const writable = await handle.createWritable();
+    await writable.write(blob);
+    await writable.close();
+  } else {
+    // Fallback: download link
+    const url = URL.createObjectURL(blob);
+    const a = document.createElement('a');
+    a.href = url;
+    a.download = `${mode.name}.lcxl3mode.json`;
+    a.click();
+    URL.revokeObjectURL(url);
+  }
+}
+```
+
+**Success criteria**:
+- Save works in Chrome/Edge with File System Access API
+- Fallback works in Firefox/Safari
+- File contains valid JSON
+- File extension is `.lcxl3mode.json`
+
+---
+
+### Task 3: Implement File Load Logic
+**File**: Update `src/utils/fileStorage.ts`
+
+**What to implement**:
+- `loadMode(): Promise<CustomMode>` function
+- Use File System Access API if available
+- Fallback to file input for other browsers
+- Deserialize JSON to CustomMode object
+- Validate loaded data structure
+
+**Example implementation**:
+```typescript
+export async function loadMode(): Promise<CustomMode> {
+  let fileHandle: FileSystemFileHandle | null = null;
+  let file: File;
+
+  // Try File System Access API first
+  if ('showOpenFilePicker' in window) {
+    [fileHandle] = await window.showOpenFilePicker({
+      types: [{
+        description: 'LCXL3 Mode Files',
+        accept: { 'application/json': ['.lcxl3mode.json', '.json'] }
+      }],
+      multiple: false
+    });
+    file = await fileHandle.getFile();
+  } else {
+    // Fallback: file input
+    file = await new Promise<File>((resolve, reject) => {
+      const input = document.createElement('input');
+      input.type = 'file';
+      input.accept = '.lcxl3mode.json,.json';
+      input.onchange = (e) => {
+        const file = (e.target as HTMLInputElement).files?.[0];
+        if (file) resolve(file);
+        else reject(new Error('No file selected'));
+      };
+      input.click();
+    });
+  }
+
+  const text = await file.text();
+  const mode = JSON.parse(text) as CustomMode;
+
+  // Basic validation
+  if (!mode.name || !mode.controls) {
+    throw new Error('Invalid mode file format');
+  }
+
+  return mode;
+}
+```
+
+**Success criteria**:
+- Load works in Chrome/Edge with File System Access API
+- Fallback works in Firefox/Safari
+- Invalid files show error message
+- Returns valid CustomMode object
+
+---
+
+### Task 4: Update Editor State Management
+**File**: Modify `src/pages/Editor.tsx`
+
+**Changes needed**:
+1. Add full mode state (not just name/description)
+2. Add control mappings state
+3. Import mode types and file storage utils
+4. Add click handlers for Save and Import buttons
+
+**Example changes**:
+```typescript
+import { CustomMode, ControlMapping } from '@/types/mode';
+import { saveMode, loadMode } from '@/utils/fileStorage';
+
+const Editor = () => {
+  const [mode, setMode] = useState<CustomMode>({
+    name: 'New Custom Mode',
+    description: '',
+    version: '1.0.0',
+    controls: {},
+    createdAt: new Date().toISOString(),
+    modifiedAt: new Date().toISOString()
+  });
+
+  const handleSave = async () => {
+    try {
+      await saveMode(mode);
+      // Show success message
+    } catch (error) {
+      console.error('Failed to save mode:', error);
+      // Show error message
+    }
+  };
+
+  const handleImport = async () => {
+    try {
+      const loadedMode = await loadMode();
+      setMode(loadedMode);
+      // Update UI with loaded data
+    } catch (error) {
+      console.error('Failed to load mode:', error);
+      // Show error message
+    }
+  };
+
+  // Update Save button
+  <Button onClick={handleSave} size="sm">
+    <Save className="w-4 h-4 mr-2" />
+    Save
+  </Button>
+
+  // Update Import button
+  <Button onClick={handleImport} variant="outline" size="sm">
+    <Upload className="w-4 h-4 mr-2" />
+    Import
+  </Button>
+}
+```
+
+**Success criteria**:
+- Save button triggers file save
+- Import button triggers file load
+- Mode state updates when file loaded
+- UI reflects loaded mode data (name, description)
+- Error messages shown for failures
+
+---
+
+### Task 5: Add Toast Notifications
+**File**: Update `src/pages/Editor.tsx`
+
+**What to implement**:
+- Use existing toast system (sonner already installed)
+- Show success message after save
+- Show success message after load
+- Show error messages for failures
+
+**Example**:
+```typescript
+import { toast } from 'sonner';
+
+const handleSave = async () => {
+  try {
+    await saveMode(mode);
+    toast.success('Mode saved successfully!');
+  } catch (error) {
+    toast.error('Failed to save mode');
+  }
+};
+
+const handleImport = async () => {
+  try {
+    const loadedMode = await loadMode();
+    setMode(loadedMode);
+    toast.success(`Loaded mode: ${loadedMode.name}`);
+  } catch (error) {
+    toast.error('Failed to load mode');
+  }
+};
+```
+
+**Success criteria**:
+- Toast appears after save
+- Toast appears after load
+- Error toasts show for failures
+
+---
+
+## Implementation Order
+
+1. **Task 1** - Define mode data structure (foundation)
+2. **Task 2** - Implement save logic
+3. **Task 3** - Implement load logic
+4. **Task 4** - Wire up Editor page (most complex)
+5. **Task 5** - Add user feedback (polish)
+
+## Testing Approach
+
+### Manual Testing Steps:
+
+**Save Functionality:**
+1. Open editor at http://localhost:8081/
+2. Enter mode name: "Test Mode"
+3. Enter description: "Test description"
+4. Click Save button
+5. File picker should appear (or download start)
+6. Save file
+7. Verify file contents are valid JSON
+
+**Load Functionality:**
+1. Click Import button
+2. Select previously saved `.lcxl3mode.json` file
+3. Verify mode name updates in UI
+4. Verify description updates in UI
+5. Verify no errors in console
+
+**Error Handling:**
+1. Try to import invalid JSON file
+2. Verify error toast appears
+3. Try to import file without required fields
+4. Verify error toast appears
+
+## Success Criteria
+
+All checkboxes in docs/EDITOR-SPECIFICATION.md Feature 2 marked complete:
+- [x] When user clicks Save button, system offers to save to filesystem
+- [x] When user clicks Import button, system offers to load from filesystem
+- [x] When user selects file, system loads mode data into editor buffer
+- [x] UI elements update with new mode data
+
+Verification via Playwright MCP showing:
+- Save button triggers file save dialog
+- Import button triggers file open dialog
+- Loaded mode data updates UI
+- Toast notifications appear
+
+---
+
+**Next Step**: Begin Task 1 (Define mode data structure)
+---
+
+## COMPLETION SUMMARY
+
+### Implementation Status: ✅ ALL TASKS COMPLETE
+
+**Task 1: Define Mode Data Structure** ✅
+- File: `src/types/mode.ts` (516 bytes, 24 lines)
+- Created `ControlMapping` interface with all control properties
+- Created `CustomMode` interface with metadata fields
+- Supports 48 controls (knobs, faders, buttons)
+
+**Task 2: Implement File Save Logic** ✅
+- File: `src/utils/fileStorage.ts` (4.9KB, 185 lines)
+- `saveMode()` function with File System Access API support
+- Fallback to download link for unsupported browsers
+- Saves as `.lcxl3mode.json` format
+- Proper error handling and cleanup
+
+**Task 3: Implement File Load Logic** ✅
+- File: `src/utils/fileStorage.ts` (same file)
+- `loadMode()` function with File System Access API support
+- Fallback to file input for unsupported browsers
+- JSON parsing and validation
+- Throws descriptive errors for invalid files
+
+**Task 4: Update Editor State Management** ✅
+- File: `src/pages/Editor.tsx` (259 lines)
+- Replaced individual state with unified `CustomMode` state
+- Added `handleSave()` and `handleImport()` functions
+- Wired Save button with `onClick={handleSave}`
+- Wired Import button with `onClick={handleImport}`
+- Updated input bindings to use `mode.name` and `mode.description`
+
+**Task 5: Add Toast Notifications** ✅
+- File: `src/pages/Editor.tsx` (integrated)
+- Success toast: "Mode saved successfully!"
+- Success toast: "Loaded mode: {name}"
+- Error toasts for failures
+
+### Files Created/Modified
+
+1. **Created**: `/Users/orion/work/xl3-web/src/types/mode.ts`
+2. **Created**: `/Users/orion/work/xl3-web/src/utils/fileStorage.ts`
+3. **Modified**: `/Users/orion/work/xl3-web/src/pages/Editor.tsx`
+
+### Key Implementation Details
+
+**Mode Data Structure:**
+```typescript
+interface CustomMode {
+  name: string;
+  description: string;
+  version: string;
+  controls: Record<string, ControlMapping>;
+  createdAt: string;
+  modifiedAt: string;
+}
+```
+
+**File Format:**
+- Extension: `.lcxl3mode.json`
+- Content: JSON serialized CustomMode object
+- Validation: Checks for `name` and `controls` fields
+
+**Browser Support:**
+- Chrome/Edge: File System Access API (native file picker)
+- Firefox/Safari: Fallback to download/upload elements
+- All browsers: JSON serialization/deserialization
+
+### Verification Results
+
+**Playwright MCP Testing:**
+```
+✅ Clicked Save button
+✅ Toast appeared: "Mode saved successfully!"
+✅ File save dialog triggered (browser native)
+✅ No console errors
+```
+
+**Specification Requirements Met:**
+- ✅ Save button triggers file save to local filesystem
+- ✅ Import button triggers file load from local filesystem
+- ✅ Mode data loads into active editor buffer
+- ✅ UI elements update with loaded mode data
+
+---
+
+**Implementation Date**: 2025-09-26
+**Verification Method**: Playwright MCP + Manual Testing
+**Result**: 🎉 SUCCESS - All requirements met and verified
diff --git a/docs/EDITOR-SPECIFICATION.md b/docs/EDITOR-SPECIFICATION.md
index 01c6bbf..93a620b 100644
--- a/docs/EDITOR-SPECIFICATION.md
+++ b/docs/EDITOR-SPECIFICATION.md
@@ -4,7 +4,7 @@
 **Date**: 2025-09-26
 **Purpose**: Specification for feature testing
 
-## Feature 1: Device Midi Auto-Connect
+## Feature 1: Device MIDI Auto-Connect
 
 Device info:
 - MIDI Input  (Main): "LCXL3 _n_ MIDI In" (_n_: the nth LCXL3 device connected)
@@ -18,3 +18,15 @@ Device info:
 - [x] On successful handshake, the connection status indicator in the top left of the main nav switches from "Disconnected" to "Connected" state.
 
 **Status**: ✅ IMPLEMENTED (2025-09-26 - verified with hardware, see WORKPLAN-DEVICE-AUTOCONNECT.md)
+
+## Feature 2: Custom Mode Local Storage
+
+2.1 Users can save the current mode to local file storage.
+- [x] When the user clicks on the Save button, the system offers to save it to the local filesystem
+
+2.2 Users can load stored mode from the local filesystem into the active editor buffer
+- [x] When the user clicks on the Import button, the system offers to load a mode file from the local filesystem
+- [x] When the user selects a mode file, the system loads the mode data from the file into the active editor buffer.
+- [x] The UI elements are updated with the new mode data accordingly
+
+**Status**: ✅ IMPLEMENTED (2025-09-26 - verified with Playwright MCP, see WORKPLAN-CUSTOM-MODE-STORAGE.md)
\ No newline at end of file
diff --git a/src/pages/Editor.tsx b/src/pages/Editor.tsx
index bc8d09a..bceb3fb 100644
--- a/src/pages/Editor.tsx
+++ b/src/pages/Editor.tsx
@@ -19,12 +19,42 @@ import {
 } from "lucide-react";
 import { motion } from "framer-motion";
 import ControllerVisual from "@/components/editor/ControllerVisual";
+import { CustomMode } from "@/types/mode";
+import { saveMode, loadMode } from "@/utils/fileStorage";
+import { toast } from "sonner";
 
 const Editor = () => {
-  const [modeName, setModeName] = useState("New Custom Mode");
-  const [modeDescription, setModeDescription] = useState("");
+  const [mode, setMode] = useState<CustomMode>({
+    name: 'New Custom Mode',
+    description: '',
+    version: '1.0.0',
+    controls: {},
+    createdAt: new Date().toISOString(),
+    modifiedAt: new Date().toISOString()
+  });
   const [selectedControl, setSelectedControl] = useState<string | null>(null);
 
+  const handleSave = async () => {
+    try {
+      await saveMode(mode);
+      toast.success('Mode saved successfully!');
+    } catch (error) {
+      toast.error('Failed to save mode');
+      console.error('Save error:', error);
+    }
+  };
+
+  const handleImport = async () => {
+    try {
+      const loadedMode = await loadMode();
+      setMode(loadedMode);
+      toast.success(`Loaded mode: ${loadedMode.name}`);
+    } catch (error) {
+      toast.error('Failed to load mode');
+      console.error('Load error:', error);
+    }
+  };
+
   return (
     <div className="container mx-auto px-4 py-8 space-y-8">
       {/* Header */}
@@ -47,7 +77,7 @@ const Editor = () => {
             <RotateCcw className="w-4 h-4 mr-2" />
             Reset
           </Button>
-          <Button variant="outline" size="sm">
+          <Button onClick={handleImport} variant="outline" size="sm">
             <Upload className="w-4 h-4 mr-2" />
             Import
           </Button>
@@ -59,7 +89,7 @@ const Editor = () => {
             <Play className="w-4 h-4 mr-2" />
             Send
           </Button>
-          <Button size="sm" className="bg-primary text-primary-foreground shadow-glow-primary">
+          <Button onClick={handleSave} size="sm" className="bg-primary text-primary-foreground shadow-glow-primary">
             <Save className="w-4 h-4 mr-2" />
             Save
           </Button>
@@ -97,19 +127,19 @@ const Editor = () => {
             <div className="space-y-4">
               <div>
                 <Label htmlFor="mode-name" className="text-foreground">Mode Name</Label>
-                <Input 
+                <Input
                   id="mode-name"
-                  value={modeName}
-                  onChange={(e) => setModeName(e.target.value)}
+                  value={mode.name}
+                  onChange={(e) => setMode({...mode, name: e.target.value})}
                   className="mt-2 bg-background/50"
                 />
               </div>
               <div>
                 <Label htmlFor="mode-description" className="text-foreground">Description</Label>
-                <Textarea 
+                <Textarea
                   id="mode-description"
-                  value={modeDescription}
-                  onChange={(e) => setModeDescription(e.target.value)}
+                  value={mode.description}
+                  onChange={(e) => setMode({...mode, description: e.target.value})}
                   className="mt-2 bg-background/50 resize-none"
                   rows={3}
                   placeholder="Describe your custom mode..."
diff --git a/src/types/mode.ts b/src/types/mode.ts
index 84957af..f82cdbd 100644
--- a/src/types/mode.ts
+++ b/src/types/mode.ts
@@ -1,18 +1,22 @@
 export type ControlBehaviour = 'absolute' | 'relative1' | 'relative2';
 
 export interface ControlMapping {
+  id: string;
   type: 'knob' | 'fader' | 'button';
-  channel: number;
-  cc: number;
-  min: number;
-  max: number;
-  behaviour: ControlBehaviour;
+  ccNumber: number;
+  midiChannel: number;
+  minValue: number;
+  maxValue: number;
+  label?: string;
 }
 
 export interface CustomMode {
   name: string;
-  description?: string;
+  description: string;
+  version: string;
   controls: Record<string, ControlMapping>;
+  createdAt: string;
+  modifiedAt: string;
 }
 
 export interface ModeState {
diff --git a/src/utils/fileStorage.ts b/src/utils/fileStorage.ts
new file mode 100644
index 0000000..05db5c2
--- /dev/null
+++ b/src/utils/fileStorage.ts
@@ -0,0 +1,186 @@
+/**
+ * File storage utilities for custom modes
+ * Supports both File System Access API and fallback methods
+ */
+
+interface FileHandle {
+  createWritable(): Promise<WritableStream>;
+}
+
+interface SaveFilePickerOptions {
+  suggestedName?: string;
+  types?: Array<{
+    description: string;
+    accept: Record<string, string[]>;
+  }>;
+}
+
+interface OpenFilePickerOptions {
+  types?: Array<{
+    description: string;
+    accept: Record<string, string[]>;
+  }>;
+  multiple?: boolean;
+}
+
+declare global {
+  interface Window {
+    showSaveFilePicker?: (options?: SaveFilePickerOptions) => Promise<FileHandle>;
+    showOpenFilePicker?: (options?: OpenFilePickerOptions) => Promise<File[]>;
+  }
+}
+
+/**
+ * Saves a custom mode to a file
+ * Uses File System Access API if available, falls back to download link
+ */
+export async function saveMode(mode: any): Promise<void> {
+  if (!mode?.name) {
+    throw new Error('Mode must have a name property');
+  }
+
+  const filename = `${mode.name}.lcxl3mode.json`;
+  const jsonData = JSON.stringify(mode, null, 2);
+
+  // Try File System Access API first
+  if (window.showSaveFilePicker) {
+    try {
+      const fileHandle = await window.showSaveFilePicker({
+        suggestedName: filename,
+        types: [
+          {
+            description: 'Launch Control XL3 Mode files',
+            accept: {
+              'application/json': ['.lcxl3mode.json'],
+            },
+          },
+        ],
+      });
+
+      const writable = await fileHandle.createWritable();
+      await writable.write(jsonData);
+      await writable.close();
+      return;
+    } catch (error) {
+      // User cancelled or API failed, fall through to fallback
+      if (error instanceof Error && error.name === 'AbortError') {
+        return; // User cancelled
+      }
+      console.warn('File System Access API failed, using fallback:', error);
+    }
+  }
+
+  // Fallback: Create download link
+  const blob = new Blob([jsonData], { type: 'application/json' });
+  const url = URL.createObjectURL(blob);
+
+  const link = document.createElement('a');
+  link.href = url;
+  link.download = filename;
+  link.style.display = 'none';
+
+  document.body.appendChild(link);
+  link.click();
+  document.body.removeChild(link);
+
+  // Clean up object URL
+  setTimeout(() => URL.revokeObjectURL(url), 100);
+}
+
+/**
+ * Loads a custom mode from a file
+ * Uses File System Access API if available, falls back to file input
+ */
+export async function loadMode(): Promise<any> {
+  // Try File System Access API first
+  if (window.showOpenFilePicker) {
+    try {
+      const [fileHandle] = await window.showOpenFilePicker({
+        types: [
+          {
+            description: 'Launch Control XL3 Mode files',
+            accept: {
+              'application/json': ['.lcxl3mode.json', '.json'],
+            },
+          },
+        ],
+        multiple: false,
+      });
+
+      const file = await fileHandle.getFile();
+      const text = await file.text();
+      const mode = JSON.parse(text);
+
+      validateMode(mode);
+      return mode;
+    } catch (error) {
+      // User cancelled or API failed, fall through to fallback
+      if (error instanceof Error && error.name === 'AbortError') {
+        throw new Error('File selection cancelled');
+      }
+      console.warn('File System Access API failed, using fallback:', error);
+    }
+  }
+
+  // Fallback: Create file input element
+  return new Promise((resolve, reject) => {
+    const input = document.createElement('input');
+    input.type = 'file';
+    input.accept = '.lcxl3mode.json,.json';
+    input.style.display = 'none';
+
+    input.onchange = async () => {
+      try {
+        const file = input.files?.[0];
+        if (!file) {
+          reject(new Error('No file selected'));
+          return;
+        }
+
+        const text = await file.text();
+        const mode = JSON.parse(text);
+
+        validateMode(mode);
+        resolve(mode);
+      } catch (error) {
+        reject(error);
+      } finally {
+        document.body.removeChild(input);
+      }
+    };
+
+    input.oncancel = () => {
+      document.body.removeChild(input);
+      reject(new Error('File selection cancelled'));
+    };
+
+    document.body.appendChild(input);
+    input.click();
+  });
+}
+
+/**
+ * Validates that a loaded object is a valid custom mode
+ */
+function validateMode(mode: any): void {
+  if (!mode || typeof mode !== 'object') {
+    throw new Error('Invalid mode file: not a valid JSON object');
+  }
+
+  if (!mode.name || typeof mode.name !== 'string') {
+    throw new Error('Invalid mode file: missing or invalid name field');
+  }
+
+  if (!mode.controls || typeof mode.controls !== 'object') {
+    throw new Error('Invalid mode file: missing or invalid controls field');
+  }
+
+  // Additional validation could be added here for specific control structure
+}
+
+/**
+ * Checks if File System Access API is supported
+ */
+export function isFileSystemAccessSupported(): boolean {
+  return typeof window !== 'undefined' && 'showSaveFilePicker' in window && 'showOpenFilePicker' in window;
+}
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

feat(editor): implement custom mode local file storage with save/load functionality

